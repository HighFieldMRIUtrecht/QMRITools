(* ::Package:: *)

(* ::Title:: *)
(*QMRITools CardiacTools*)


(* ::Subtitle:: *)
(*Written by: Martijn Froeling, PhD*)
(*m.froeling@gmail.com*)


(* ::Section:: *)
(*Begin Package*)


BeginPackage["QMRITools`CardiacTools`", Join[{"Developer`"}, Complement[QMRITools`$Contexts, {"QMRITools`CardiacTools`"}]]];


(* ::Section:: *)
(*Usage Notes*)


(* ::Subsection:: *)
(*Functions*)


HelixAngleCalc::usage = 
"HelixAngleCalc[eigenvectors, mask, vox] calculates the helix angle matrix of cardiac data using only a left ventricle mask.
HelixAngleCalc[eigenvectors, mask, maskp, vox] calculates the helix angle matrix of cardiac data using only a left ventricle mask, and a maskp for visualization.
HelixAngleCalc[eigenvectors, mask, centerpoint, vec, inout, vox]  calculates the helix angle matrix of cardiac data using only a left ventricle mask.
HelixAngleCalc[eigenvectors, mask, maskp, centerpoint, vec, inout, vox] calculates the helix angle matrix of cardiac data using a left vantricle mask and a maskp for visualization.

eigenvectors are the tensor eigenvectors calculated with EigenvecCalc.
mask is a mask of the left ventricle.
maskp is a mask used for visualization.
vox is the voxels size, {slice, x, y}.

The folowing values are calculated automaticlay Using CentralAxes but can also be provided as an input.
centerpoint is the center of each slice calculated with CentralAxes.
inout is the inner and outer radius calcualted with CentralAxes.
vec is the vector describin the central axes of the heart, calculated with CentralAxes.

Output is het fiber angle matrix FAM = {9, slice, x, y} or {FAM, plot}.
The angles are in degrees. 

HelixAngleCalc[] is based on DOI: 10.1186/1532-429X-17-S1-P15."

MaskHelix::usage = 
"MaskHelix[helix, mask] masks helix angle data, sets the background to -100 and allows for Median filter of the helix mask.
helix can be a singel map or the FAM.

Output is the masked helix angle data."

CalculateWallMap::usage = 
"CalculateWallMap[mask,vox] calculates the wall distance map and the wall derivative.

Output is {wallmap, wallDerivative}."

CentralAxes::usage = 
"CentralAxes[mask, vox] calculates the center of the lumen from a mask of the left ventricle. vox is the voxels size, {slice, x, y}.
CentralAxes[mask, maskp, vox] allows for fancy visualization of the other structures using maskp.

Output is {centerpoints, normalvecs, inout} or {centerpoints, normalvecs, inout, fit}."


GetMaskSegmentPoints::usage = 
"GetMaskSegmentPoints[mask]."

CardiacSegmentMask::usage = 
"CardiacSegmentMask[mask, slices, points, {rev,seg,group}]."

CardiacSegment::usage = 
"CardiacSegment[data, mask, off] allows to segment the heart in 1, 4, 6 or AHA-17 segements for each slice 360 radial samples are generated.

data is a background image on which all overlays are projected. 
mask is the mask of the left ventricle (same as used for CentralAxes) and defines the area in which the data is sampled.
off is the centerpoints generated by CentralAxes.

Output is {segmask, segang, {points, slices}}."

PlotSegments::usage = 
"PlotSegments[mask, data, segang] shows how the heart wil be sampled by RadialSample. 

mask is a mask the left ventricle that was used in the CardiacSegment.
function and the segang is the output of the cardaic SegmentFunction.

Output is a plot window."

PlotSegmentMask::usage = 
"PlotSegmentMask[mask, segmask, vox] plots the mask segements created by CardiacSegment.

mask is a mask the left ventricle that was used in the CardiacSegment.
segmask is the output of CardiacSegemnt.
vox is the voxels size, {slice, x, y}.

Output is a plot window."


RadialSample::usage = 
"RadialSample[mask, data, segang] radialy samples the provided parametermap data. 

The mask should be a mask of the left ventricle that was used in the CardiacSegment.
segang is the output of the cardaic SegmentFunction.

Output is {points, vals} which are orderd as indicated by the user."

TransmuralPlot::usage = 
"TransmuralPlot[data] plots transmural profiles of the data which are created by RadialSample.

data can be a single profile or a list of profiles. In the second case the mean and standardeviations are plotted.

Output is a plot of the transmural profile."


BullseyePlot::usage = 
"BullseyePlot[data, segmask] generates a AHA-17 segement bullseye plot. 
BullseyePlot[list] generates a AHA-17 segement bullseye plot of the lists (which needs to have 17 values) provide.

data is a 3D volume used for the plot. 
segmask is the AHA-17 segmentation resulting form the CardiacSegment function when AHA17 is selected.

Output is a bullseye plot or a plotwindow, depending on the Method which can be \"Dynamic\" else it will be static.

BullseyePlot[] is based on DOI: 10.1161/hc0402.102975."


ExcludeSlices::usage = 
"ExcludeSlices[data] excludes slices that do not look like the others based on various distance measures.

Output is an array with 1 or 0 with the dimensiosn {slices, diff dirs}."


MakeECVBloodMask::usage = 
"MakeECVBloodMask[T1pre, T1post] makes a bloodpool mask based on the T1pre and T1post images. It assumes that the hart is cropped with the blood in the center.

The T1pre and T1post maps are assuemed to be in ms."


ECVCalc::usage = 
"ECVCalc[T1pre, T1post, hema] calculates the ECVmap using MakeECVBloodMask.
ECVCalc[T1pre, T1post, bloodMask, hema] calculates the ECVmap using bloodMask.

The T1pre and T1post maps are assuemed to be in ms."


CreateHeart::usage = 
"CreateHeart[] creates a simulated left ventricle shape.
CreateHeart[pars] creates a simulated left ventricle shape with predifined parameters pars.

Output is the heart shape, the voxel size and the parameters needed to generate the heart, {mask, vox, pars}."

CardiacCoordinateSystem::usage = 
"CardiacCoordinateSystem[mask, vox] creates the cardiac coordinate system within the mask and is used in HelixAngleCalc. 
Output is a set of vectors {radvecn, norvecc, cirvec}, being the radial, normal and circular axes of each voxel respectivley.
If the option showPlot is true the output is {{radvecn, norvecc, cirvec}, plots}."


(* ::Subsection::Closed:: *)
(*Options*)


LCMMethod::usage = 
"LCMMethod is an option for HelixAngleCalc and LMCSytemCalc. Can be \"CentralAxes\" or \"WallMap\". 
\"CentralAxes\" uses wall distance calculation using projection of the centarl axes and circular approximation of the ventricle. This method is fairly fast and uses CentralAxes internaly.
\"WallMap\" uses wall distance interpolation and subsequential gradient calculation. Can take long for high res datasets but is most accurate. Uses CalculateWallMap internaly."

AxesMethod::usage = 
"AxesMethod is an option for HelixAngleCalc and CentralAxes and CardiacCoordinateSystem. Can be \"Linear\", \"Quadratic\", \"Cubic\"."

RowSize::usage =
"RowSize is an option for CentralAxes. defines the number or images per showing the segmentation.
Can be \"Automatic\" of an integer." 

ShowPlot::usage = 
"ShowPlot is an option for CentralAxes, HelixAngleCalc and CardiacCoordinateSystem. True shows the fit of the central axes and outpu the plot as extra output."

MaskWallMap::usage = 
"MaskWallMap is an option for CalculateWallMap. if True or False."


StartPoints::usage = 
"StartPoints is an option for CardiacSegment. Value is \"Default\" or the point list given by CardiacSegment."

StartSlices::usage = 
"StartSlices is an option for CardiacSegment. Value is \"Default\" or the list given by CardiacSegment."

LineThreshold::usage = 
"LineThreshold is an option for CardiacSegment. Can be number between 0 and 1. Increasing the value will decrease the amount of wall sampled."

LineStep::usage = 
"LineStep is an option for CardiacSegment."

SegmentAngle::usage = 
"SegmentAngle is an option for CardiacSegment."

RadialSamples::usage =
"RadialSamples is an option for RadialSample and PlotSegments. Defines how manny transmural samples are taken."

DropSamples::usage = 
"DropSamples is an option for RadialSample and PlotSegments. Defines how manny samples are droped form star and end. Can be an number or set (strat, end) of numbers."

GridLineSpacing::usage = 
"GridLineSpacing is an option of TransmuralPlot. It defines the spacing of the gridlines.";

ShowOutliers::usage = "ShowOutliers is an option for ExcludeSlices."

SmoothHelix::usage = 
"SmoothHelix is an option for MaskHelix, sets the kernelsize for the MedianFilter." 

BackgroundValue::usage = 
"BackgroundValue is an option for MaskHelix. Sets the backgroud value (default is -100)."

TextOffset::usage = 
"TextOffset is an option for BullseyePlot. Determines where the text is placed, can be 0 to 1."

TextSize::usage = 
"TextSize is an option for BullseyePlot. Determines the text size."

TextNumberForm::usage =
"TextNumberForm is an option for BullseyePlot. Specifies how many number and decimals to use like in NumberForm."

BullPlotMethod::usage = 
"BullPlotMethod is an option for BullseyePlot. Can be \"Dynamic\" of \"Normal\". 
\"Dynamic\" allows to change plotting parameters in Manipulation window."

CutOffMethod::usage =
"CutOffMethod is an option for ExcludeSlices. Default value is \"Auto\" or it can be a fixed percentage (value between 0 and .5)."

DistanceMeasure::usage = 
"DistanceMeasure is an option for ExcludeSlices. Defaul value is 5. (1 ManhattanDistance, 2 SquaredEuclideanDistance, 3 EuclideanDistance, 4 Correlation, 5 SpearmanRho."

BloodMaskRange::usage = 
"BloodMaskRange is an option for MakeECVBloodMask." 

OutputCheckImage::usage =
"OutputCheckImage is an option for MakeECVBloodMask." 	


(* ::Subsection:: *)
(*Error Messages*)


(* ::Section:: *)
(*Functions*)


Begin["`Private`"]


(* ::Subsection:: *)
(*HelixAngleCalc*)


(* ::Subsubsection::Closed:: *)
(*CardiacCoordinateSystem*)


Options[CardiacCoordinateSystem] = {ShowPlot -> False, LCMMethod->"WallMap", AxesMethod->"Quadratic"}

SyntaxInformation[CardiacCoordinateSystem] = {"ArgumentsPattern" -> {_,_, OptionsPattern[]}};

CardiacCoordinateSystem[mask_?ArrayQ, vox:{_?NumberQ, _?NumberQ, _?NumberQ}, opts:OptionsPattern[]]:= CardiacCoordinateSystem[mask, 0, vox, opts]

CardiacCoordinateSystem[mask_?ArrayQ, maskp_, vox:{_?NumberQ, _?NumberQ, _?NumberQ}, OptionsPattern[]] := Block[{
		dim, axesout, off, vec, inout, pla, met, radvec, norvec, cirvec,norvecc, radvecn, wall, der,
		sp, spz, spxy, maskCont, vectorField,n, z, y, x, coo, rav, nov, rov, vec1 ,vec2, vec3, plot, plw 
	},
	
	dim = Dimensions[mask];
	
	(*get the cardiac center line*)
	axesout = CentralAxes[mask, maskp, vox, 
		AxesMethod -> OptionValue[AxesMethod], 
		ShowPlot -> OptionValue[ShowPlot]
	];
	{off, vec, inout} = If[OptionValue[ShowPlot], pla = axesout[[4]]; axesout[[1 ;; 3]], axesout];
	
	PrintTemporary["LMCS caclulation start"];
	Switch[OptionValue[LCMMethod],
		"CentralAxes",
		plw = Nothing;
		(*calculate the wall angle map*)
		wall = N[WallAngleMap[mask,vox,inout]Degree];
		(*define te rad vector using center points*)
		radvec = RadVecC[dim,off];
		(*define norvecs using centerline vectors*)
		norvec = ConstantArray[vec[[#]],dim[[2;;]]]&/@Range[dim[[1]]];
		(*define rotation vectors perpendicualr to radvecn and norvec*)
		cirvec = NormalizeC[CrossC[radvec,norvec]];
		(*correct the norvec for the wall curvature by rotation around rotvec*)
		norvecc = NorVecR[wall,cirvec,norvec];
		(*make radvec purpendicular to corrected norvec*)
		radvecn = MakePerpendicular[radvec,norvecc];
		,
		"WallMap",
		(*Calculate the wall distance map, and the wall direction*)
		wall = CalculateWallMap[mask, vox, ShowPlot -> OptionValue[ShowPlot]];
		{wall, der} = If[OptionValue[ShowPlot], plw = wall[[3]]; wall[[1 ;; 2]], wall];
		(*make all vectors perpendicual*)
		radvecn = NormalizeC[Transpose[der/vox, {4, 1, 2, 3}]];
		norvec = ConstantArray[#, dim[[2 ;;]]] & /@ vec;
		norvecc = MakePerpendicular[norvec, radvecn];
		cirvec = NormalizeC[CrossC[radvecn,norvecc]];
	];
	
	PrintTemporary["LMCS is done"];
	If[OptionValue[ShowPlot],
		(*plot hear geo*)
		sp = Ceiling[Dimensions[mask]/{12, 24, 24}];
		{spz, spxy} = {sp[[1]], Min[sp[[2 ;; 3]]]};
		maskCont = PlotMaskVolume[mask + maskp, vox];
		n = (spz 0.6 vox[[1]]) {1, -1, 1}/vox;
		vectorField = Table[
			If[mask[[z, y, x]] == 0,
				{None, None, None},
				coo = {x, -y + dim[[2]] + 1, z};
				rav = Reverse[n radvecn[[z, y, x]]];
				nov = Reverse[n norvecc[[z, y, x]]];
				rov = Reverse[n cirvec[[z, y, x]]];
				{
					{Darker[Green], Thick, Line[{coo(*-rav*), coo + rav}]},
					{Darker[Blue], Thick, Line[{coo(*-nov*), coo + nov}]}, 
					{Darker[Red], Thick, Line[{coo(*-rov*), coo + rov}]}
				}
			], 
		{z, 1, dim[[1]], spz}, {y, 1, dim[[2]], spxy}, {x, 1, dim[[3]], spxy}];
		
		{vec1, vec2, vec3} =   DeleteCases[Flatten[#, 2], None] & /@ Transpose[vectorField, {2, 3, 4, 1}];
	    plot = Show[maskCont, Graphics3D[vec1], Graphics3D[vec2], Graphics3D[vec3]];
	    
	    PrintTemporary[plot];
	    Pause[1];
	];
	
	If[OptionValue[ShowPlot],
		{{radvecn, norvecc, cirvec}, {pla, plw, plot}},
		{radvecn, norvecc, cirvec}
	]
]


(* ::Subsubsection::Closed:: *)
(*HelixAngleCalc*)


Options[HelixAngleCalc]={ShowPlot->True, LCMMethod->"WallMap", AxesMethod->"Quadratic"};

SyntaxInformation[HelixAngleCalc]={"ArgumentsPattern"->{_,_,_,_.,OptionsPattern[]}};

HelixAngleCalc[data_?ArrayQ, mask_?ArrayQ, vox:{_?NumberQ, _?NumberQ, _?NumberQ}, opts:OptionsPattern[]]:=HelixAngleCalc[data,mask,0,vox,opts]

HelixAngleCalc[data_?ArrayQ, mask_?ArrayQ, maskp_, vox:{_?NumberQ, _?NumberQ, _?NumberQ}, opts:OptionsPattern[]]:=Block[{
		out, evec, projection, inp, helix, sign, norvec,radvec, cirvec, coors, plots, i, j
	},

	coors = CardiacCoordinateSystem[mask, maskp, vox, 
		ShowPlot->OptionValue[ShowPlot], 
		LCMMethod->OptionValue[LCMMethod], 
		AxesMethod->OptionValue[AxesMethod]
	];
	
	{radvec, norvec, cirvec} = If[OptionValue[ShowPlot], plots = coors[[2]]; coors[[1]], coors];

	(*create helix angle maps*)
	out = Flatten[Table[
		evec=Map[Reverse,data[[All,All,All,All,i]],{3}];
		(*align vector with projection vector*)
		evec=Sign2[DotC[{norvec,radvec,cirvec}[[j]],evec]] evec;
		(*Helix,Transverse,Sheet}*)
		projection = MakePerpendicular[evec, {radvec,cirvec,norvec}[[j]]];
		inp = DotC[projection,{cirvec,norvec,radvec}[[j]]];
		helix=ArcCos[Abs[inp]]/Degree;
		
		sign=If[(j==1 && i==1),Sign2[inp],1];
		sign helix
	, {i, 3}, {j, 3}],1];

	If[OptionValue[ShowPlot], {Re@out,plots}, Re@out]
]


(* ::Subsubsection::Closed:: *)
(*Sign2*)


Sign2[dat_]:=Sign[Sign[dat] + 0.0001];


(* ::Subsubsection::Closed:: *)
(*MakePerpendicular*)


MakePerpendicular = Compile[{{vec1, _Real, 1}, {vec2, _Real, 1}}, 
	Normalize[vec1 - (vec1 . vec2) vec2], 
RuntimeAttributes -> {Listable}, RuntimeOptions -> "Speed"];


(* ::Subsubsection::Closed:: *)
(*NormalizeC*)


NormalizeC = Compile[{{vec, _Real, 1}}, 
	Normalize[vec], 
RuntimeAttributes -> {Listable}, RuntimeOptions -> "Speed"];


(* ::Subsubsection::Closed:: *)
(*RadVecC*)


RadVecC = Compile[{{dim, _Real, 1}, {off, _Real, 2}}, 
	Table[Normalize[{i, j, k}-off[[i]]], {i, dim[[1]]}, {j, dim[[2]]}, {k, dim[[3]]}], 
RuntimeAttributes -> {Listable}, RuntimeOptions -> "Speed"];


(* ::Subsubsection::Closed:: *)
(*NorVecC*)


NorVecC = Compile[{{off, _Real, 2}, {vec, _Real, 2}, {dim, _Real, 1}, {vox, _Real, 1}}, Block[{offv},
	offv = vox # & /@ off;
	Table[vec[[First@First@Position[offv, First@Nearest[offv, vox {i, j, k}, 1]]]],{i, dim[[1]]}, {j, dim[[2]]}, {k, dim[[3]]}]],
Parallelization -> True, RuntimeOptions -> "Speed"];


(* ::Subsubsection::Closed:: *)
(*NorVecR*)


NorVecR = Compile[{{angmap, _Real, 0}, {rotvec, _Real, 1}, {norvec, _Real, 1}}, Block[{v1, v2, v3, W, iden},
	{v1, v2, v3} = rotvec;
	iden = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}};
	W = -{{0, -v3, v2}, {v3, 0, -v1}, {-v2, v1, 0}};
	(iden + Sin[angmap] W + (2 Sin[angmap/2]^2 MatrixPower[W, 2])) . norvec], 
RuntimeAttributes -> {Listable}, RuntimeOptions -> "Speed"];



(* ::Subsubsection::Closed:: *)
(*CrossC*)


CrossC = Compile[{{vec1, _Real, 1}, {vec2, _Real, 1}}, 
	Cross[vec1, vec2], 
RuntimeAttributes -> {Listable}, RuntimeOptions -> "Speed"];


(* ::Subsubsection::Closed:: *)
(*DotC*)


DotC = Compile[{{vec1, _Real, 1}, {vec2, _Real, 1}}, 
	vec1 . vec2, 
RuntimeAttributes -> {Listable}, RuntimeOptions -> "Speed"];


(* ::Subsubsection::Closed:: *)
(*WallAngleMap*)


WallAngleMap[mask_, vox_, inout_] := Block[{dim, cent, len, edge1, edge2, fout, fin, walldir, wallang, wallvec, sign, wallangfunc, dist, in, out},
	dim = Dimensions[mask];
	len = dim[[1]];
	
	(*fit the wall profile with Quadratic function*)
	{in, out} = (FitWall[#, "Quartic"]) & /@ {inout[[1, 2]], inout[[2, 2]]};
	fout = First@First@Position[out[[1]], _Real?(# != 0. &)];
	fin = First@First@Position[in[[1]], _Real?(# != 0. &)];
	
	walldir = {in, out};
	wallang = Transpose[Map[(
		wallvec = Normalize[vox {1, #[[2]], 0}];
		sign = Sign2[#[[2]]];
		{#[[1]], sign VectorAngle[{1, 0, 0}, wallvec]/Degree}
	) &, Transpose[walldir, {2, 3, 1}], {2}], {3, 1, 2}];
	
	cent = {ConstantArray[0, len], wallang[[1, 2]]};

	If[fout > 1, wallang[[2, 2, Range[fout - 1]]] = 90];
	If[fin > 1, wallang[[1, 2, Range[fin - 1]]] = 90];
	cent = {ConstantArray[0, len], wallang[[1, 2]]};

	edge1 = {ConstantArray[ Max[walldir[[All, 1]]], len], wallang[[2, 2]]};
	edge2 = {ConstantArray[ Max[vox dim], len], wallang[[2, 2]]};
	wallang = Transpose[{Transpose[vox[[1 ;; 2]] {Range[len], #[[1]]}], #[[2]]}] & /@ Join[{cent}, wallang, {edge1, edge2}];
	
	wallang = Sort[DeleteDuplicates[Flatten[wallang, 1]]];
	wallangfunc = Interpolation[wallang, InterpolationOrder -> 1];
	
	Quiet@Table[
		dist = EuclideanDistance[{j, k}, inout[[1, 1, z, 2 ;;]]];
		wallangfunc[vox[[1]] z, vox[[2]] dist]
	, {z, dim[[1]]}, {j, dim[[2]]}, {k, dim[[3]]}
   ]
]


(* ::Subsubsection::Closed:: *)
(*FitWall*)


(*fit the waal profile for the normalized central axes*)
FitWall[data_, met_] := Block[{fun, pf, fdata, xdat, points, pos},
	(*define function and data*)
	fun = Switch[met,
		"Quadratic", {1, t, t^2},
		"Cubic", {1, t, t^2, t^3},
		"Quartic", {1, t, t^2, t^3, t^4},
		_, {1, t}];
	xdat = Range[Length[data]];
	fdata = DeleteCases[Transpose[{xdat, data}], {_, {}}];
	
	(*perform the fit and gererate the fitted poins *)
	pf = Simplify@Chop@Fit[fdata, fun, t];
	points = Chop[pf /. t -> # & /@ xdat];
	
	(*set the radius to zero for slices without a mask*)
	pos = Flatten[Position[data, {}]];
	If[! (pos === {}), points[[pos]] = 0];
	{points, (Unitize[points[[#]]] (D[pf, t] /. t -> #) /.  0. -> 10) & /@ xdat}
]


(* ::Subsection::Closed:: *)
(*CalculateWallMap*)


Options[CalculateWallMap] = {ShowPlot -> True, MaskWallMap->False};

SyntaxInformation[CalculateWallMap] = {"ArgumentsPattern" -> {_, _, OptionsPattern[]}};

CalculateWallMap[maski_, vox_, OptionsPattern[]] := Module[{
	seg, min, mout, mtot, pts, ptsi, pos, ptso, x, y, z, plane, mask,
	surfpl, pointspl, planepl, planefit, fit, planem, d1, d2, d3, zc,
	min2, mout2, surfin, surfout, ptsin, ptsout, ptspl, inpnt, outpnt,
	wall, pt, pt1, pt2, dist1, ptsm, ptsmv, dist, der, mn ,mx, ind, max
	},
	
	(*prepare the mask*)
	mask = SelectComponents[#, "Count", -1] & /@ Round[maski];
	
	(*create the inner and outer volume*)
	seg = MorphologicalComponents[N[#]] & /@ (1. - mask);
	seg = If[#[[1, 1]] == 2, # /. {2 -> 1, 1 -> 2}, #] & /@ seg;
	min = Unitize[Clip[seg - 1, {0, 1}, {0, 0}]];
	mout = Unitize[1 - Clip[seg, {0, 1}, {0, 0}]];
	mtot = (mout + 1) - 2 min;
	
	(*get the top points to fit top plane*)
	ind = Range[Length[mask]] - 1;
	pts = ptsi = Flatten[MapIndexed[(If[(pos = Pick[ind, #1, 1]) != {}, Reverse@Flatten[{Last@pos, #2}], Nothing]) &, RotateDimensionsLeft[mask], {2}], 1];
	max = Max[pts[[All, 3]]] - Ceiling[Length[mask]/10];
	ptso = Select[pts, #[[3]] > max &];
	
	(*fit the top plane*)
	Clear[x, y, z];
	plane = Fit[ptso, {1, x, y}, {x, y}];
	While[ptsi != ptso,
		ptsi = ptso;
		ptso = Select[pts, (((plane - z) /. Thread[{x, y, z} -> #]) < 1) &];
		plane = Fit[ptso, {1, x, y}, {x, y}];
	];
	
	(*plane fit visualisation*)
	If[OptionValue[ShowPlot],
		surfpl = ListContourPlot3D[GaussianFilter[mask, 1], Contours -> {0.6}, Mesh -> False, PlotRange -> Transpose[{{0, 0, 0}, Reverse@(Dimensions[mask])}],
			BoxRatios -> Reverse@(vox Dimensions[mask]), ContourStyle -> Directive[Gray, Opacity[0.5]], Lighting -> "Neutral", Axes -> False];
		pointspl = ListPointPlot3D[ptsi, PlotRange -> Transpose[{{0, 0, 0}, Reverse@Dimensions[mask]}], BoxRatios -> 1, PlotStyle -> Red];
		planepl = Plot3D[plane,  {x, 0, Dimensions[mask][[3]]}, {y, 0, Dimensions[mask][[2]]}, Mesh -> False, PlotStyle -> Directive[Red, Opacity[.2]], BoundaryStyle -> Darker[Red]];
		planefit = Show[surfpl, planepl, pointspl, PerformanceGoal -> "Speed", ImageSize->350];
	];
	
	(*make mask from plan*)
	planem = 0 mout;
	{d1, d2, d3} = Dimensions[planem];
	Table[
		zc = (Round[plane] + o) /. {x -> xc, y -> yc};
		If[zc <= d1, planem[[zc, yc, xc]] = 1]
		, {xc, 1, d3}, {yc, 1, d2}, {o, 1, 2}];
	planem = (1 - mout) planem;
	
	(*close inner mask to plane*)
	min2 = UnitStep[RotateDimensionsRight[FillFun[RotateDimensionsLeft[planem + mout + min]]] - 2];
	mout2 = Clip[mout + min2, {0, 1}];
	
	ptsin = Position[min2 - (Erosion[#, 1] & /@ min2), 1];
	ptsout = Position[(Dilation[#, 1] & /@ mout2) - mout2, 1];
	ptsm = Position[mask, 1];
	
	If[OptionValue[ShowPlot],
		(*Create Inner and outer surfaces*)
		{surfout, surfin} = ListContourPlot3D[GaussianFilter[min2 + mout2, 1], Contours -> {0.3, 1.5}[[#]], Mesh -> False, 
			PlotRange -> Transpose[{{0, 0, 0}, Reverse@(Dimensions[mask])}], Lighting -> "Neutral", 
			BoxRatios -> Reverse@(vox Dimensions[mask]), ContourStyle -> Directive[{Red, Blue}[[#]], Opacity[0.4]], 
			MaxPlotPoints -> {50, 100}] & /@ {1, 2};
		
		ptspl = Show[surfin, surfout, ListPointPlot3D[{Reverse[#]-1&/@ptsin[[;; ;;2]], Reverse[#]-1&/@ptsout[[;; ;;2]]}, PlotStyle -> {Blue, Red}], PerformanceGoal -> "Speed",ImageSize->350]
	];
	
	inpnt = Nearest[N[vox # & /@ ptsin]];
	outpnt = Nearest[N[vox # & /@ ptsout]];
	ptsmv = N[vox # & /@ ptsm];
	
	(*generate the wall distance function*)
	min = 0.1 Norm[Drop[vox,1]];
	dist = Map[(
		pt = #;
		pt1 = Mean@inpnt[pt, 1];
		pt2 = Mean@outpnt[pt, 1];
		dist1 = Norm[pt1 - pt2];
		If[dist1 < min, 0., Mean[{Norm[pt1 - pt]/dist1, 1 - (Norm[pt2 - pt]/dist1)}]]
	) &, ptsmv];
	
	(*create the wall distance map*)
	wall = GaussianFilter[Normal[SparseArray[Thread[ptsm -> dist], Dimensions[mask]]] + (1 - mout2), 1];
	der = GaussianFilter[wall, {{3,3,3}}(*{2 (1/vox)/(1/vox[[2]])}*), #] & /@ (IdentityMatrix[3]);
    
    If[OptionValue[MaskWallMap],
    	wall = mask wall;
    	der = mask # & /@ der;
    	{mn, mx} = Quantile[Flatten[GetMaskData[wall, mask]],{0.01,0.99}];
    	wall = Clip[mask ((wall - mn)/(mx-mn)),{0,1}];
    ];
    
    If[OptionValue[ShowPlot], PrintTemporary[Row[fit = {planefit, ptspl}]]; {wall, der, fit}, {wall, der}]
]

FillFun = Compile[{{v, _Integer, 1}}, Block[{out, in, i, m},
	out = v;
	in = 0 v;
	m = 1 - UnitStep[v - 2];
	i = 0;
	If[Last[out] =!= 2,
		While[in =!= out && i < 10,
			i++;
			in = out;
			out = out + m 2 Prepend[UnitStep[Abs[Differences[out]] - 2], 0]
		];
	out, out]]
, RuntimeAttributes -> {Listable}, RuntimeOptions -> "Speed"];


(* ::Subsection:: *)
(*CentralAxes*)


(* ::Subsubsection::Closed:: *)
(*CentralAxes*)


Options[CentralAxes]={ShowPlot->False, RowSize->"Automatic", AxesMethod->"Cubic"(*,Output->True*)};

SyntaxInformation[CentralAxes]={"ArgumentsPattern"->{_,_,_.,OptionsPattern[]}};

CentralAxes[mask_,vox_,opts:OptionsPattern[]]:=CentralAxes[mask,0,vox,opts]

CentralAxes[mask_,maskp_,vox_,OptionsPattern[]]:=Module[{
	rad,met,row,dim,half,minmaxr,inner,outer,inout,offi,offo,vecsi,vecso,
	offouti,offouto,pl1,off,vecs,pl2,offout,vecsout,fit,last},
	
	(*get option values*)
	rad={0.01,1};
	met=OptionValue[AxesMethod];
	row=If[OptionValue[RowSize]==="Automatic"||!IntegerQ[OptionValue[RowSize]],
	Round[Sqrt[Length[mask]]],
	OptionValue[RowSize]
	];
	
	(*get data dimensions*)
	dim=Dimensions[mask];
	(*half=CenterPoint[mask];*)
	half=Drop[dim,1]/2.;
	minmaxr= rad Max[(Drop[dim,1]/1)];
	
	(*get inner and outer radius*)
	{inner,outer} = GetRadius[mask(*,minmaxr,half*)];

	(*finde the upper most closed outer*)
	last = First@Last@Position[Unitize[inner[[3]] /. {} -> 0] + Unitize[outer[[3]] /. {} -> 0], 2];
	outer[[All, last + 1 ;;]] = Transpose@ConstantArray[{{}, {}, {}}, Length[outer[[3]]] - last];
	
	(*fit off centers*)
	{off, vecs} = FitCenterLine[inner[[1]], outer[[1]], vox, met];
	{offi, vecsi} = FitCenterLine[inner[[1]], vox, met];
	{offo, vecso} = FitCenterLine[outer[[1]], vox, met];
	
	{off, vecs} = BoundCorrect[Min /@ Transpose[{inner[[3]], outer[[3]]} /. {{} -> 0}], off, vecs];
	{offi, vecsi} = BoundCorrect[inner[[3]]/. {{} -> 0}, offi, vecsi];
	{offo, vecso} = BoundCorrect[outer[[3]]/. {{} -> 0}, offo, vecso];
	  
	(*generate plots*)
	If[OptionValue[ShowPlot],
		pl1 = PlotRadius[Clip[2 mask + maskp,{0,2}], inner, outer];
		pl2 = PlotSegmentation[mask + maskp, inner, outer, {off, offi, offo}, vox];
		fit = Row[{GraphicsGrid[Partition[pl1, row, row, 1, {}], ImageSize -> row*100], pl2}];
	];
	
	(*create output*)
	offout = Reverse[{1, -1, 1} (# + {0, -(dim[[2]]), 0})] & /@ off;
	offouti = Reverse[{1, -1, 1} (# + {0, -(dim[[2]]), 0})] & /@ offi;
	offouto = Reverse[{1, -1, 1} (# + {0, -(dim[[2]]), 0})] & /@ offo;
	vecsout=Reverse[{1,-1,1} #]&/@vecs;
	inout = {{offouti, inner[[3]]}, {offouto, outer[[3]]}};
	
	(*If[OptionValue[ShowPlot]==True,Print[fit]];*)
	If[OptionValue[ShowPlot],{offout,vecsout,inout,fit},{offout,vecsout,inout}]
]


(* ::Subsubsection::Closed:: *)
(*BoundCorrect*)


BoundCorrect[points_,off_,vec_]:=Block[{vv,first,last,offo,veco},
	vv = Unitize[points];
		
	first = (First@Position[vv, 1])[[1]];
	last = (Last@Position[vv, 1])[[1]];
	offo = Join[
		{off[[first, 1]] + (first - #) (off[[first, 1]] - off[[first + 1, 1]]), off[[first, 2]] + (first - #) (off[[first, 2]] - off[[first + 1, 2]]), #} & /@ Range[1, first - 1],
		off[[Range[first, last]]],
	  	{off[[last, 1]] + (# - last) (off[[last, 1]] - off[[last - 1, 1]]), off[[last, 2]] + (# - last) (off[[last, 2]] - off[[last - 1, 2]]), #} & /@ Range[last + 1, Length[vv]]
	  ];
	veco=Join[ConstantArray[vec[[first]],first-1],vec[[first;;last]],ConstantArray[vec[[last]],Length[vv]-last]];
	{offo,veco}
]


(* ::Subsubsection::Closed:: *)
(*CenterPoint*)


CenterPoint[mask_]:=Module[{half}, 
	DynamicModule[{halfi},
		halfi=Dimensions[mask[[1]]]/2;
		DialogInput[{
			LocatorPane[Dynamic[halfi],Image[Mean[mask],ImageSize->400],Appearance->Graphics[{Red,Disk[]},ImageSize->30]],
			DefaultButton["Done",DialogReturn[half=halfi]]
		},WindowTitle->"Select Center",WindowFloating->True,Modal->True]
	];
	half
]


(* ::Subsubsection::Closed:: *)
(*GetRadius*)


GetRadius[mask_] := Block[{comps, in, out, fout, fin},
	comps = MorphologicalComponents[Reverse@# - Erosion[Reverse@#, 1], CornerNeighbors -> False] & /@ mask;
		
	{in, out} = Transpose[Switch[Max[#],
		1, {{}, Reverse /@ Position[#, 1]},
		2, SortBy[{Reverse /@ Position[#, 1], Reverse /@ Position[#, 2]}, (Length[#] &)],
		_, {{}, {}}
	] & /@ comps];
	
	fout = Transpose[MapIndexed[If[#1 === {}, {{}, {}, {}}, FitEllipse[#1, #2]] &, out]];
	fin = Transpose[MapIndexed[If[#1 === {}, {{}, {}, {}}, FitEllipse[#1, #2]] &, in]];
	
	{fin, fout}
]


FitEllipse[pts_, i_] := Block[{lsMat, a, b, c, d, e, f, s, val ,vec,  den, num ,fac, r0, r1,r2,ang},
	
	(*transform coordinates*)
	lsMat = N[Function[{x, y}, {x^2, 2 x y, y^2, 2 x, 2 y, 1}] @@@ pts];
	(*solve eclipse equation*)
	(*{a, b, c, d, e} = Chop[LeastSquares[lsMat, ConstantArray[1., Length[pts]]]];*)
	d = Transpose[lsMat] . lsMat;
	c = {{0, 0, -2, 0, 0, 0}, {0, 1, 0, 0, 0, 0}, {-2, 0, 0, 0, 0, 0}, 
		{0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0}};
	{val, vec} = Eigensystem[{d, c}];
	{a, b, c, d, e, f} = vec[[Position[Boole[Negative /@ val], 1][[1, 1]]]];
		
	den = b^2 - a c;
	num = 2*(a e^2 + c d^2 + f b^2 - 2 b d e - a c f);
	fac = Sqrt[((a - c)^2 + 4 b^2)];
	
	If[(b^2 - a c) < 0, 
		(*solve for centers*)
		r0 = {(c*d - b*e)/den, (a*e - b*d)/den};
		(*get the radisu*)
		r1 = Sqrt[num/den/(fac - a - c)];
		r2 = Sqrt[num/den/(-fac - a - c)];
		(*get the angle*)
		ang = ArcTan[(2 b)/(a - c)]/2;
		If[ a > c, ang += Pi/2];
		{Join[r0, i], {r1, r2, ang}, Mean[{r1, r2}]},
		{{}, {}, {}}
	]
]


(* ::Subsubsection::Closed:: *)
(*FitCenterLine*)


(*fit the center line for the average inner and outer center points*)
FitCenterLine[inner_, outer_, vox_, met_] := Block[{data},
	data = Mean[DeleteCases[#, {}]] & /@ Transpose[{inner, outer}];
	FitCenterLine[data, vox, met]
]

FitCenterLine[datai_, vox_, met_] := Block[{fun, pf, xdat, data, fdata},
	data = datai /. {Mean[{}] -> {{}, {}, {}}, {} -> {{}, {}, {}}};
	
	fun = Switch[met,
		"Quadratic", {1, t, t^2},
		"Cubic", {1, t, t^2, t^3},
		"Quartic", {1, t, t^2, t^3, t^4},
	_, {1, t}];
	
	xdat = Range[Length[data]];
	fdata = DeleteCases[Transpose[{Range[Length[#]], #}], {_, {}}] & /@ Transpose[data];
	pf = Simplify@Chop@Fit[#1, fun, t] & /@ fdata;
	
	{Transpose[If[NumberQ[#], ConstantArray[#, Length[xdat]], # /. t -> xdat] & /@ pf],
	(Normalize[D[Reverse[vox] pf, t] /. t -> #] & /@ xdat)}
]


(* ::Subsubsection::Closed:: *)
(*PlotRadius*)


Ellipse2D[{{x0_, y0_, z0_}, {a_, b_, alpha_}}, theta_] := {
	x0 + a*Cos[theta]*Cos[alpha] - b*Sin[theta]*Sin[alpha],
	y0 + a*Cos[theta]*Sin[alpha] + b*Sin[theta]*Cos[alpha]
}
Ellipse3D[{{x0_, y0_, z0_}, {a_, b_, alpha_}}, theta_] := {
	x0 + a*Cos[theta]*Cos[alpha] - b*Sin[theta]*Sin[alpha],
	y0 + a*Cos[theta]*Sin[alpha] + b*Sin[theta]*Cos[alpha], 
	z0
}


PlotRadius[mask_, inner_, outer_] := MapThread[(
	Show[
		Image[#1/Max[mask], ImageSize -> 100],
		If[#2[[1]] != {}, ParametricPlot[Ellipse2D[#2[[{1, 2}]], t] - 0.5, {t, 0, 2 Pi}, PlotStyle -> Directive[Thick, Red]], Graphics[]],
		If[#2[[1]] != {}, Graphics[{Red, PointSize[Medium], Point[#2[[1, 1 ;; 2]] - 0.5]}], Graphics[]],
		If[#3[[1]] != {}, ParametricPlot[Ellipse2D[#3[[{1, 2}]], t] - 0.5, {t, 0, 2 Pi}, PlotStyle -> Directive[Thick, Blue]], Graphics[]],
		If[#3[[1]] != {}, Graphics[{Blue, PointSize[Medium], Point[#3[[1, 1 ;; 2]]]}], Graphics[]]
	]
) &, {mask, Transpose@inner, Transpose@outer}]


(* ::Subsubsection::Closed:: *)
(*PlotSegmentation*)


PlotSegmentation[mask_, inner_, outer_, {off_, offi_, offo_}, vox_] := Block[{voxl, offp, offip, offop},
	voxl = Reverse[vox];
	
	offp = {.5, .5, 0} + {1, 1, 1} # & /@ DeleteCases[off, {}];
	offip = {.5, .5, 0} + {1, 1, 1} # & /@ DeleteCases[offi, {}];
	offop = {.5, .5, 0} + {1, 1, 1} # & /@ DeleteCases[offo, {}];
	
	Show[
		PlotMaskVolume[mask, vox],
		(*center points*)
		ListPointPlot3D[offp, PlotStyle -> Directive[{Thick, Black, PointSize[Large]}]],
		Graphics3D[{Thick, Black, Line[offp]}],
		
		ListPointPlot3D[Delete[outer[[1]], Position[outer[[2]], {}]], PlotStyle -> Directive[{Thick, Blue, PointSize[Large]}]],
		Graphics3D[{Thick, Blue, Line[Delete[offop, Position[outer[[2]], {}]]]}],
		
		ListPointPlot3D[Delete[offip, Position[inner[[2]], {}]], PlotStyle -> Directive[{Thick, Red, PointSize[Large]}]],
		Graphics3D[{Thick, Red, Line[Delete[offip, Position[inner[[2]], {}]]]}],
		
		(*Plot the segmented outlines*)
		If[outer[[2, #]] === {}, 
			Graphics3D[],
			ParametricPlot3D[Ellipse3D[outer[[{1, 2}, #]], u] - {0.5, .5, 0}, {u, 0, 2 Pi}, PlotStyle -> Directive[{Thick, Blue, Opacity[.5]}]] 
			(*ParametricPlot3D[{outer[[3, #]] Sin[u], outer[[3, #]] voxl[[1]]/voxl[[2]] Cos[u],0} + offop[[#]], {u, 0, 2 Pi}, PlotStyle -> Directive[{Thick, Blue, Opacity[.5]}]]*)
		] & /@ Range[Length[mask]],
		
		If[inner[[2, #]] === {}, 
			Graphics3D[], 
			ParametricPlot3D[Ellipse3D[inner[[{1, 2}, #]], u] - {0.5, .5, 0}, {u, 0, 2 Pi}, PlotStyle -> Directive[{Thick, Red, Opacity[.5]}]]
			(*ParametricPlot3D[{inner[[3, #]] Sin[u], inner[[3, #]] voxl[[1]]/voxl[[2]] Cos[u], 0} + offip[[#]], {u, 0, 2 Pi}, PlotStyle -> Directive[{Thick, Red, Opacity[.5]}]]*)
		] & /@ Range[Length[mask]],
		
	ImageSize->400]
]


(* ::Subsubsection::Closed:: *)
(*PlotMaskVolume*)


Options[PlotMaskVolume] = {Filter->True}

PlotMaskVolume[mask_,vox_,color_:Darker[Gray],OptionsPattern[]] := Block[{pmask,dim},
	pmask = ArrayPad[Reverse[If[OptionValue[Filter], GaussianFilter[Clip[mask], 1],	Clip[mask]], 2], 1];
	dim=Dimensions[pmask];
	ListContourPlot3D[pmask, Contours -> {.4}, ContourStyle -> {color, Opacity[.5]}, Mesh -> False,
		Lighting -> "Neutral", BoundaryStyle -> None, PlotRange -> (Thread[{{0, 0, 0}, Reverse@dim - 1}]),
		BoxRatios -> Reverse[(vox (dim + 2))], Axes -> True, ImageSize -> 400, SphericalRegion -> True
	]
]


(* ::Subsection:: *)
(*CardiacSegment*)


(* ::Subsubsection:: *)
(*GetMaskSegmentPoints*)


SyntaxInformation[GetMaskSegmentPoints] = {"ArgumentsPattern" -> {_}};

GetMaskSegmentPoints[mask_]:=Block[{segM,m1,m2,points,maskc},
	segM = Normal[SplitSegmentations[mask][[1]]];
	{m1,m2}=Transpose[segM][[2;;3]];
	
	points=Transpose[{
		1/.ComponentMeasurements[Reverse[#],"Centroid"]&/@m1,
		1/.ComponentMeasurements[Reverse[#],"Centroid"]&/@m2
	}];
	points = Map[If[# === 1, None, Reverse@#] &, points, {2}];

	maskc=Clip[mask,{0,1}];
	{maskc, points}
]


(* ::Subsubsection:: *)
(*CardiacSegmentMask*)


SyntaxInformation[CardiacSegmentMask]={"ArgumentsPattern"->{_,_,_,_,_.,OptionsPattern[]}};

CardiacSegmentMask[{msk_,vox_},regions_,points_,{rev_,type_,slcGrp_}]:=CardiacSegmentMask[msk,regions,points,CentralAxes[msk,vox,ShowPlot->False][[1]],{rev,type,slcGrp}]

CardiacSegmentMask[msk_,regions_,points_,offi_,{rev_,type_,slcGrp_}]:=Block[{dim,slices,dim2,centers,segments,segm,segs,nseg,rule,
	off,coordinates,segmask,cent,coor,angs,angp,cang,l,u,sel,tmp,sls},
	
	(*get the dimensions and positinos*)
	dim=Dimensions[msk];
	slices=dim[[1]];
	dim2=Drop[dim,1];
	
	If[Length[offi[[1]]]==2,
		centers=offi;,
		centers=Reverse/@offi[[All,2;;3]];
	];
	
	Print[centers];
	
	(*get the segments per slice*)
	{segments,segm}=SlicesToSegments[regions,slices,points,{type,slcGrp}];
	Print["test"];
	segs=Select[segments,#[[2]]=!=0&];
	nseg=Length[segs];
	
	(*convert mask too coordinates*)
	coordinates=(Reverse/@Position[#,1])&/@Round[msk];
	
	Print[segments,segm];
	
	(*create mask per slice from points*)
	segmask=Table[
		If[(n/.segm)==0,
		{ConstantArray[0,dim2]}
		,
		If[coordinates==={},
			ConstantArray[ConstantArray[0,dim2],n/.segm]
			,
			cent=centers[[n]];
			coor=coordinates[[n]];
			(*calculate the anlges for segments*)
			Print[{points[[n]],cent,n/.segm, 2 Boole[rev]-1}];
			angs = VecAngleC[points[[n]], cent, n/.segm, 2 Boole[rev]-1];
			Print[angs];
			angp=Partition[angs,2,1,1];
			(*convert the coordinates to angles*)
			cang=(ToPol@@Transpose[#-cent&/@coor])[[All,2]];
			cang=2Pi(1-UnitStep[cang])+cang;
			
			Print[MinMax[cang]];
						
			(*make the masks for each partition*)
			(
				{l,u}=#;
				Print[{l,u,l>u}];
				sel=If[l>u,
					(UnitStep[cang-l]-UnitStep[cang-2Pi])+(UnitStep[cang-0]-UnitStep[cang-u]),
					UnitStep[cang-l]-UnitStep[cang-u]
				];
				Normal[SparseArray[Reverse/@Pick[coor,sel,1]->1,dim2]]
			)&/@angp
			]
		]
	,{n,1,slices,1}];
	
	Print[Dimensions[segmask]];
	
	
	(*group mask slices for AHA 17 segments or other slice grouping*)
	If[slcGrp||StringQ[type],
		Transpose@Flatten[
		Table[
			tmp=ConstantArray[0,Flatten[{segments[[i,2]],dim}]];
			sls=segments[[i,1]];
			If[sls=!={},tmp[[All,sls]]=Transpose[segmask[[sls]]]];
			tmp,
			{i,nseg,1,-1}],1]
		,
		segmask
	]
]


SlicesToSegments[{start_,ap_,mid_,bas_,end_},slices_,points_,{segmi_,slcgrp_}]:=Block[{apex,apical,midcavity,basal,none,segments,sel},
	sel = If[#[[1]] === 1 || #[[2]] === 1, 0, 1] & /@ points;
	(*segment ranges*)
	apex=Range[start+1,ap];
	apical=Range[ap+1,mid];
	midcavity=Range[mid+1,bas];
	basal=Range[bas+1,end];
	{apex, apical, midcavity, basal} = Select[#, sel[[#]] === 1 &] & /@ {apex, apical, midcavity, basal};
	none=Complement[Range[1,slices],Flatten[{apex,apical,midcavity,basal}]];
	
	segments=Switch[segmi,
		"AHA",Thread[{apex,apical,midcavity,basal,none}->{1,4,6,6,0}],
		"AHA+",Thread[{apex,apical,midcavity,basal,none}->{2,6,8,8,0}],
		_,If[slcgrp,
			DeleteCases[Thread[{apex,apical,midcavity,basal,none}->{segmi,segmi,segmi,segmi,0}],{}->_],
			{Range[slices]->segmi}
		]
	];
	
	{segments,Flatten[Thread/@segments]}
]


ToPol = Compile[{{x,_Real,0},{y,_Real,0}},{Sqrt[x^2 + y^2],ArcTan[y,x]},RuntimeAttributes->{Listable}];
FromPol = Compile[{{r,_Real,0},{a,_Real,0}},{r Cos[a],r Sin[a]},RuntimeAttributes->{Listable}];


(* ::Subsubsection::Closed:: *)
(*CardiacSegment*)


Options[CardiacSegment]={StartPoints->"Default",StartSlices->"Default",LineThreshold->.25,LineStep->.5, SegmentAngle->1};

SyntaxInformation[CardiacSegment] = {"ArgumentsPattern" -> {_, _, _, OptionsPattern[]}};

CardiacSegment[data_,maski_,off_,OptionsPattern[]]:=DialogInput[{
	DynamicModule[{
		mask,radiusStart,centers,pointsIn,coordinates,angles,segmask, segang,startPoint, revi, lineAng,none,
		lines,centerpl,slices,api,midi,basi,sti,endi,carPl,colsOver,car,lm,pos,st,en,app,seg,allpli
		},
	
		mask=Round[maski];
		radiusStart=ConstantArray[Max[Dimensions[mask]]/8,Length[mask]];
		centers=Reverse/@off[[All,2;;3]];
		
		startPoint=OptionValue[StartPoints];
		If[startPoint==="Default",
			revi=1;
			pointsIn=Transpose[{
				centers-Transpose@{radiusStart,radiusStart},
				centers-Transpose@{radiusStart,-radiusStart}
				},{2,1,3}];
			,
			If[NumberQ[startPoint[[2]]],
				revi=startPoint[[2]];
				pointsIn=Reverse@startPoint[[1]];
				,
				revi=1;
				pointsIn=Reverse@startPoint;
			]
		];
		
		coordinates=(Reverse/@Position[#,1])&/@mask;
		angles=N@Table[i,{i,0,359,OptionValue[SegmentAngle]}]Degree;
		PrintTemporary["Calculating sample lines"];
		{lines, lineAng} = LinePoints[mask, off, LineThreshold->OptionValue[LineThreshold], LineStep->OptionValue[LineStep]];
		
		(*static plots*)
		centerpl=Graphics[{Red ,Disk[#,1]}]&/@centers;
		
		slices=Length[mask];
	
		{sti,api,midi,basi,endi} = If[OptionValue[StartSlices]==="Default"||OptionValue[StartSlices]==={},
			pos = Position[Max[#] & /@ mask, 1];
			st = First@First[pos-1];
			en = First@Last[pos];
			app=Round[(en-st)/7];
			seg=Ceiling@Range[st + app, en - (en - (app + st))/3, (en - (app + st))/3];
			Flatten[{st,seg,en}]
			,
			OptionValue[StartSlices]
		];
	
		carPl = ArrayPlot[car = Reverse@Total[Transpose[mask]], ColorFunction -> "GrayTones", Frame -> False,ImageSize -> {200, 200}, AspectRatio -> 1];
		colsOver = 0 car;lm = Dimensions[car];
		allpli=Graphics[MapThread[{#2, Thick,Line[{{0, #1}, {lm[[2]], #1}}]} &, {{sti,api,midi,basi,endi}, {Gray, Orange, Blue, Red, Purple}}]];
		
		PrintTemporary["Initializing manipulte window"];
		Manipulate[
			(*slice sements*)
			end=Clip[end,{bas,slices}];
			bas=Clip[bas,{mid,end}];
			ap=Clip[ap,{start,mid}];
			mid=Clip[mid,{ap,bas}];
			start=Clip[start,{0,ap}];
			(*app=Clip[app,{0,mid}];*)
			n=Clip[n,{1,slices}];
			allpl=Graphics[MapThread[{#2, Thick,Line[{{0, #1}, {lmm, #1}}]} &, {{start,ap,mid,bas,end}, {Gray, Orange, Blue, Red, Purple}}]];
			
			(*segment ranges*)
			apex=Range[start+1,ap];
			apical=Range[ap+1,mid];
			midcavity=Range[mid+1,bas];
			basal=Range[bas+1,end];
			none=Complement[Range[1,slices],Flatten[{apex,apical,midcavity,basal}]];
			
			(*Colors*)
			backcols=Flatten[Thread/@Thread[{apex,apical,midcavity,basal,none}->{Orange,Blue,Red,Purple,Gray}]];
			colls=backcols[[All,2]];
			backcol=n/.backcols;
			
			(*segments*)
			segments=If[!NumberQ[segmi],
				If[segmi=="AHA",
					Thread[{apex,apical,midcavity,basal,none}->{1,4,6,6,0}],
					Thread[{apex,apical,midcavity,basal,none}->{2,6,8,8,0}]
				],
				If[slcgrp,
					DeleteCases[Thread[{apex,apical,midcavity,basal,none}->{segmi,segmi,segmi,segmi,0}],{}->_],
					{Range[slices]->segmi}
				]
			];
			
			segm=n/.Flatten[Thread/@segments];
			
			(*get correct center, calcualte angles and rad*)
			cent=centers[[n]];
			rad=Clip[RadCalcC[points[[n]],cent],{5,Min[Dimensions[mask[[1]]]/2]}];
			angs=VecAngleC[points[[n]],cent,segm,rev];
				
			(*plots*)
			anatomypl=ArrayPlot[data[[n]],
				ColorFunction->"GrayTones",FrameTicks->Automatic,DataReversed->True,ImageSize->400,Mesh->mesh,
				LabelStyle->Directive[{Bold,Black,FontFamily->"Helvetica"}],FrameTicksStyle->Directive[{Black,Thick}],FrameStyle->Directive[{Thick,backcol}]];
			maskpl=If[masktype,
				ArrayPlot[(1-Ceiling[GaussianFilter[mask[[n]],2]-linetr]),ColorRules->{1->Transparent,0->GrayLevel[1,mop]},DataReversed->True],
				ArrayPlot[(1-mask[[n]]),ColorRules->{1->Transparent,0->GrayLevel[1,mop]},DataReversed->True]
			];
						
			(*circle and arrows*)
			circplot=If[MemberQ[display,1],
				Switch[segm,
					0,Graphics[{backcol, Thick, Circle[cent,rad]}],
					1,Graphics[{backcol, Thick, Circle[cent,rad]}],
					_,segpt=RotateRad[rad,cent,#]&/@angs; 
					Graphics[{{Thick,backcol,Arrow[{cent,#}]&/@segpt},{backcol,Thick,Circle[cent,rad]}}]
				],
				Graphics[]
			];
			
			(*lines1 - full lines*)
			lineplot=If[MemberQ[display,2],
				angsp = Angpart[angs,angles[[1;;;;astep]],rev]; 
				segpts = Map[RotateRad[rad,cent,#]&,angsp,{2}];
				Graphics[Table[{ColFun[i,segm],Line[{cent,#}]&/@segpts[[i]]},{i,1,segm}]],
				Graphics[]
			];
			
			(*points*)
			pointplot=If[MemberQ[display,3],
				pts = RegionPoins[cent,angs,coordinates[[n]]];
				Graphics[Table[{ColFun[i,segm],PointSize[Large],Point[#-{.5,.5}&/@pts[[i]]]},{i,1,segm}]],
				Graphics[]
			];
			
			(*disks*)
			polplot=If[MemberQ[display,4],
				dsks = RegionDisk[cent,angs,rad,rev]; 
				Graphics[Table[{Opacity[0.5],ColFun[i,segm,backcol],dsks[[i]]},{i,1,segm}]],
				Graphics[]
			];
			
			(*lines2 - mask lines*)
			lineplot2 = If[MemberQ[display,5],
				angsp = astep(Angpart[angs,lineAng[[n,1;;;;astep]],rev,True]-1)+1;
				Graphics[Table[{ColFun[i,segm],Line[lines[[n,#]]]&/@angsp[[i]]},{i,1,segm}]],
				Graphics[]
			];
						
			(*locator pane*)
			Column[{
				(*sclice buttons*)
				Row[{Button["<<<",n=1],Button["<<", n=start],Button["<",n=n-1], Button[">",n=n+1],Button[">>",n=end],Button[">>>",n=slices]}]
				,
				(*locator pane *)
				LocatorPane[
					(*dynamic points*)
					Dynamic[points[[n]]],
					(*dynamic plot*)
					Dynamic[Show[anatomypl,maskpl,polplot,lineplot,lineplot2,pointplot,circplot,centerpl[[n]], ImageSize->600]]
					(*locator appearance*)
					,Appearance->{Graphics[{Green,Disk[]},ImageSize->15],Graphics[{Blue,Disk[]},ImageSize->15]}
				]
			},Alignment->Center]
			,
			(*manipulate controls*)
			{{n,Round[slices/2],"Slice"},1,slices,1},
			{{mop,.2,"Mask opacity"},0,1},
			{{masktype,True,"show lines mask"},{True->"threshold mask",False->"normal mask"}},
			{{segmi,"AHA","Number of segments"},{1->"1 per sliec",2->"2 per sliec",4->"4 per slice",6->"6 per slice",8->"8 per slice","AHA"->"AHA-17","AHA+"->"AHA-24"}},
			PaneSelector[{
				False->"",
				True-> Control[{{slcgrp,True,"Use slice grouping:"},{False->"group by slice",True->"group by region"},ControlType->SetterBar}]
				},
				Dynamic[NumberQ[segmi]]
			],
			Delimiter,
			
			(*point controls*)
			Row[{
				Button["Reverse points",rev=If[rev==1,-1,1];points=Reverse/@points,FrameMargins->0,Appearance->If[rev==-1,"Pressed","Normal"]],
				Button["Reset points",points=pointsIn,FrameMargins->0],
				Button["Rotate points -90",points=MapThread[{RotatePointC[#1[[1]],#2,-.5Pi],RotatePointC[#1[[2]],#2,-.5Pi]}&,{points,centers}],FrameMargins->0],
				Button["Rotate points 90",points=MapThread[{RotatePointC[#1[[1]],#2,.5Pi],RotatePointC[#1[[2]],#2,.5Pi]}&,{points,centers}],FrameMargins->0]
			}],
			
			(*display controls*)
			Delimiter,
			{{display,{1,4},"display"},{1->"arrows",4->"disks",2->"lines",5->"lines mask",3->"points mask"},ControlType->TogglerBar},
			{{mesh,False,"show gridlines"},{False,True}},
			{{astep,3,"line resolution"},1,5,1},
			{{linetr,OptionValue[LineThreshold],"line threshold"},0.1,1,.05},
			Button["recalculate lines", {lines, lineAng} = LinePoints[mask,off,LineThreshold->linetr,LineStep->OptionValue[LineStep]];],
			
			Delimiter,
			(*slice segmentation*)
			Column[{
			(*slices slider*)
				Row[{
					VerticalSlider[Dynamic[start],{0,slices,1},Background->Lighter@Gray, Appearance -> {Vertical, Tiny}],"  ",
					VerticalSlider[Dynamic[ap],{0,slices,1},Background->Lighter@Orange, Appearance -> {Vertical, Tiny}],"  ",
					VerticalSlider[Dynamic[mid],{0,slices,1},Background->Lighter@Blue, Appearance -> {Vertical, Tiny}],"  ",
					VerticalSlider[Dynamic[bas],{0,slices,1},Background->Lighter@Red, Appearance -> {Vertical, Tiny}],"  ",
					VerticalSlider[Dynamic[end],{0,slices,1},Background->Lighter@Purple, Appearance -> {Vertical, Tiny}],"      ",
					Dynamic[Show[carPl,allpl]]
				}]
			}]
			,
			(*close buttons*)
			Delimiter,
			Row[{
				DefaultButton["Done",DialogReturn[
					{segmask, segang, points} = GenerateOutput[points,centers,segments,rev,NumberQ[segmi],slcgrp,coordinates,Dimensions[mask],lines,lineAng];
					
					segang=Map[{#[[1]], DeleteCases[#[[2]], {}]} &, segang, {2}];
					
					{segmask,segang, {{points,rev},{start,ap,mid,bas,end}}}
					]
				],
				CancelButton["Cancel",DialogReturn[$Canceled]]
			}],
			
			(*hidden controls*)
			{{points,pointsIn},ControlType->None},
			{angs,ControlType->None},
			{angsp,ControlType->None},
			{angsp2,ControlType->None},
			{segpt,ControlType->None},
			{segm,ControlType->None},
			{segpts,ControlType->None},
			{rad,ControlType->None},
			{cent,ControlType->None},
			{pols,ControlType->None},
			{dsks,ControlType->None},
			{pts,ControlType->None},
			{{slcgrp,True},ControlType->None},
			{{rev,revi},ControlType->None},
			
			
			{{lmm,lm[[2]]},ControlType->None},
			
			{{ap,api},ControlType->None},
			{{mid,midi},ControlType->None},
			{{bas,basi},ControlType->None},
			{{end,endi},ControlType->None},
			{{start,sti},ControlType->None},
			{{allpl,allpli},ControlType->None},
			
			{apex,ControlType->None},
			{apical,ControlType->None},
			{midcavity,ControlType->None},
			{basal,ControlType->None},
			
			{segments,ControlType->None},
			{backcols,ControlType->None},
			{backcol,ControlType->None},
			{colls,ControlType->None},
			
			{anatomypl,ControlType->None},
			{maskpl,ControlType->None},
			{polplot,ControlType->None},
			{lineplot,ControlType->None},
			{lineplot2,ControlType->None},
			{pointplot,ControlType->None},
			{circplot,ControlType->None},
			
			(*initialization*)
			ControlPlacement->Left,
			SynchronousUpdating->True, SynchronousInitialization -> False
		]
	]
	(*close dialog input*)
	},WindowTitle->"Segement the heart",WindowFloating->True,Modal->False
];


(* ::Subsubsection::Closed:: *)
(*ColFun*)


ColFun[i_,seg_,back_]:=If[back===Gray,back,If[seg==1,ColorData["Rainbow"][0.],ColorData["Rainbow"][((i-1)/(seg-1.))]]]

ColFun[i_,seg_]:=If[seg==1,ColorData["Rainbow"][0.],ColorData["Rainbow"][((i-1)/(seg-1.))]]


(* ::Subsubsection::Closed:: *)
(*RegionDisk*)


RegionDisk[cent_,ang_,ran_,rev_]:=Block[{ans},
	ans=Partition[If[Negative[#],#+2Pi,#]&/@(-ang+0.5Pi),2,1,1];
	If[rev==1,
		Disk[cent,ran,If[#[[1]]>#[[2]],#,#+{0,-2Pi}]]&/@ans,
		Disk[cent,ran,If[#[[2]]>#[[1]],Reverse@#,Reverse[#+{0,+2Pi}]]]&/@ans
	]
]


(* ::Subsubsection::Closed:: *)
(*RegionPoints*)


RegionPoins[cent_,angs_,points_]:=Block[{pts},
	If[Length[angs]==1,
		{points},
		If[points==={},
			ConstantArray[{},Length[angs]]
			,
			pts=Partition[RotateRad[5000,cent,#]&/@angs,2,1,1];
			Pick[points,RegionMember[Polygon[Prepend[#,cent]+0.5],points]]&/@pts
		]
	]
]


(* ::Subsubsection::Closed:: *)
(*RadCalcC*)


RadCalcC = Compile[{{pnt,_Real,2},{cent,_Real,1}}, Mean[Norm[#-cent]&/@pnt]];


(* ::Subsubsection::Closed:: *)
(*VecAngleC*)


VecAngleC=Compile[{{pnt,_Real,2},{cent,_Real,1},{num,_Integer,0},{rev,_Real,0}},
	Block[{x1,x2,y1,y2,ang1,ang2,angs,angs2,angsout,diff},
		{{x1,y1},{x2,y2}}=(#-cent&/@pnt);
		
		ang1=ArcTan[y1,x1];
		ang2=ArcTan[y2,x2];
		
		diff=If[rev==1,ang2-ang1,ang1-ang2];
		diff=If[Negative[diff],2Pi+diff,diff];
		
		angs={
			ang1,
			ang2,
			1./2 diff,
			1./4 (2Pi- diff),
			1./3 (2Pi- diff),
			1./3 diff,
			1./5 (2Pi- diff)
			};
		
		(*define angels based on number of segments*)
		angs2 = Switch[num,
			0, {0.123},
			1, {angs[[1]]},
			2, {angs[[1]], angs[[2]]},
			4, {angs[[1]]-(rev angs[[5]]), angs[[1]], angs[[2]], angs[[2]]+(rev angs[[5]])},
			6, {angs[[1]]-(rev angs[[4]]), angs[[1]], angs[[1]]+(rev angs[[3]]), angs[[2]], angs[[2]]+(rev angs[[4]]), angs[[2]]+(rev 2 angs[[4]])},
			8, {angs[[1]]-(rev 2 angs[[7]]), angs[[1]]-(rev angs[[7]]), angs[[1]], angs[[1]]+(rev angs[[6]]), angs[[1]]+(rev 2 angs[[6]]), angs[[2]], angs[[2]]+(rev angs[[7]]), angs[[2]]+(rev 2 angs[[7]])},
			_, {angs[[1]]}	
		];
		
		(*export angles that are always between 0 and 2Pi*)
		If[Negative[#],2Pi+#,#]&/@angs2
	]
];


(* ::Subsubsection::Closed:: *)
(*RotatePointC*)


RotatePointC=Compile[{{pt,_Real,1},{cent,_Real,1},{ang,_Real,0}},({{Cos[ang], Sin[ang]}, {-Sin[ang], Cos[ang]}} . (pt-cent))+cent];


(* ::Subsubsection::Closed:: *)
(*RotateRad*)


RotateRad[_, _, 0.123] = {};

RotateRad[_, _, {}] = {};

RotateRad[rad_,cent_,ang_] := RotateRadC[rad, cent, ang];

RotateRadC=Compile[{{rad,_Real,0},{cent,_Real,1},{ang,_Real,0}},(cent+{{Cos[ang], Sin[ang]}, {-Sin[ang], Cos[ang]}} . {0,rad})];


(* ::Subsubsection::Closed:: *)
(*AngPart*)


Angpart[{0.123},___] = {}

Angpart[angs_,angles_,rev_,ind_:False]:=Block[{pang,end,start,sel},
	pang = Partition[angs,2,1,1];
	pang = ({start,end}=If[rev==1,#,Reverse@#];
		If[start<end,
			Select[angles, start<#<=end&],
			Select[angles, #<=end||start<#&]
		])&/@pang;
	If[ind,	Map[First@FirstPosition[angles,#]&,pang,{2}],pang]
]


(* ::Subsubsection::Closed:: *)
(*LinePoints*)


Options[LinePoints] = {LineThreshold->.3,LineStep->.75};

LinePoints[mask_, off_, opts : OptionsPattern[]] := Transpose@MapThread[LinePoints[#1, #2, opts] &, {mask, off}]

LinePoints[mask_?MatrixQ, off_?VectorQ, OptionsPattern[]] := Block[{
	step, tresh,dimy,dimx,dim,maskf,cent,seg,min,mout,ptsol,ptsil,ptso,ptsi,intDis,dist, ord,
	ptsml,ptsm,centval, int1,int2,intDer,centVal,int,x,y,val,vali,vec,ii,lines,angles
	},
	(*options*)
	step=OptionValue[LineStep];
	tresh=OptionValue[LineThreshold];
	
	(*prepare data*)
	{dimy,dimx}=dim=Dimensions[mask];
	maskf=GaussianFilter[N[mask],2];
	cent=off[[{3,2}]];
	
	(*check if there is a mask*)
	If[Total[Flatten[maskf]]<2,
		(*if no maks do nothing*)
		(*Print["no Mask"];*)
		ptsm=Table[RotationMatrix[-i Degree] . {0.,1.},{i,0,359,1.}];
		angles = AngFun[cent, ptsm];
		(*angles=(ArcTan@@Normalize[#-cent])&/@ptsm;*)
		lines=ConstantArray[{},360];
		,
		(*get the inner and/or outer mask*)
		seg=MorphologicalComponents[N[1-mask]];
		seg=If[#[[1,1]]==2,#/.{2->1,1->2},#]&[seg];
		min=Unitize[Clip[seg,{1.5,2},{0,0}]];
		mout=Unitize[1-Clip[seg,{0,1},{0,0}]];
		
		(*check which method to use*)
		(*1. both inner and outer mask*)
		(*2. apex, only other mask with cent in the mask*)
		(*3. base, no closed maks with cent outside the mask*)
		If[Total[Flatten[min]]=!=0,
			(*Print["inner and outer mask"];*)
			(*there is an inner and outer mask - here lines are formed perpendicular to the wall*)
			
			(*get outer and inner points - 720 points equally distributed radially*)
			{ptsol,ptso}=PerimiterPoints[Ceiling[GaussianFilter[mout,2]-tresh],dim,.5];
			{ptsil,ptsi}=PerimiterPoints[Dilation[Floor[(GaussianFilter[min,2]+tresh)],1],dim,.5];
			
			(*make the distance map function*)
			intDis=Interpolation[Join[Thread[{ptsol,1}],Thread[{ptsil,0}]],InterpolationOrder->1,"ExtrapolationHandler"->{First@Nearest[Join[Thread[ptsol->1],Thread[ptsil->0]],{#1,#2},1]&,"WarningMessage"->False}];
			(*fill the distance map*)
			dist=1-mout;
			(dist[[#[[1]],#[[2]]]]=intDis[#[[2]]-0.5,dimy-#[[1]]+0.5])&/@Position[mask,1];
			
			(*get the mid wall points*)
			{ptsml,ptsm}=PerimiterPoints[Ceiling[0.5-dist],dim];
			
			(*get the wall derivatives*)
			(*make the derivative funciton - vector pointing perpendicular to the wall at wall mid point*)
			{int1,int2}=ListInterpolation[GaussianFilter[dist,{5,5},#],InterpolationOrder->1]&/@IdentityMatrix[2];
			intDer={int2[#[[2]],#[[1]]],int1[#[[2]],#[[1]]]}&;
			
			(*get the line points and angles*)
			angles = AngFun[cent, ptsm];
			(*angles=(ArcTan@@Normalize[#-cent])&/@ptsm;*)
			lines=(step=Normalize[intDer[#]];{FindPoint[#,-step,ptsi],FindPoint[#,step,ptso]})&/@ptsm;
			,
			(*ther is only an outer mask*)
			centVal=mask[[Round[off[[2]]],Round[off[[3]]]]];
			If[centVal===1,
				(*Print["center in the mask"];*)
				(*the center falls within the mask - apex region*)
				{ptsol,ptso}=PerimiterPoints[Ceiling[GaussianFilter[mout,2]-tresh],dim];
				
				(*get the line points and angles*)
				angles = AngFun[cent, ptso];
				(*angles=(ArcTan@@Normalize[#-cent])&/@ptso;*)
				lines=Thread[{ConstantArray[cent,Length[ptso]],ptso}];
				,
				(*Print["center outside the mask"];*)
				(*the center falls outside the mask*)
				ptsm=Table[RotationMatrix[-i Degree] . {0.,1.},{i,0,359,1.}];
				int=ListInterpolation[maskf,InterpolationOrder->1];
				{x,y}=cent;
				vali=int[y+0.5,x+0.5]-tresh;
				
				(*get the line points and angles*)
				angles = AngFun[cent, ptsm];
				(*angles=(ArcTan@@Normalize[#-cent])&/@ptsm;*)
				lines=Map[(
					vec=#;
					ii=0;
					val=vali;
					{x,y}=cent;
					(*find the first position for which point is inside the mask*)
					While[(1+step<=y<=dimy-step-1&&1+step<=x<=dimx-step-1&&val<=0.),{x,y}=cent+(ii step) vec;val=int[y+0.5,x+0.5]-tresh;ii++;];
					ptsi=cent+((ii-1) step) vec;
					(*Then find the first position for which point is outside the mask again*)
					While[(1+step<=y<=dimy-step-1&&1+step<=x<=dimx-step-1&&val>0.),{x,y}=cent+(ii step) vec;val=int[y+0.5,x+0.5]-tresh;ii++;];
					ptso=cent+((ii-2) step) vec;
					(*if none found return {} else return cent and firt point*)
					If[val>-tresh,{ptsi,ptso},{}]
				)&,ptsm];
			]
		]
	];
	
	(*put everythin in order*)
	ord=Ordering[angles];
	{lines[[ord]],angles[[ord]]+Pi}
]


AngFun[cent_, pts_] := -(ArcTan @@ ({-1, 1} Reverse[Normalize[# - cent]])) & /@ pts


(* ::Subsubsection::Closed:: *)
(*PerimiterPoints*)


PerimiterPoints[im_,{x_,_},deg_:1]:=Block[{pts,ptsp,len,int},
	ptsp=ComponentMeasurements[Image[im],"PerimeterPositions"][[1,2,1]];
	pts=Append[ptsp,First[ptsp]];
	len=Prepend[Accumulate[ArcLength[Line[#]]&/@Partition[pts,2,1]],0];
	int=Interpolation[Thread[{len,pts}],InterpolationOrder->1];
	pts=int/@Range[0,Max[len],Max[len]/((360/deg)-1)];
	pts={0,x}+{1,-1}#&/@pts;
	{ptsp,pts}
]


(* ::Subsubsection::Closed:: *)
(*FindPoint*)


FindPoint[pmid_,step_,pts_]:=Block[{ptar,pnear,ni,nd,n,fnear,v,u},
	(*define line perpendicular to wall and find nearest wall point*)
	ptar=pmid+step;
	pnear=First@Nearest[pts,ptar,1];
	ni=nd=Sqrt[Total[(pnear-ptar)^2]];
	
	(*project point on line and find the new point closest to new line*)
	While[nd>10^-3,
		v=ptar-pmid;u=pnear-pmid;
		ptar=pmid+(v . u/v . v)v;
		pnear=First@Nearest[pts,ptar,1];
		n=Sqrt[Total[(pnear-ptar)^2]];
		nd=Abs[n-ni];ni=n;
	];
	pnear
]


(* ::Subsubsection::Closed:: *)
(*GenerateOutput*)


GenerateOutput[points_,centers_,segments_,rev_,numSeg_,slcGrp_,coordinates_,dim_,lines_,angles_]:=Block[{
	slices, dim2, segm, segs, nseg, rule, segmask, segang,cent, angs, mask, tmp, sls},
	
	(*get paramters*)
	slices=dim[[1]];
	dim2=Drop[dim,1];
	segm=Flatten[Thread/@segments];
	
	(*only select the segments to use - discard the none segment*)
	segs=Select[segments,#[[2]]=!=0&];
	nseg=Length[segs];
	rule = Thread[Range[nseg]->segs[[All,2]]];
	
	(*create mask per slice from points*)
	{segmask,segang} = Transpose@Table[
		If[(n/.segments)==0,
			{ConstantArray[0,dim2],{}}
			,
			(*calculate the anlges for segments*)
			cent=centers[[n]];
			angs = VecAngleC[points[[n]],cent,n/.segm,rev];
			Print[angs];
			(*make the masks*)
			mask = Normal[SparseArray[Reverse/@#1 -> 1, dim2]]&/@RegionPoins[cent,angs,coordinates[[n]]];
			(*partition the angles*)
			angs = lines[[n,#]]&/@Angpart[angs,angles[[n]],rev,True];
			(*outupt*)		
			{mask,angs}
		]
	,{n,1,slices,1}];
	
	(*group mask slices for AHA 17 segments*)
	segmask = If[!numSeg||slcGrp,
		Flatten[Table[
			tmp=ConstantArray[0,Flatten[{segments[[i,2]],dim}]];
			sls=segments[[i,1]];
			If[sls=!={},tmp[[All,sls]]=Transpose[segmask[[sls]]]];
			tmp
		,{i,nseg,1,-1}],1]
		,
		Transpose@segmask
	];

	(*group radial coordinates for AHA 17 segments*)
	segang = If[!numSeg||slcGrp,
		Flatten[Table[
			sls=segments[[i,1]];
			If[sls==={},
				ConstantArray[{}, i/.rule],
				Transpose@MapThread[(Thread[{#2,#1}])&,{segang[[sls]],sls}]
			]
		,{i,nseg,1,-1}],1]
		,
		Transpose@MapIndexed[Thread[{First[#2],#1}]&,segang,1]
	];
	{segmask,segang,Reverse@points}
]


(* ::Subsection:: *)
(*PlotSegments*)


(* ::Subsubsection::Closed:: *)
(*PlotSegments*)


Options[PlotSegments] = {RadialSamples -> 10};

SyntaxInformation[PlotSegments] = {"ArgumentsPattern" -> {_, _, _, OptionsPattern[]}};

PlotSegments[data_, mask_, angs_, OptionsPattern[]] := Block[{pan}, 
 	pan = Manipulate[ 		
 		slices=angs[[n,All,1]];
 		pts=DeleteCases[#,{}]&/@angs[[n,All,2]];
 		nmr=Range[Length[slices]];
 		
 		datpl=ArrayPlot[data[[#]], DataReversed -> True, ColorFunction -> "GrayTones"]&/@slices;
 		maskpl=mask[[slices]];
 		
 		size = Length[angs[[n]]] 250;
 		(*switch between views*)
 		GraphicsRow[Show[
 		Switch[m,
 			(*mask with inner and outer pionts only*) 
 			1, {datpl[[#]],
 				If[NumberQ[Mean[Flatten[pts[[#]]]]],
 					ListPlot[{pts[[#,All,1]], pts[[#,All,2]]}, AspectRatio -> 1, PlotStyle -> {Red, Orange}],
 					Graphics[]
 				]},
 			(*mask with inner and outer points plus radial samples*)
 			2, {datpl[[#]],
 				If[NumberQ[Mean[Flatten[pts[[#]]]]],
 					ListPlot[Transpose@PointRange[pts[[#]], OptionValue[RadialSamples]], AspectRatio -> 1],
 					Graphics[]
 				]},
 			3, {
 				If[NumberQ[Mean[Flatten[pts[[#]]]]],
 					ArrayPlot[Fun[maskpl[[#]], Round[pts[[#,All,1]]], Round[pts[[#,All,2]]]], DataReversed -> True, ColorFunction -> "GrayTones"],
 					ArrayPlot[maskpl[[#]], DataReversed -> True, ColorFunction -> "GrayTones"]
 				]}
     		]
 		] &/@ nmr, ImageSize->size], 
	    {{n, 1, "segment"}, 1, Length[angs], 1}, 
	    {{m, 1, "plot type"}, {1 -> "start stop point", 2 -> "radial samples", 3 -> "mask"}}, 
	    {size, ControlType -> None},
	    {pts, ControlType -> None},
	    {nmr, ControlType -> None},
	    {slices, ControlType -> None},
	    {datpl, ControlType -> None},
	    {maskpl, ControlType -> None},
	    
	    SaveDefinitions->True
     ];
  NotebookClose[plotwindow];
  plotwindow = CreateWindow[DialogNotebook[{CancelButton["Close", DialogReturn[]], pan}, WindowSize -> All, WindowTitle -> "Plot data window"]];
  ]


(* ::Subsubsection::Closed:: *)
(*Fun*)


Fun[mask_,pts1_,pts2_]:=Block[{tmp=mask},
	(tmp[[#[[2]],#[[1]]]]=10)&/@pts1;
	(tmp[[#[[2]],#[[1]]]]=-10)&/@pts2;
	tmp]


(* ::Subsubsection::Closed:: *)
(*PointRange*)


PointRange[pts_,steps_]:=Block[{step=steps-1,pt1,pt2},
	(
	pt1=#[[2,{1,2}]];
	pt2=#[[1,{1,2}]];
	Table[pt2+(i (pt1-pt2)/step),{i,0,step,1}]
	)&/@pts
]

PointRange[pts_,steps_,drop_]:=Block[{step=steps-1,pt1,pt2},
	(
	pt1=#[[2,{1,2}]];
	pt2=#[[1,{1,2}]];
	Take[Table[pt2+(i (pt1-pt2)/step),{i,0,step,1}],{1+drop,steps-drop}]
	)&/@pts
]


(* ::Subsection::Closed:: *)
(*PlotSegmentsMask*)


SyntaxInformation[PlotSegmentMask] = {"ArgumentsPattern" -> {_, _, _}};

PlotSegmentMask[maski_, segmaski_, vox_] := Block[{heart, seg,pan},
	heart = PlotMaskVolume[maski, vox];
	seg = PlotMaskVolume[segmaski[[#]], vox, Red,Filter->False] & /@ Range[Length[segmaski]];
	pan=Manipulate[
		GraphicsGrid[{{
			Show[heart, seg[[n]]],
			Show[heart, seg[[n]], ViewPoint -> Front, Method -> {"RotationControl" -> None}]
			},{
			Show[heart, seg[[n]], ViewPoint -> Top, Method -> {"RotationControl" -> None}],
			Show[heart, seg[[n]], ViewPoint -> Left, Method -> {"RotationControl" -> None}]
		}}, ImageSize -> 600]
   , {{n,1,"Segment"}, 1, Length[segmaski], 1},SaveDefinitions->True];
   
   NotebookClose[plotwindow];
   plotwindow = CreateWindow[DialogNotebook[{CancelButton["Close", DialogReturn[]], pan}, WindowSize -> All, WindowTitle -> "Plot data window"]];
]


(* ::Subsection::Closed:: *)
(*RadialSample*)


Options[RadialSample]={RadialSamples->10, DropSamples->0};

SyntaxInformation[RadialSample] = {"ArgumentsPattern" -> {_, _, _, OptionsPattern[]}};

RadialSample[mask_,data_,segang_,OptionsPattern[]]:=Block[{
	pos,dat,val,intdat,exdat,intfunc, output,slice,pts,int,ptsr,vals
	},

	(*slice by slice interpolation function*)
	intfunc = MapThread[(
		pos = Position[Round[#1], 1];
		dat = #2;
		val = dat[[#[[1]], #[[2]]]] & /@ pos;
		If[pos =!= {},
			intdat = N@Thread[{pos, val}];
			exdat = N@Thread[pos -> val];
			With[{nearF = Nearest[exdat]}, Interpolation[intdat, InterpolationOrder -> 1,
				"ExtrapolationHandler" -> {Mean[nearF[{#1, #2}, 3]] &, "WarningMessage" -> False}]
			],
			0 &
		]
	) &, {mask, data}, 1];
	
	output = Map[(
		slice = #[[1]];
		pts = #[[2]];
		int = intfunc[[slice]];
		
		If[pts=!=None,
			(*get radial pts steps*)
			ptsr = PointRangeC[pts, OptionValue[RadialSamples],OptionValue[DropSamples]];
			vals = int @@ Transpose[ptsr, {2, 3, 1}];
			{ptsr, vals},
			{{}, {}}
		]
	) &, segang, {2}];
	
	{output[[All,All,1]],output[[All,All,2]]}
]

PointRangeC = Compile[{{pts, _Real, 2}, {steps, _Integer, 0}, {drop, _Integer, 0}}, Block[{n, step},
	n = steps - 1;
	step = (pts[[2]] - pts[[1]])/n;
	pts[[1]] + # step & /@ Range[0 + drop, n - drop]
], RuntimeAttributes -> {Listable}, RuntimeOptions -> "Speed"];


(* ::Subsection::Closed:: *)
(*TransmuralPlot*)


Options[TransmuralPlot] = {GridLineSpacing -> 10, PlotStyle -> Red, PlotRange -> Automatic, ImageSize->300, Method->"Median", PlotLabel->None}

SyntaxInformation[TransmuralPlot] = {"ArgumentsPattern" -> {_, OptionsPattern[]}};

TransmuralPlot[data_, OptionsPattern[]] := Block[{mn, std, steps, stdM, stdP, xdata, min, max, col,pdat,dat,fil,style},
	dat=If[ArrayDepth[data]==1,
		{data},
		Switch[OptionValue[Method],
			"Median", Transpose[Quantile[data, {.5, .35, .65}]],
			"MedianQ", Transpose[Quantile[data, {.5, .25, .75}]],
			"MedianSD", Transpose[Quantile[data, {.5, .16, .84}]],
			"Median95", Transpose[Quantile[data, { .5, .05, .95}]],
			"Median0", Transpose[Quantile[data, {.5}]],
			_, 
			mn = Mean[data];
			std = StandardDeviation[data];
			{stdM, stdP} = {mn - std, mn + std};
			{mn,stdM,stdP}
		]
	];
	
	steps = Length[dat[[1]]];
	xdata = (Range[0, steps - 1])/(steps - 1);
	pdat=(Thread[{xdata, #}]&/@ dat);
	
	fil=If[OptionValue[Method]=="Median0",None,{2 -> {3}}];
	{min, max} = If[OptionValue[PlotRange] === Automatic, MinMax[dat], OptionValue[PlotRange]];
	
	style=If[ArrayDepth[data]==1,
		OptionValue[PlotStyle],
		col = OptionValue[PlotStyle];
		(Directive[#, col,Thick] & /@ {Dashing[None], Dashed, Dashed})
	];
	
	col = OptionValue[PlotStyle];
	ListLinePlot[pdat, PlotStyle ->style, Filling -> fil, FillingStyle -> Directive[Opacity[0.2], col],
		Axes -> False, Frame -> {{True, False}, {True, False}}, FrameStyle -> Directive[{Thick, Black}],
		LabelStyle -> Directive[{Bold, Black, 14, FontFamily -> "Helvetica"}], PlotRange -> {{0, 1}, {min, max}},
		ImageSize->OptionValue[ImageSize],PlotLabel->OptionValue[PlotLabel], 
		GridLines -> {{{.5, Directive[Thick, Black, Dashed]}}, Join[System`FindDivisions[{min, max},Round[(max-min)/ OptionValue[GridLineSpacing]]], {{0, Directive[{Thick, Black}]}}]},
		FrameTicks -> {{{0, "Endo"}, {.5, "Mid"}, {1, "Epi"}}, Automatic}
	]
]


(* ::Subsection::Closed:: *)
(*MaskHelix*)


Options[MaskHelix]={BackgroundValue-> -100, SmoothHelix->False};

SyntaxInformation[MaskHelix] = {"ArgumentsPattern" -> {_, _, OptionsPattern[]}};

MaskHelix[helix_, mask_,OptionsPattern[]] := Block[{fun},
	fun=Switch[
		OptionValue[SmoothHelix],
		1, N[mask MedianFilter[#, 1]] /. 0. -> OptionValue[BackgroundValue],
		_, N[mask #] /. 0. -> OptionValue[BackgroundValue]
		]&;
	If[ArrayDepth[helix]==4,fun/@helix,fun[helix]]	
]


(* ::Subsection::Closed:: *)
(*BullseyePlot*)


Options[BullseyePlot]={
	TextOffset->.5,
	TextSize->12,
	PlotRange->Automatic, 
	ColorFunction->"TemperatureMap", 
	BullPlotMethod->"Dynamic", 
	TextNumberForm->{5,2},
	ImageSize->200
};

SyntaxInformation[BullseyePlot] = {"ArgumentsPattern" -> {_, _., OptionsPattern[]}};

BullseyePlot[data_?ArrayQ,segMask_?ArrayQ,opts:OptionsPattern[]]:=Block[{fdata}, 
	fdata=(Flatten@GetMaskData[data,#])&/@segMask;
	BullseyePlot[fdata,opts]
]

BullseyePlot[dati_?ListQ,OptionsPattern[]]:=Block[{number, radius, datat, min, max, cols, sdata, pts, disks, textv, textn, plfun, col},
	number = {6, 6, 4, 1};
	radius = {4.9, 3.6, 2.3, 1};
	datat = If[# === {} || NumberQ[#], #, Round[Mean[#], .01]] & /@ dati;
	{min, max} = If[OptionValue[PlotRange] === Automatic, MinMax[DeleteCases[datat, 0.]], OptionValue[PlotRange]];
	
	cols = (# -> Show[ColorData[#, "Image"], ImageSize -> 100]) & /@ {"GrayTones", "Rainbow", "ThermometerColors", "SunsetColors", "TemperatureMap", "GrayYellowTones", "BlueGreenYellow", "AvocadoColors", "SouthwestColors"};
	
	max = If[max <= min, min + 0.1, max];
	sdata = (datat - min)/(max - min);
	
	pts = Flatten[Table[If[i == 4, {{0, 0}}, RotationMatrix[# Degree] . {0,radius[[i]] - 1.3 OptionValue[TextOffset]} & /@ Range[0, 359, 360/number[[i]]]], {i, 4}], 1];
	
	disks = Flatten[{
		Table[{col, Disk[{0, 0}, radius[[1]], Pi/3 {i, i + 1}]}, {i, 1, 6}],
		Table[{col, Disk[{0, 0}, radius[[2]], Pi/3 {i, i + 1}]}, {i, 1, 6}],
		Table[{col, Disk[{0, 0}, radius[[3]], (i - 1) Pi/2 + {Pi/4, 3 Pi/4}]}, {i, 1, 4}],
		{{col, Disk[{0, 0}, radius[[4]], {0, 2 Pi}]}}
	}, 1];
	
	textv = Table[Text[Style[If[datat[[i]] === {} || sdata[[i]] < 0, "", NumberForm[datat[[i]],OptionValue[TextNumberForm]]], Bold, FontFamily -> "Helvetica", Black, FontSize -> OptionValue[TextSize]], pts[[i]]],{i, 17}]; 
	textn = Table[Text[Style[If[datat[[i]] === {} || sdata[[i]] < 0, "", i], Bold, FontFamily -> "Helvetica", Black, FontSize -> OptionValue[TextSize]], pts[[i]]], {i, 17}];
	
	plfun[{colf_, cstyle_}, {pText_, textVal_}] := Block[{blcol, colfunc}, 
		Legended[
			blcol = If[colf == "GrayTones", Darker[Red], Gray];
			colfunc = ColorData[colf][If[cstyle, 1 - #, #]] &;
			Graphics[{EdgeForm[{Thick, Black}], MapThread[#1 /. If[#2 === {} || #2 < 0, col -> blcol, col -> colfunc[#2]] &, {disks, sdata}], If[pText, Switch[textVal, 1, textn, 2, textv]]},
				ImageSize -> OptionValue[ImageSize]], 
			BarLegend[{colf, {min, max}}, LabelStyle -> Directive[{Bold, Black, FontFamily -> "Helvetica", FontSize -> OptionValue[TextSize]}], LegendMarkerSize -> 0.8 OptionValue[ImageSize]]
		]
	];
	
	pan = Manipulate[
		plfun[{colf, cstyle}, {pText, textVal}]
		,
		{{pText, True, "Show labels"}, {True, False}},
		{{textVal, 2, "Label"}, {1 -> "Segment", 2 -> "Value"}},
		{{colf, OptionValue[ColorFunction], "Color function"}, cols},
		{{cstyle, False, "Reverse color"}, {True, False}},
	SaveDefinitions->True, Deployed->False, SynchronousInitialization -> False];
	
	If[OptionValue[BullPlotMethod] === "Dynamic",
		NotebookClose[plotwindow];
		plotwindow = CreateWindow[DialogNotebook[{CancelButton["Close", DialogReturn[]], pan}, WindowSize -> All, WindowTitle -> "Plot data window"]];
		,
		plfun[{OptionValue[ColorFunction], False}, {True, 2}]
	]
]


(* ::Subsection:: *)
(*ExcludeSlices*)


(* ::Subsubsection::Closed:: *)
(*ExcludeSlices*)


Options[ExcludeSlices] = {CutOffMethod -> "Auto",DistanceMeasure->5, ShowOutliers->False};

SyntaxInformation[ExcludeSlices] = {"ArgumentsPattern" -> {_, OptionsPattern[]}}

ExcludeSlices[data_, OptionsPattern[]] := Block[{measure, selmask, cutoff, std, mn, bin, type,q1,q2,q3},
	type = OptionValue[DistanceMeasure];
	cutoff = OptionValue[CutOffMethod];
	(*get similarity measure*)
	measure = CalculateMeasure[data, type];
	(*calculate cutoff and selection mask*)
	cutoff = If[NumberQ[cutoff] && cutoff < .5, Quantile[Flatten@measure, cutoff],
		{q1, q2, q3} = Quantile[Flatten[measure], {0.25, 0.5, .75}];
		q2 - 2 (q3 - q1)
	];
	selmask = Mask[measure, cutoff];
	(*report the outliers*)
	If[OptionValue[ShowOutliers],ShowOutlierDistribution[measure, selmask, cutoff]];
	(*output mask*)
	selmask
]


(* ::Subsubsection::Closed:: *)
(*ShowOutlierDistribution*)


ShowOutlierDistribution[measure_, selmask_, cutoff_] := Block[{mn, fmeas, minmax},
	
	fmeas = Flatten@measure;
	mn = Mean@fmeas;
	minmax = MinMax[fmeas];
	
	(*Plot Outlier distributions*)
	Print[GraphicsRow[{
		ListPlot[fmeas, GridLines -> {None, Flatten[{mn, cutoff}]}, GridLinesStyle -> Directive@{Thick, Red}, PlotStyle -> Directive@{PointSize[0.03], Black}, PlotRange -> {All, minmax}],
		Histogram[fmeas, {(minmax[[2]] - minmax[[1]])/20}, ChartStyle -> Black, PerformanceGoal -> "Speed", GridLines -> {{mn, cutoff}, None}, GridLinesStyle -> Directive@{Thick, Red}, PlotRange -> {minmax, Full}]
	}, PlotLabel -> {mn, StandardDeviation[fmeas], cutoff}]];
	
	(*report outliers*)
	Print@Row[Flatten[{"% slices excluded: ", Round[100 Total[Flatten[(1 - selmask)]]/Length[Flatten@selmask]], "  /  ", "% directions per slice exlcuded: ", Round[100 (Total[(1 - #)]/Length[#] & /@ selmask)]}], "  "];
]


(* ::Subsubsection::Closed:: *)
(*CalculateMeasure*)


CalculateMeasure[data_, type_] := Block[{
	target, datan, fun, measure, slice, dirs, mask,mm,q1,q2,q3,iqr
	},
	
	target = Median /@ data;
	target = Flatten /@ (target/Median[Flatten[target]]);
	datan = Map[Flatten[#/Median[Flatten[#]]] &, data, {2}];
	{slice, dirs} = Dimensions[datan][[1 ;; 2]];
	
	(*select distance measure*)
	fun = Switch[type,
		1, ManhattanDistance,
		2, SquaredEuclideanDistance,
		3, EuclideanDistance,
		4, Correlation,
		5, SpearmanRho,
		_, SpearmanRho
	];
	(*calculate measure*)
	measure = Table[
		mask=Unitize[target[[i]] datan[[i, j]]];
		fun[Pick[target[[i]], mask, 1], Pick[datan[[i, j]], mask, 1]],
   	 {i, 1, slice, 1}, {j, 1, dirs, 1}];
   	 
   	 (*normalize measure*)
   	 measure = (
   	 	mm = #;
   	 	{q1, q2, q3} = Quantile[#, {0.25, 0.5, .75}];
   	 	iqr = q3 - q1;
   	 	mm = Select[mm, ((q1 - 1 iqr) < # < (q3 + 1 iqr)) &];
   	 	{q1, q2, q3} = Quantile[mm, {0.25, 0.5, .75}];
   	 	iqr = q3 - q1;
   	 	mm = Select[mm, ((q1 - 1 iqr) < # < (q3 + 1 iqr)) &];
   	 	{q1, q2, q3} = Quantile[mm, {0.25, 0.5, .75}];
   	 	1 + (# - q2)/(10 (q3 - q1))
   	 ) & /@ measure;
   	 
   	 (*make low value bad*)
   	 If[type <= 3, 2 - measure, measure]
]


(* ::Subsection::Closed:: *)
(*MakeECVBloodMask*)


Options[MakeECVBloodMask] = {BloodMaskRange -> {1400, {0, 700}}, OutputCheckImage -> True}

SyntaxInformation[MakeECVBloodMask] = {"ArgumentsPattern" -> {_, _, OptionsPattern[]}}

MakeECVBloodMask[pre_, post_, OptionsPattern[]] := Block[{
	mask1, mask2, bloodMask, meas, cent, preM, postM, slice, ims
	},
	
	{preM, postM} = OptionValue[BloodMaskRange];
	
	mask1 = Mask[pre, preM];
	mask2 = Mask[post, postM];
	
	bloodMask = Image3D[ImageData[
		SelectComponents[Erosion[Image[#], 1], "Count", -3]] & /@ (mask1 mask2)];
	meas = ComponentMeasurements[bloodMask, "IntensityCentroid"];
	
	cent = First@Nearest[meas[[All, 2]], Reverse@Dimensions[mask1]/2.];
	bloodMask = Erosion[#, 1] & /@ ImageData[SelectComponents[bloodMask, #IntensityCentroid == cent &]];
	
	If[OptionValue[OutputCheckImage],
		slice = Ceiling[Length[pre]/2];
		ims = (Image[((pre[[slice]]/Max[pre[[slice]]]) + bloodMask[[slice]])/2]);
		{bloodMask, ims},
		bloodMask
	]
]


(* ::Subsection::Closed:: *)
(*MakeECVBloodMask*)


ECVCalc[mappre_, mappost_, hema_?RealQ] := Block[{z, x, y, mask},
	mask = MakeECVBloodMask[mappre, mappost];
	ECVCalc[mappre, mappost, mask, hema]
]

ECVCalc[mappre_, mappost_, bloodMask_, hema_] := Block[{deltaR1, deltaR1b},
	deltaR1 = Clip[DevideNoZero[1, mappost] - DevideNoZero[1, mappre], {0, Infinity}];
	deltaR1b = Median@Flatten[GetMaskData[deltaR1, bloodMask]];
	Clip[100 (deltaR1/deltaR1b) (1 - hema), {0, 100}]
]  


(* ::Subsection::Closed:: *)
(*CreateHeart*)


SyntaxInformation[CreateHeart] = {"ArgumentsPattern" -> {_.}};

CreateHeart[] := CreateHeart[0.]

CreateHeart[setin_] := Block[{
	set, col, contin, contout, shape, seto, shapeplot, topline, shapeout, con, out, shapeoutC, shout, shin
	},
	
	set = out = If[setin === 0. || ! ListQ[setin], {{73, 2.85, 2.8, 0.018, 0}, {67, 3.42, 5.76, 0.078}, 110}, setin];
	col = Gray;
	
	NotebookClose[cardiacWindow];
	cardiacWindow = DialogInput[{
		CancelButton["Generate", DialogReturn[out = seto]],
		Manipulate[
			contin = ContourPlot[With[
				{zi = 0.06 (zp - higi), xi = 0.06 (xp - 59), yi = 0},
				((xi - shifti)^2/widthi*(1 - cupi zi) + (yi)^2/widthi*(1 - cupi zi) + zi^2/lengthi^2)
			], {xp, 0, 120}, {zp, 0, 120}, Contours -> {1}, ContourStyle -> {Thick, Red}, ContourShading -> None];
			
			contout = ContourPlot[With[
				{zo = 0.06 (zp - higo), xo = 0.06 (xp - 59), yo = 0},
				(xo^2/widtho*(1 - cupo zo) + yo^2/widtho*(1 - cupo zo) + zo^2/lengtho^2)
			], {xp, 0, 120}, {zp, 0, 120}, Contours -> {1}, ContourStyle -> {Thick, Blue}, ContourShading -> None];
			
			shape = Table[With[{
				zi = 0.06 (zp - higi), xi = 0.06 (xp - 59.5), yi = 0,
				zo = 0.06 (zp - higo), xo = 0.06 (xp - 59.5), yo = 0},
				shout = If[((xo^2/widtho*(1 - cupo zo) + yo^2/widtho*(1 - cupo zo) + zo^2/lengtho^2) > 1), 0, 1];
				shin = If[(((xi - shifti)^2/widthi*(1 - cupi zi) + yi^2/widthi*(1 - cupi zi) + zi^2/lengthi^2) > 1), 0, 1];
				shout - shin
			], {zp, 120, 1, -1}, {xp, 1, 120}];
			
			seto = {{higi, lengthi, widthi, cupi, shifti}, {higo, lengtho, widtho, cupo}, top};
			shapeplot = ArrayPlot[shape];
			topline = Graphics[{
				{Green, Thick, Line[{{0, top}, {120, top}}]},
				{White, Polygon[{{0, top}, {120, top}, {120, Length[shape] + 1}, {0, Length[shape] + 1}}]}
			}];
			
			Show[shapeplot, topline, contin, contout]
			
			, Delimiter
			, {{higi, set[[1, 1]], "inner hight"}, 60, 90}
			, {{lengthi, set[[1, 2]], "inner length"}, 2, 4}
			, {{widthi, set[[1, 3]], "inner width"}, 1, 10}
			, {{cupi, set[[1, 4]], "inner cup"}, 0, 0.25}
			, {{shifti, set[[1, 5]], "inner shift"}, -1, 1}
			, Delimiter
			, {{higo, set[[2, 1]], "outer hight"}, 60, 90}
			, {{lengtho, set[[2, 2]], "outer length"}, 2, 4}
			, {{widtho, set[[2, 3]], "outer width"}, 1, 10}
			, {{cupo, set[[2, 4]], "outer cup"}, 0, 0.25}
			, Delimiter
			, {{top, set[[3]],"top loation"}, 90, 120, 1}
			, Button["set 1", {{higi, lengthi, widthi, cupi}, {higo, lengtho, widtho, cupo}, top} = {{73, 2.85, 2.8, 0.018}, {67, 3.42, 5.76, 0.078}, 110}]
			, Button["set 2", {{higi, lengthi, widthi, cupi}, {higo, lengtho, widtho, cupo}, top} = {{69, 3.1, 2.8, 0.16}, {67.5, 3.6, 7.3, 0.12}, 105}],
			
			SynchronousUpdating -> True, Method -> "Queued"
		]
	}, WindowSize -> All, WindowTitle -> "Plot data window", WindowFloating -> True, Modal -> True];
	
	shapeoutC = Compile[{{seti, _Real, 1}, {seto, _Real, 1}}, 
		Table[With[{
			zi = 0.06 (zp - seti[[1]]),
			xi = 0.06 (xp - 59.5),
			yi = 0.06 (yp - 59.5),
			zo = 0.06 (zp - seto[[1]]),
			xo = 0.06 (xp - 59.5),
			yo = 0.06 (yp - 59.5)},
			If[((xo^2/seto[[3]]*(1 - seto[[4]] zo) + yo^2/seto[[3]]*(1 - seto[[4]] zo) + zo^2/seto[[2]]^2) > 1), 0, 1] - If[(((xi - seti[[5]])^2/seti[[3]]*(1 - seti[[4]] zi) + yi^2/seti[[3]]*(1 - seti[[4]] zi) + zi^2/seti[[2]]^2) > 1), 0, 1]
		], {zp, 1, 120, 1}, {xp, 1, 120, 1}, {yp, 1, 120, 1}]
	];
	
	shapeout = shapeoutC[out[[1]], out[[2]]];
	con = ConstantArray[0, Dimensions[shapeout]];
	shapeout[[out[[3]] ;;]] = con[[out[[3]] ;;]];
	Return[{ArrayPad[shapeout, 10], {0.7, 0.7, 0.7}, seto}];
]


(* ::Section:: *)
(*End Package*)


End[](* End Private Context *)

EndPackage[]
