(* ::Package:: *)

(* ::Title:: *)
(*QMRITools PlottingTools*)


(* ::Subtitle:: *)
(*Written by: Martijn Froeling, PhD*)
(*m.froeling@gmail.com*)


(* ::Section:: *)
(*Begin Package*)


BeginPackage["QMRITools`PlottingTools`", Join[{"Developer`"}, Complement[QMRITools`$Contexts, {"QMRITools`PlottingTools`"}]]];


(* ::Section:: *)
(*Usage Notes*)


(* ::Subsection::Closed:: *)
(*Functions*)


PlotData::usage =
"PlotData[data] plots the data.
PlotData[data, vox] plots the data and for 3D and 4D data assumes the voxelsize vox (z,x,y).
PlotData[data1, data2] plots data1 and data2.
PlotData[data1, data2, vox] plots data1 and data2 and for 3D and 4D data assumes the voxelsize vox (z,x,y)."

PlotData3D::usage = 
"PlotData3D[data,vox] is a 3D dataviewer, data is the 3D dataset and voxsize the size of the voxels in mm (z,x,y)."

PlotDefGrid::usage =
"PlotDefGrid[data, phasemap, shiftpar] plots the dataset on the background with on top the non deformed and the deformed grid, or arrows or lines."


GetSlicePositions::usage =
"GetSlicePositions[data] finds the position of slices with the maximal signal in voxel index.
GetSlicePositions[data, vox] find the position of slices with the maximal signal in mm."

GetSliceData::usage =  
"GetSliceData[data, offsets] gets the slices from the data defined by offsets which are obtained by GetSlicePosisions.
GetSliceData[data, offsets, vox] gets the slices from the data defined by offsets which are obtained by GetSlicePosisions in mm.
The offsets can also be provided manually which is {{AX,..},{COR,..},{SAG,..}}."

MakeSliceImages::usage =  
"MakeSliceImages[imgData] generates images from the imgData which is obtained form GetSliceData.
MakeSliceImages[imgData, vox] generates images from the imgData which is obtained form GetSliceData, vox is used for the correct aspect ratio of the images.
MakeSliceImages[imgData, {labData, labels}] generates images from the imgData which is obtained form GetSliceData with an overlay of the segmentations in labData, which can also be obtained using GetSliceData on the segmentations.
labels should be the label numbers used in the original segmentation (to allow correct scaling between slices).
MakeSliceImages[imgData, {labData, labels},vox] generates images from the imgData which is obtained form GetSliceData with an overlay of the segmentations in labData, which can also be obtained using GetSliceData on the segmentations, vox is used for the correct aspect ratio of the images."


PlotContour::usage = 
"PlotContour[data, vox] creates a contour of the data.
PlotContour[data, vox, scale] creates a contour of the data with the surface colored acording to scale.
PlotContour[data, vox, scale, range] creates a contour of the data with the surface colored acording to scale with a fixed plotrange."

PlotCorrection::usage = 
"PlotCorrection[w] plots deformation vectors w {w1,w2..} generated by Registration2D and Registration3D for multiple datasets or registration steps."

ListSpherePlot::usage =
"ListSpherePlot[points] plots 3D points as spheres"

GradientPlot::usage = 
"GradientPlot[bvec, bval] plots the given bvec with position of the gradients scaled according to the bval."

PlotDuty::usage = 
"PlotDuty[{grad, bval, ord}, mode] plot the gradient dutycycle"

PlotMoments::usage = 
"PlotMoments[{G(t),..}, te, t] plots the moments generated by CalculateMoments"

PlotIVIM::usage = 
"PlotIVIM[vals, data, bvals] plots the results of the IVIM fits from IVIMCalc or BayesianIVIMFit2 or Baye."

PlotSequence::usage = 
"PlotSequence[seq,var] where seq is the output from GradSeq."

(*Ploti::usage = "testing"*) 



(* ::Subsection::Closed:: *)
(*Options*)


MakeCheckPlot::usage = 
"MakeCheckPlot is an option for GetSlicePositions and if set true gives a plot of the slices locations."

DropSlices::usage = 
"DropSlices is an option for GetSlicePositions and specifies how many slices from the beginning and and should be ignored."

PeakNumber::usage = 
"PeakNumber is an option of GetSlicePostitions and specifies how many slices per direction need to be found."

ImageLegend::usage = 
"ImageLegend is an option for MakeSliceImages, if set true a barlegend is added to the image."


PlotSpace::usage = 
"PlotSpace is an option for GradientPlot can be \"bspace\" or \"qspace\"."

PlotColor::usage = 
"PlotColor is an option for GradientPlot can be any color or gradient color name."

NormalizeIVIM::usage = 
"NormalizeIVIM is an option for IVIMplot. If True the signal at b=0 is 1."

SphereSize::usage = 
"SphereSize is an option for GradientPlot and ListSpherePlor. Sets the size of the spheres thar represent the gradients."

SphereColor::usage = 
"SphereColor ListSpherePlor. Default value is Automatic, If a color is given this color will be used for all spheres."

PositiveZ::usage = 
"PositiveZ is an options for GradientPlot. If True all Gradients are displayed with a positive z direction."


(* ::Subsection::Closed:: *)
(*Error Messages*)


PlotData::data = "Error: Data must be a 2D, 3D or 4D numeric array."

PlotData::size = "Datasets must have the same number of slices. dataset1: `1` slices, dataset2: `2` slices. (Image dimensions may vary)."

PlotData::set = 
"Error: Not two valied datasest, posibilities:
- 2D and 2D
- 3D and 3D
- 4D and 4D
- 2D and 4D
- 2D and 4D
- 3D and 4D"

PlotData3D::data = "Data should be a 3D or 4D dataset."

PlotDefGrid::dir = "direction must be \"COL\" or \"ROW\", unknown direction: `1`."


(* ::Section:: *)
(*Functions*)


Begin["`Private`"]


(* ::Subsection:: *)
(*General Plot Functions and definitions*)


(* ::Subsubsection::Closed:: *)
(*Definitions*)


(*plot menu options*)
sizes={200,300,400,500,750,1000,1500,2000,2500,3000};
psizes={100,200,300,400,500,600,700,800,900,1000};
files={".pdf",".jpg",".gif",".tif",".png"};
colfuncs={1->"Normal",2->"Reverse",3->"Symetric",4->"Reverse Symetric"};
labStyle=Directive[Bold,FontFamily->"Helvetica",14,Black];


(*3D color rules and settings*)
colors3D = {Automatic -> "Automatic", "XRay", "HighRange", "LowRange","WhiteBlackOpacity", 
	"SunsetColorsOpacity", "RainbowOpacity"};
views = Thread[2*{{0.65, -1.2, 1}, {1, 0, 0}, {-1, 0, 0}, {0, 1, 0}, {0, -1, 0}, {0, 0, 1}, {0, 0, -1}} -> {"Start", "Right", "Left", "Front", "Back", "Top", "Bottom"}];

(*default gradient color funtions*)
gradsets = ColorData["Gradients"];
colorNames = {
	"GrayTones", "Rainbow", "ThermometerColors", "SunsetColors", 
	"TemperatureMap", "LightTemperatureMap", "GrayYellowTones", "BlueGreenYellow", 
	"AvocadoColors", "SouthwestColors"};

(*custom color functions and generate image of custom color*)
CustCol[colf_] := Graphics[Raster[{Range[100]/100.}, {{0, 0}, {1, 1}}, ColorFunction -> colf], 
AspectRatio -> 1/8, ContentSelectable -> False, ImageSize -> 100, PlotRange -> {{0, 1}, {0, 1}}]

custColors = {
	"RedToWhite" -> (Blend[{RGBColor[1, 1, 1], RGBColor[.7, 0, 0]}, 1 - #]&),
	"BlackToWhite" -> (Blend[{RGBColor[1, 1, 1], RGBColor[0, 0, 0]}, 1 - #]&),
	"Flow" -> (Blend[{White, Blend[{Blue, Cyan}], Blue, Black, Red, Orange, White}, #]&),
	"Fire" -> (Blend[{Black, Blue, Purple, Red, Orange, Yellow, White}, #] &),
	"NIH" -> (Blend[{Black, Purple, Blue, Green, Yellow, Orange, Red, Darker@Darker@Red}, #] &),
	"Cardiac" -> (Blend[{Darker@Green, Cyan, Blue, Purple, Red, Yellow, Darker@Green}, #] &),
	"GEcol" -> (Blend[{Black, RGBColor[0, .22, .22], RGBColor[0, .45, .45], RGBColor[.4, .0, .9], RGBColor[.75, .25, .5], Orange, RGBColor[1, .7, .35],  White}, #] &)
	};

(*generate color list*)
colors = If[MemberQ[gradsets, #], 
		(# -> Show[ColorData[#, "Image"], ImageSize -> 100]), 
		(# ->  CustCol[#/. custColors])
	] & /@ Join[colorNames,custColors[[All,1]]];


(* ::Subsubsection::Closed:: *)
(*ToByte*)


ToByte = Compile[{{data, _Real, 0}, {range, _Real, 1}},(data - range[[1]])/(range[[2]] - range[[1]]), RuntimeAttributes -> {Listable}, RuntimeOptions -> "Speed"];


(* ::Subsubsection::Closed:: *)
(*Clip and lookup*)


ColorData2[func_] := If[MemberQ[gradsets, func], ColorData[func], (func /. custColors)]
ColSel[func_, cfunc_] := With[{fun = {# &, 1 - # &, Abs[(2 # - 1)] &, Abs[Abs[(2*#) - 1] - 1] &}[[func]]}, ColorData2[cfunc][fun[#]]&]

ColorLookup[___] = Darker[Red];
ColorLookup = With[{ran = Range[0, 1., 1./255.]},
	Table[
		ColorLookup[j,i] = (ColSel[j, i] /@ ran) /. (RGBColor[x_, y_, z_] -> RGBColor[x, y, z, 1])
		, {j, 1, 4}, {i, colors[[All, 1]]}];
   ColorLookup];
(*With[{ran = Range[0, 1., 1./255.]},Table[ColorLookup[j,i] = (ColSel[j, i] /@ ran) /. (RGBColor[x_, y_, z_] -> RGBColor[x, y, z, 1]), {j, 1, 4}, {i, colors[[All, 1]]}]];*)

ColorRound = Compile[{{x, _Real, 0}}, If[0 <= x <= 1, Round[255 x] + 2, If[x < 0, 1, 258]], RuntimeOptions -> "Speed"];
LookUpTable[{lstyle_, color_}, {minclip_, maxclip_}] := Module[{collist, fun}, 
	With[{colfunc = ColSel[lstyle, color]},
   collist = {minclip}~Join~(colfunc /@ Range[0, 1, 1./255])~Join~{maxclip};
   fun[None] = Transparent;
   fun[x_] := collist[[ColorRound[x]]];
   fun
   ]]

ColorRound2 = Compile[{{x, _Real, 0}, {pmin, _Real, 0}, {pmax, _Real, 0}}, 
   If[pmin <= x <= pmax, Round[255 ((x - pmin)/(pmax - pmin))] + 2, 
    If[x < pmin, 1, 258]], RuntimeOptions -> "Speed"];
LookUpTable2[{lstyle_, color_}, {minclip_, maxclip_}, {pmin_, pmax_}] := Module[{collist, fun, minc, maxc},
  (*generate color lookup table with correct clipping colors for min and max, add opacity for Image function*)
  {minc, maxc} = {minclip, maxclip} /. (RGBColor[x_, y_, z_] -> RGBColor[x, y, z, 1]);
  collist = ({minc}~Join~(ColorLookup[lstyle, color])~Join~{maxc});
  (*define the color function fun*)
  fun[None] = Transparent;
  fun[x_] := collist[[ColorRound2[x, pmin, pmax]]];
  fun
  ]


(* ::Subsubsection::Closed:: *)
(*ManPannel*)


ManPannel[name_,cont_,depl_:True]:=
Module[{controls = DeleteCases[cont, Null]}, 
 OpenerView[{Style[name, Bold, Medium], 
   Grid[If[ArrayDepth[controls] == 1, {controls}, controls],Alignment -> {{Right, Left}, Center}, ItemSize -> {{13, 30}}]}, 
  depl
  ]
]


(* ::Subsubsection::Closed:: *)
(*Lengend plot*)


Legendi[plot_, color_, min_, max_, ps_] := Legended[plot,
	Placed[
   	BarLegend[{ColSel[color[[1]], color[[2]]][(# - min)/(max - min)]&, {min, max}}, 
    LabelStyle -> labStyle, LegendMarkerSize -> .92 ps, LegendLayout -> "Column"]
    ,{After, Bottom}]
];


(* ::Subsubsection::Closed:: *)
(*Lengend plot*)


Save
Labeli[lab_,ps_,plot_]:=If[StringQ[lab],
	Column[{
		Row[{Style[lab, labStyle, TextAlignment->Center, FontSize -> Round[ps/20]]},ImageSize->ps,Alignment->Center],
		plot
	},
	Alignment->Center]
	,
	plot
	];


(* ::Subsubsection::Closed:: *)
(*LabelFunc*)


LabelFunc[label_,{x_:Null,y_:Null}]:=Block[{labout},
labout=If[x===Null&&y===Null,
	If[!StringQ[label],"",label],
	If[y===Null,
		If[label==" "||label==""||!StringQ[label],If[label==" "," ",""],label<>" - "]<>"Slice "<>ToString[x],
		If[label==" "||label==""||!StringQ[label],If[label==" "," ",""],label<>" - "]<>"Slice "<>ToString[x]<>"-"<>ToString[y]
		]
	];
	If[labout==="",None,labout]
	]


(* ::Subsubsection::Closed:: *)
(*LabelJoin*)


LabelJoin[label_]:=StringJoin[Riffle[DeleteCases[label[[{3, 1, 2}]], None], "\n"]] /. "" -> None


(* ::Subsubsection::Closed:: *)
(*PlotSize*)


PlotSize[data_,ps_,aspect_]:=Block[{dimx,dimy,size,ratio,dsize},
	{dimy, dimx} = Dimensions[data];
	dsize = {dimx, dimy}*aspect;
	size = (dsize/Max[dsize]) ps;
	ratio = 1/Divide @@ dsize;
	{dimx,dimy,size,ratio}
]


(* ::Subsubsection::Closed:: *)
(*PlotRangeVals*)


PlotRangeVals[scale_, data_, {min_, max_}] := Block[{mindat, maxdat},
	{mindat, maxdat} = If[scale,
		(*Autoscale*)N[MinMax[data]],
		(*Manual Scale*){min, max}
	];
	(*only use valid scale which is max>min*)
    If[mindat >= maxdat, maxdat = mindat + 0.001];
   	{mindat, maxdat}
   ];


(* ::Subsubsection::Closed:: *)
(*PlotTicks*)


PlotTicks[dimx_, dimy_] := Block[{tkx, tky},
   tkx = Table[tx, {tx, 0, dimx, If[dimx > 250, 50, 25]}];
   tky = Table[{ty, dimy - ty}, {ty, dimy, 0, If[dimy > 250, -50, -25]}];
   {{tky, tky}, {tkx, tkx}}
   ];


(* ::Subsubsection::Closed:: *)
(*JoinResc*)


JoinResc[data1_,data2_]:=
Module[{dim1,dim2},
	dim1=Dimensions[data1];
	dim2=Dimensions[data2];
	If[dim1==dim2,
		{data1,data2},
		If[Max[dim1]<Max[dim2],
			{RescaleImg[data1,dim2],data2},
			{data1,RescaleImg[data2,dim1]}
			]
		]
	]

RescaleImg[data_, dim_] := Block[{type},
 type = If[ArrayQ[data, _, IntegerQ], "Bit16","Real32"];
 ImageData[ImageResize[Image[data, type], Reverse[dim], Resampling -> "Gaussian"], type]
]


(* ::Subsubsection::Closed:: *)
(*DataString*)


DataString[dim_]:=
ReleaseHold[
	{
		Hold["one image with a dimension of "<>ToString[dim[[1]]]<>"x"<>ToString[dim[[2]]]<>" voxels"],
		Hold[ToString[dim[[1]]]<>" slices with a dimensions of "<>ToString[dim[[2]]]<>"x"<>ToString[dim[[3]]]<>" voxels"],
		Hold[ToString[dim[[1]]]<>"x"<>ToString[dim[[2]]]<>" slices with a dimensions of "<>ToString[dim[[3]]]<>"x"<>ToString[dim[[4]]]<>" voxels"]
	}[[Length[dim]-1]]
	]


(* ::Subsection:: *)
(*Export Functions*)


(* ::Subsubsection::Closed:: *)
(*MultiFileSave*)


MultiFileSave[plot_,label_,range_,type_,size_]:=
Module[{input,lab},
	input=SystemDialogInput["Directory", Directory[]];
	If[input===$Canceled,Return[Print["Export multiple files was canceled!"]]];
	
	Switch[Length[range],
		2,(* one 3D datasest *)
		Table[
			lab=ReleaseHold[label]/. None->"";
			pl=ReleaseHold[plot];
			SaveImage[pl,input<>lab<>type,FileType->type,ImageSize -> size];
			(*Export[input<>lab<>type, Rasterize[ReleaseHold[plot], RasterSize->2*size],RasterSize->2*size, ImageResolution->300];*)
			,{xs,range[[1]],range[[2]]}];,
		4,(* one 4D datasest *)
		Table[
			lab=ReleaseHold[label]/. None->"";
			pl=ReleaseHold[plot];
			SaveImage[pl,input<>lab<>type,FileType->type,ImageSize -> size];
			(*Export[input<>lab<>type, Rasterize[ReleaseHold[plot], RasterSize->2*size],RasterSize->2*size, ImageResolution->300];*)
			,{xs,range[[1]],range[[2]]},{ys,range[[3]],range[[4]]}];
		];
		
	Print["Multiple fiels were saved to: "<>input<>" as "<>type<>" files."];
	]


(* ::Subsubsection::Closed:: *)
(*MovieSave*)


MovieSave[plot_,dur_,loop_,size_,range_]:=
Module[{input,movie},
	input=SystemDialogInput["FileSave", Directory[] <> $PathnameSeparator<>"*.gif"];
	If[input===$Canceled,Return[Print["Export movie was canceled!"]]];
	
	movie=Flatten[Switch[Length[range],
		2,(* one 3D datasest *)
		Table[Rasterize[ReleaseHold[plot],RasterSize->size],{xs,range[[1]],range[[2]]}],
		4,(* one 4D datasest *)
		Table[Rasterize[ReleaseHold[plot],RasterSize->size],{xs,range[[1]],range[[2]]},{ys,range[[3]],range[[4]]}]
		]];
	Export[input,movie,"DisplayDurations"->dur,"AnimationRepetitions"->loop,RasterSize->size, ImageResolution->150];
	Print["Movie was saved to: "<>input];
	]


(* ::Subsection:: *)
(*Plot Functions*)


(* ::Subsubsection::Closed:: *)
(*Ploti*)


Ploti[data_, minmax_, label_, ps_, color_, colscal_, legend_, frame_, ccolor_, aspect_] := Block[
	{plot, pdat, lab, ratio, tx, ty, dimx, dimy, size, dsize, colf, 
		pmin, pmax, lmin, lmax, mindat, maxdat, tks},
	
	{dimx,dimy,size,ratio}=PlotSize[data,ps,aspect];
	tks = PlotTicks[dimx, dimy];
	{pmin, pmax} = PlotRangeVals[colscal, data, minmax];
	
	(*pdat = Reverse@ToByte[data, {pmin, pmax}];*)
	colf = LookUpTable2[color, ccolor,{pmin,pmax}];
	
	(*not using array plot makes plot 2x as fast*)
	plot=Graphics[Raster[Reverse@data, ColorFunction -> colf], Frame -> frame, FrameTicks -> tks, ImageSize -> size, AspectRatio -> ratio];
	
	(*add label*)
	plot = Labeli[label,ps,plot];
	(*add legend*)
	If[legend, Legendi[plot, color, pmin, pmax, size[[2]]], plot]
  ]


(* ::Subsubsection::Closed:: *)
(*Plot2i*)


Plot2i[data_,minmax_,label_,ps_,color_,autosc_,legend_,frame_,join_,ccolor_,aspect_,leg_]:=Block[{plot},
	Switch[join[[1]],
		1,(*Normal side by side*)
		plot={
			Ploti[data[[1]],minmax[[1]],label[[1]],ps,color[[1]],autosc[[1]],legend,frame,ccolor[[1]],aspect],
			Ploti[data[[2]],minmax[[2]],label[[2]],ps,color[[2]],autosc[[2]],legend,frame,ccolor[[2]],aspect]
			};
		Labeli[label[[3]],ps,Grid[{plot}]],
		2(*CheckboardPlot*),
		CheckPlot[data,minmax,label,ps,color,autosc,frame,join[[2]],join[[3]],ccolor,aspect],
		3(*Opacity overlay plot*),
		OpacityPlot[data,minmax,label,ps,color,autosc,legend,frame,join[[3]],join[[4]],ccolor,aspect, leg],
		4(*Difference Plot*),
		DifferencePlot[data,minmax,label,ps,color,legend,frame,join[[3]],join[[5]],ccolor,aspect]
		]
]


(* ::Subsubsection::Closed:: *)
(*CheckPlot*)


CheckPlot[data_,minmax_,label_,ps_,color_,autosc_,frame_,size_,flip_,ccolor_,aspect_]:=
Module[{plot1,plot2,colf1,colf2,pdat1,pdat2,ratio,a,b,tks,
	dimy,dimx,pmin1,pmax1,pmin2,pmax2,lab,psize},
	
	{a,b}=If[flip,{2,1},{1,2}];
	{pdat1,pdat2}=JoinResc[data[[a]],data[[b]]];
	{dimx,dimy,psize,ratio}=PlotSize[pdat1,ps,aspect];
			
	{pmin1, pmax1} = PlotRangeVals[autosc[[a]], pdat1, minmax[[a]]];
	{pmin2, pmax2} = PlotRangeVals[autosc[[b]], pdat2, minmax[[b]]];
	
	colf1 = LookUpTable2[color[[a]], ccolor[[a]],{pmin1,pmax1}];
	colf2 = LookUpTable2[color[[b]], ccolor[[b]],{pmin2,pmax2}];

	tks = PlotTicks[dimx, dimy];

	(*make plot*)
	plot1 = Graphics[
		Raster[Reverse[pdat1],ColorFunction -> (colf1)],
 		Frame->frame, FrameTicks->tks, ImageSize -> psize,AspectRatio -> ratio];
 	plot2 = Graphics[
 		Raster[Reverse[CheckBoard[pdat2,size]],ColorFunction -> (colf2)]];
	
	(*add label*)
	lab = LabelJoin[label];
	Labeli[lab,ps,Show[{plot1,plot2}]]
	]


(* ::Subsubsection::Closed:: *)
(*CheckBoard*)


CheckBoard[img_,check_]:=
Module[{dim},
	dim=Dimensions[img];
	Table[
		If[(
			OddQ[Ceiling[(i-0.5 dim[[1]])/check]]&&OddQ[Ceiling[(j-0.5 dim[[2]])/check]]
			) || (
			EvenQ[Ceiling[(i-0.5 dim[[1]])/check]]&&EvenQ[Ceiling[(j-0.5 dim[[2]])/check]]
			),
			img[[i,j]],None
			],{i,1,dim[[1]],1},{j,1,dim[[2]]}
		]
	]


(* ::Subsubsection::Closed:: *)
(*DifferencePlot*)


DifferencePlot[data_,minmax_,label_,ps_,color_,legend_,frame_,flip_,range_,ccolor_,aspect_]:=
Module[{pdat,a,b,pl,min1,max1,min2,max2},
	
	{a,b}=If[flip,{2,1},{1,2}];
	{min1,max1}=minmax[[a,1;;2]];
	{min2,max2}=minmax[[b,1;;2]];
	
	pdat=(Subtract@@(JoinResc[data[[a]],data[[b]]]));
	
	(*make plot*)
	pl=Ploti[pdat,{-range,range},LabelJoin[label],ps,color[[a]],False,legend,frame,ccolor[[a]],aspect]
	]


(* ::Subsubsection::Closed:: *)
(*OpacityPlot*)


OpacityPlot[data_,minmax_,label_,ps_,col_,autosc_,legend_,frame_,flip_,op_,ccolor_,aspect_,leg_]:=
Module[{p1,p2,pdat1,pdat2,a,b,c,lab, plot,dimx,dimy,size,ratio},
	
	{a,b}=If[flip,{2,1},{1,2}];
	{pdat1,pdat2}=JoinResc[data[[a]],data[[b]]];
	{dimx,dimy,size,ratio}=PlotSize[pdat1,ps,aspect];

	(*make plot*)	
	p1=Ploti[pdat1,minmax[[a]],None,ps,col[[a]],autosc[[a]],False,frame,ccolor[[a]],aspect];
	p2=Ploti[pdat2,minmax[[b]],None,ps,col[[b]],autosc[[b]],False,frame,ccolor[[b]],aspect];
	plot = Show[{p1,Graphics[{Opacity[op],p2[[1]]}]}];
	
	(*add label*)
	lab = LabelJoin[label];
	plot = Labeli[lab,ps,plot];
	
	(*add legend*)
	c = If[leg == 1, b, a];
	If[legend, Legendi[plot, col[[c]], minmax[[c,1]],minmax[[c,2]], size[[2]]], plot]
	]


(* ::Subsection:: *)
(*check and rewrite*)


(* ::Subsubsection::Closed:: *)
(*PlotDefi*)


PlotDefi[data_,shift_,{dim_,dir_},{min_,max_},lab_,ps_,color_,clip_,{gs_,gf_,ncol_,dcol_,lcol_,acol_},{def_,norm_,defl_,arr_,pl_}]:=
Module[{normGrid,deffGrid,pos,dcor,ncor,points,lines,arrows,head,plot},
	
	normGrid=Table[{j-0.5,-(i-dim[[2]])+0.5},{i,1,dim[[2]],gs},{j,1,dim[[3]],gs}];
	
	deffGrid=Table[
		If[dir=="ROW",{j-shift[[i,j]]-0.5,-(i-dim[[2]])+0.25},
		If[dir=="COL",{j-0.5,-(i-shift[[i,j]]-dim[[2]])+0.25}]]
		,{i,1,dim[[2]],gs},{j,1,dim[[3]],gs}];
	
	pos=Ceiling[DeleteCases[Flatten[Table[If[shift[[i,j]]==0.,{i,j},Null],{i,1,dim[[2]],gs},{j,1,dim[[3]],gs}],1],Null]/gs];
	
	dcor=Flatten[Delete[deffGrid,pos],1];
	ncor=Flatten[Delete[normGrid,pos],1];
	
	points=
	If[def&&norm,Graphics[{{PointSize[gf[[2]]],ncol,Point[ncor]},{PointSize[gf[[2]]],dcol,Point[dcor]}}],
		If[def,Graphics[{PointSize[gf[[2]]],dcol,Point[dcor]}],
			If[norm,Graphics[{PointSize[gf[[2]]],ncol,Point[ncor]}],
				Graphics[]
				]
			]
		];
	
	lines=If[defl,
		If[dir=="COL",Graphics[{Thickness[gf[[1]]],lcol,Map[BSplineCurve[#]&,deffGrid]}],
			If[dir=="ROW",Graphics[{Thickness[gf[[1]]],lcol,Map[BSplineCurve[#]&,Transpose[deffGrid]]}]]
			],
		Graphics[]
		];
	
	arrows=If[arr,
		head=Graphics[Line[{{-1/2,1/4},{0,0},{-1/2,-1/4}}]];
		Graphics[{Thickness[gf[[1]]],acol,Arrowheads[{{0.008,Automatic,head}}],Arrow[#]&/@ Transpose[{dcor,ncor}]}],
		Graphics[]
		];
	
	plot=If[pl,
		Ploti[data, {min, max}, None, ps, {1, color}, False, False, False, clip, {1, 1}],Graphics[]
		];
	
	Show[plot,lines,points,arrows,ImageSize->ps,PlotLabel->Style[lab,Bold,FontFamily->"Arial",FontSize->Round[ps/20]]]
	]


(* ::Subsubsection::Closed:: *)
(*MultiFileSaveDef*)


MultiFileSaveDef[data_,shift_,range_,type_,size_,settings_]:=
Module[{input,dim,dir,min,max,label,ps,color,gs,gf,ncol,dcol,lcol,acol,def,norm,defl,arr,pl,lab,exp,name},
	input=SystemDialogInput["Directory",Directory[]];
	If[input===$Canceled,Print["Export multiple files was canceled!"],	
		{dim,dir}=settings[[1]];
		{min,max}=settings[[2]];
		label=settings[[3]];
		ps=settings[[4]];
		color=settings[[5]];
		{gs,gf,ncol,dcol,lcol,acol}=settings[[6]];
		{def,norm,defl,arr,pl}=settings[[7]];
		
		Table[
			lab=If[!StringQ[label],"",label<>" - "]<>"Slice - "<>ToString[x];
			exp=PlotDefi[data[[x]],shift[[x]],{dim,dir},{min,max},lab,ps,color,{gs,gf,ncol,dcol,lcol,acol},{def,norm,defl,arr,pl}];
			name=input<>lab<>type;
			Export[name,exp,ImageSize->size];
			,{x,range[[1]],range[[2]]}
			];
		Print["Multiple fiels were saved to: "<>input<>" as "<>type<>" files."];
		]
	]


(* ::Subsubsection::Closed:: *)
(*MovieSaveDef*)


MovieSaveDef[data_,shift_,dur_,loop_,size_,range_,settings_]:=
Module[{movie,input,dim,dir,min,max,label,ps,color,gs,gf,ncol,dcol,lcol,acol,def,norm,defl,arr,pl,lab},
	input=SystemDialogInput["FileSave", Directory[] <> $PathnameSeparator <>"*.gif"];
	If[input===$Canceled,Print["Export multiple files was canceled!"],
		{dim,dir}=settings[[1]];
		{min,max}=settings[[2]];
		label=settings[[3]];
		ps=settings[[4]];
		color=settings[[5]];
		{gs,gf,ncol,dcol,lcol,acol}=settings[[6]];
		{def,norm,defl,arr,pl}=settings[[7]];
		
		movie=Flatten[Table[
			lab=If[!StringQ[label],"",label<>" - "]<>"Slice - "<>ToString[x];
			PlotDefi[data[[x]],shift[[x]],{dim,dir},{min,max},lab,ps,color,{gs,gf,ncol,dcol,lcol,acol},{def,norm,defl,arr,pl}]
			,{x,range[[1]],range[[2]]}
			]];
		
		Export[input,movie,"DisplayDurations"->dur,"AnimationRepetitions"->loop,ImageSize->size];
		Print["Movi was saved to: "<>input];
		]
	]


(* ::Subsection:: *)
(*Plot Data*)


(* ::Subsubsection::Closed:: *)
(*General*)


Options[PlotData]={PlotRange->"Auto",ColorFunction->"BlackToWhite"};

SyntaxInformation[PlotData] = {"ArgumentsPattern" -> {_, _., _., OptionsPattern[]}};


(* ::Subsubsection::Closed:: *)
(*PlotData 1 dataset*)


PlotData[dat_?ArrayQ,vox:{_?NumberQ, _?NumberQ, _?NumberQ}:{1,1,1},OptionsPattern[]]:= Module[
	{data,dim,n,control,str,exp,clip,reverse,start1,end1,start2,end2,dur,loop,tab1,tab2,depth,
	x,xp,yp,min,max,minclip,maxclip,label,ps,color,lstyle,legend,fileType,size,pannel,aspect,or,rangex,rangey,frame,
	mind,maxd,plab,plot,pdata,cfs,lab,pcol,ccol
	},
	
	NotebookClose[plotwindow];
	ClearTemporaryVariables[];

	(*Check if data is numeric array, if not exit*)
	data=ToPackedArray[dat//N];
	If[!ArrayQ[data,_,RealQ],Return[Message[PlotData::data]]];
	
	(*See what kind of data: 2D,3D or 4D (n=1,2,3). If not one of those exit*)
	depth=ArrayDepth[data];
	If[depth>4, Return[Message[PlotData::set]]];
	n=depth-1;
		
	(*Determine data dimensions en make string displaying data dimensions*)
	dim=Dimensions[data];
	str="Displaying "<>DataString[dim];
	
	(*Initialize slice ranges and data range*)
	rangex=dim[[1]];
	rangey=dim[[2]];

	(*Define the initial plot range*)
	{mind,maxd}=If[ListQ[OptionValue[PlotRange]] && Length[OptionValue[PlotRange]]==2, OptionValue[PlotRange], {Min[data],Max[data]}];
	If[mind===maxd,maxd=mind+0.01];
	
	pcol=If[StringQ[OptionValue[ColorFunction]],OptionValue[ColorFunction],"BlackToWhite"];
	
	(*Define the tabs of the control pannel*)
	(*T1: first tabs, plotting controls*)
	tab1=Column[{
		(*Slice selction controls, depends on data dimensions*)
		{"",
		ManPannel["Slice Selection",{
			{Dynamic["Slice (1-"<>ToString[rangex]<>")"],Control@{{x,Round[rangex/2],""},1,Dynamic[rangex],1, Appearance -> "Labeled"}},
			{"Orientation",Control@{{or,1,""},{1->"Transversal",2->"Sagital",3->"Coronal"}}},
			{"Reverse Slice Order",Control@{{reverse,False,""},{True,False}}}
			}],
		ManPannel["Slice Selection",{
			{Dynamic["Slice 1 (1-"<>ToString[rangex]<>")"],Control@{{x,Round[rangex/2],""},1,Dynamic[rangex],1, Appearance -> "Labeled"}},
			{"Slice 2 (1-"<>ToString[rangey]<>")",Control@{{yp,1,""},1,rangey,1, Appearance -> "Labeled"}},
			{"Orientation",Control@{{or,1,""},{1->"Transversal",2->"Sagital",3->"Coronal"}}},
			{"Reverse Slice Order",Control@{{reverse,False,""},{True,False}}}
			}]
			}[[n]]
		,(*Plot range controls*)
		ManPannel["Plot Range",{
			{"Auto Scaling", Control@{{cfs,False,""},{True -> "On", False -> "Off"}}},
			{"Min value",Control@{{min,mind,""},mind,max-(maxd-mind)/250,(maxd-mind)/250, Appearance -> "Labeled"}},
			{"Max value",Control@{{max,maxd,""},min+(maxd-min)/250,maxd,(maxd-mind)/250, Appearance -> "Labeled"}},
			{"Clipping",Control@{{clip,"Custom",""},{"Auto","Custom","Transparent"}}},
			{"Min Clipping",Control@{{minclip,Black,""},ColorSlider[#,ImageSize->{Automatic,15}]&}},
			{"Max Clipping",Control@{{maxclip,White,""},ColorSlider[#,ImageSize->{Automatic,15}]&}}			
			}]
		,(*Plot style controls*)
		ManPannel["Plot Style",{
			{"Plot Title",Control@{{label,"",""},InputField[#,String]&}},
			{"Plot Size",Control@{{ps,400,""},psizes,ControlType->PopupMenu}},
			{"Color function",Control@{{color,pcol,""},colors,ControlType->PopupMenu}},
			{"Color style",Control@{{lstyle,1,""},colfuncs}},
			{"Layout",Row@{
				"  Legend:",Control@{{legend,False,""},{True,False}},
				"  Frame:",Control@{{frame,False,""},{True,False}},
				"  Label:",Control@{{lab,True,""},{True,False}}}}
			}]
		}];
	
	(*T2: second tab, exporting controls*)
	tab2=Column[{
		(*Export parameters controls*)
		ManPannel["Export plot",{
			{"File Type",Control@{{fileType,".jpg",""},files}},
			{"Export Size",Control@{{size,400,""},sizes,ControlType->PopupMenu}},
			{"Export",Button["Save Plot", SaveImage[Dynamic[exp], FileType->fileType, ImageSize -> size],Method->"Queued",ImageSize->150]}
			}]
		,(*Multiple image export controls, depends on data dimensions 2D-off, 3D-on 2 sliders, 4D-on 4 sliders*)
		{"",
		ManPannel["Export multiple plots as files",{
			{"Start slice",Control@{{start1,1,""},1,Dynamic[end1],1, Appearance -> "Labeled"}},
			{"End slice",Control@{{end1,Length[data],""},Dynamic[start1],Dynamic[rangex],1, Appearance -> "Labeled"}},
			{"Export Files",
				Button["Save Plots",MultiFileSave[Hold[plot[xs,ys,xs]],Hold[plab[xs,ys,True]],{start1,end1},fileType,size],
				Method->"Queued",ImageSize->150]}
			}],
		ManPannel["Export multiple plots as files",{
			{"Start slice 1",Control@{{start1,1,""},1,Dynamic[end1],1, Appearance -> "Labeled"}},
			{"End slice 1",Control@{{end1,1,""},Dynamic[start1],Dynamic[rangex],1, Appearance -> "Labeled"}},
			{"Start slice 2",Control@{{start2,1,""},1,Dynamic[end2],1, Appearance -> "Labeled"}},
			{"End slice 2",Control@{{end2,Length[data[[1]]],""},Dynamic[start2],Length[data[[1]]],1, Appearance -> "Labeled"}},
			{"Export Files",
				Button["Save Plots",MultiFileSave[Hold[plot[xs,ys,xs]],Hold[plab[xs,ys,True]],{start1,end1,start2,end2},fileType,size],
				Method->"Queued",ImageSize->150]}
			}]
			}[[n]]
		,(*Animated gif export controls, depends on data dimensions 2D-off, 3D/4D-on*)
		{"",
		ManPannel["Export multiple plots as animated gif",{
			{"Display Duration (s)",Control@{{dur,.5,""},0.1,2,0.1, Appearance -> "Labeled"}},
			{"Animation Repetitions",Control@{{loop,Infinity,""},{Infinity,1,2,3,4,5},ControlType->PopupMenu}},
			{"Export Movie",
				Button["Save Movie",MovieSave[Hold[plot[xs,ys,xs]],dur,loop,size,{start1,end1,start2,end2}[[1;;2(n-1)]]],
				Method->"Queued",ImageSize->150]}
			}]
			}[[Unitize[n-1]+1]](*outputt 0 or 1 thus showing menu or not*)
		}];
		
	(*Build the control pannel, allows for easy addition of more tabs*)
	control={str,Delimiter,{{pannel,1,""},{1->"Plotting options",2->"Exporting options"}},Delimiter,PaneSelector[{1->tab1,2->tab2},pannel]};

	
	(*Deploy plot window*)
	pan=Manipulate[
		If[!ListQ[data],Return[];];
		
		(*updata slice range for 3D and 4D plots when switching between axial and sagital*)
		rangex={dim[[1]],dim[[n]],dim[[n+1]]}[[or]];
	
		(*reverse slices if needed and constrain ranges*)
		x=If[NumericQ[x],Clip[x,{1,rangex}],1];
		xp=If[reverse,(-x+rangex)+1,x];
		yp=If[NumericQ[yp],Clip[yp,{1,rangey}],1];
		
		(*determine the aspect ration based on the voxelsize and dimensions*)
		aspect=Reverse[Drop[vox,{or}]];

		(*based on the data dimensions or how the data is showed determine how the data selection looks*)
		pdata={
			data&,
			{data[[#1]]&,Reverse[data[[All,#1]]]&,Reverse[data[[All,All,#1]]]&}[[or]],
			{data[[#1,#2]]&,Reverse[data[[All,#2,#1]]]&,Reverse[data[[All,#2,All,#1]]]&}[[or]]
		}[[n]];
		
		(*Make plot label*)
		plab=If[#3,
			LabelFunc[label,{{},{#1},{#1,#2}}[[n]]],
			LabelFunc[label,{}]
			]&;
			
		ccol=Switch[clip,"Auto",ColorData2[color]/@{0,1},"Custom",{minclip,maxclip},"Transparent",{Transparent,Transparent}];
	
		(*create Plot, is on hold so it can be used for exporting multiple files and movie*)
		plot=Ploti[
			pdata[#1,#2],		(*the data*)
			{min,max},			(*the plot range*)
			plab[#3,#2,lab],	(*the plot label*)
			ps,					(*the plot size*)
			{lstyle,color},		(*style (1-4),colorfunction*)
			cfs,				(*color function scaling aut*)
			legend,				(*show plot legend*)
			frame,				(*show the frame*)
			ccol,				(*the plot clip color*)
			aspect				(*the aspect ratio*)
		]&;
			
		(*insert data in plot and show*)
		(*Make sure that the x an y slice selection indices cant exceed the data dimensions*)
		exp=plot[xp,yp,x]
		
		,##(*Insertion of control pannel*),
		(*Manipulate function options*)
		ControlPlacement->Right,
		Initialization:>{or=1,reverse=False,legend=False},
		Deployed->False, 
		SynchronousInitialization -> False
		]&@@control;
		
		NotebookClose[plotwindow];
		plotwindow=CreateWindow[DialogNotebook[{CancelButton["Close", Clear[data];DialogReturn[]], pan}, 
			WindowSize -> All, WindowTitle -> "Plot data window"]];
	];


(* ::Subsubsection::Closed:: *)
(*PlotData 2 datasets*)


PlotData[dat1_?ArrayQ,dat2_?ArrayQ,vox:{_?NumberQ, _?NumberQ, _?NumberQ}:{1,1,1},OptionsPattern[]]:=
Module[{data1=N[dat1],data2=N[dat2],label,label1,label2,str,n,rangex,rangey,tab1,tab2,ccol,
	x,xp,yp,min1,max1,min2,max2,mind1,maxd1,mind2,maxd2,reverse,or,plabs,plab,plot,aspect,cfs1,cfs2,
	minclip1,maxclip1,minclip2,maxclip2,clip1,clip2,ps,legend,color1,color2,lstyle1,lstyle2,control,
	pannel,pdata1,pdata2,flip,overlay,checksize,opac,diffr,fileType,size,leftright,lab,mpdim,leg,
	start1,end1,start2,end2,dur,loop,exp,dim1,dim2,prange,frame,adep1,adep2,maxabs,pcol,pcol1,pcol2},
	
	NotebookClose[plotwindow];
	ClearTemporaryVariables[];
	
	(*Check if data is numeric array, if not exit*)
	data1 = ToPackedArray[dat1//N];
	data2 = ToPackedArray[dat2//N];
	If[(! ArrayQ[data1, _, RealQ]) || (! ArrayQ[data2, _, RealQ]),Return[Message[PlotData::data]]];

	(*See what kind of data: 2D,3D or 4D (n=1,2,3). If not one of those exit*)
	(*Determine data dimensions en make string displaying data dimensions*)
	adep1=ArrayDepth[data1];
	adep2=ArrayDepth[data2];
	dim1=Dimensions[data1];
	dim2=Dimensions[data2];
	
	mpdim=Max[Join[Take[dim1,-2],Take[dim2,-2]]];

	If[!(2<=adep1<=4 || 2<=adep2<=4), Return[Message[PlotData::set]]];
	If[(!(adep1==2 || adep2==2)),
		If[((adep1==3 || adep2==3) && dim1[[1]]!=dim2[[1]]) || (adep1==adep2==4 && dim1[[{1,2}]]!=dim2[[{1,2}]]),
			Return[Message[PlotData::size,dim1,dim2]]
		]
	];
	str="Displaying 2 dataset:\nLeft: "<>DataString[dim1]<>"\nRight: "<>DataString[dim2];
	n=Max[{adep1,adep2}]-1;
	leftright=1;

	(*determine the slider range for slice slection*)
	rangex=If[ArrayQ[data1,2],Length[data2],Length[data1]];
	rangey=If[ArrayQ[data1,4],Length[data1[[1]]],Length[data2[[1]]]];

	(*Rescale data between 0 and 1*)
	prange=OptionValue[PlotRange];

	{mind1,maxd1,mind2,maxd2}=If[ListQ[OptionValue[PlotRange]] && (Dimensions[prange] == {2} || Dimensions[prange] == {2,2}),
		If[Dimensions[prange]=={2},Flatten[{prange,prange}],If[Dimensions[prange]=={2,2},Flatten[prange]]],
		{Min[data1],Max[data1],Min[data2],Max[data2]}
		];
	If[mind1===maxd1,maxd1=mind1+0.01];
	If[mind2===maxd2,maxd2=mind2+0.01];

	maxabs=Max[Abs[{mind1,maxd1,mind2,maxd2}]];
	
	pcol=OptionValue[ColorFunction];
	If[Length[OptionValue[ColorFunction]]==2 && StringQ[pcol[[1]]] && StringQ[pcol[[2]]],
	{pcol1,pcol2}=OptionValue[ColorFunction],
	pcol1=pcol2=If[StringQ[OptionValue[ColorFunction]],
		OptionValue[ColorFunction],"BlackToWhite"]
	];

	(*Define the different tabs of the control pannel*)
	(*first tabs, plotting controls*)
	tab1=Column[{
		{"",
		ManPannel["Slice Selection",{
			{"Slice",Control@{{x,Round[rangex/2],""},1,Dynamic[rangex],1, Appearance -> "Labeled"}},
			{"Reverse Slice Order", Control@{{reverse, False, ""}, {True, False}}},
			{##} & @@ If[dim1 == dim2, {"Orientation",Control@{{or, 1, ""}, {1->"Transversal",2->"Sagital",3->"Coronal"}}},or=1; Null]
			}],
		ManPannel["Slice Selection",{
			{"Slice 1",Control@{{x,Round[rangex/2],""},1,Dynamic[rangex],1, Appearance -> "Labeled"}},
			{"Slice 2",Control@{{yp,1,""},1,rangey,1, Appearance -> "Labeled"}},
			{"Reverse Slice Order", Control@{{reverse, False, ""}, {True, False}}},
			{##} & @@ If[(Take[dim1, -2] == Take[dim2, -2])&&(Length[dim1]>=3)&&(Length[dim2]>=3), {"Orientation",Control@{{or, 1, ""}, 
				{1->"Transversal",2->"Sagital",3->"Coronal"}}}, or=1;Null]
			}]
			}[[n]]
		,
		ManPannel["Plot Range",{
			{"Data set",Control@{{leftright,1,""},{1->"Left",2->"Right"}}},
			{Style[Dynamic[{"Left dataset","Right dataset"}[[leftright]]],Bold],""},
			{"Auto Scaling",PaneSelector[{
				1->Control@{{cfs1,False,""},{True -> "On", False -> "Off"}},
				2->Control@{{cfs2,False,""},{True -> "On", False -> "Off"}}},Dynamic[leftright]]},
			{"Min value",PaneSelector[{
				1->Control@{{min1,mind1,""},mind1,max1-(maxd1-mind1)/250,(maxd1-mind1)/250, Appearance -> "Labeled"},
				2->Control@{{min2,mind2,""},mind2,max2-(maxd2-mind1)/250,(maxd2-mind1)/250, Appearance -> "Labeled"}},Dynamic[leftright]]},
			{"Max value",PaneSelector[{
				1->Control@{{max1,maxd1,""},(maxd1-mind1)/250+ min1,maxd1,(maxd1-mind1)/250, Appearance -> "Labeled"},
				2->Control@{{max2,maxd2,""},(maxd2-mind2)/250+ min2,maxd2,(maxd2-mind2)/250, Appearance -> "Labeled"}},Dynamic[leftright]]},
			{"Clippint",PaneSelector[{
				1->Control@{{clip1,"Custom",""},{"Auto","Custom","Transparent"}},
				2->Control@{{clip2,"Custom",""},{"Auto","Custom","Transparent"}}},Dynamic[leftright]]},
			{"Min Clipping",PaneSelector[{
				1->Control@{{minclip1,Black,""},ColorSlider[#,ImageSize->{Automatic,15}]&},
				2->Control@{{minclip2,Black,""},ColorSlider[#,ImageSize->{Automatic,15}]&}},Dynamic[leftright]]},
			{"Max Clipping",PaneSelector[{
				1->Control@{{maxclip1,White,""},ColorSlider[#,ImageSize->{Automatic,15}]&},
				2->Control@{{maxclip2,White,""},ColorSlider[#,ImageSize->{Automatic,15}]&}},Dynamic[leftright]]}
			},False],
		ManPannel["Plot Style",{
			{"Plot Title",Control@{{label,"",""},InputField[#,String]&}},
			{"Plot Size",Control@{{ps,400,""},psizes,ControlType->PopupMenu}},
			{"Layout",Row@{
				"  Legend:",Control@{{legend,False,""},{True,False}},
				"  Frame:",Control@{{frame,False,""},{True,False}},
				"  Label:",Control@{{lab,True,""},{True,False}}}},
			{"Data set",Control@{{leftright,1,""},{1->"Left",2->"Right"}}},
			{Style[Dynamic[{"Left dataset","Right dataset"}[[leftright]]],Bold],""},
			{"PlotTitle",PaneSelector[{
				1->Control@{{label1,"",""},InputField[#,String]&},
				2->Control@{{label2,"",""},InputField[#,String]&}},Dynamic[leftright]]},
			{"Color function",PaneSelector[{
				1->Control@{{color1,pcol1,""},colors,ControlType->PopupMenu},
				2->Control@{{color2,pcol2,""},colors,ControlType->PopupMenu}},Dynamic[leftright]]},
			{"Color style",PaneSelector[{
				1->Control@{{lstyle1,1,""},colfuncs},
				2->Control@{{lstyle2,1,""},colfuncs}},Dynamic[leftright]]}
			},True],
		ManPannel["Overlay/Checkboard Plot Options",{
			{"Merge Plots",Control@{{overlay,1,""},{1->"None",2->"Checkboard",3->"Overlay",4->"Difference"}}},
			{"Flip",Control@{{flip,False,""},{True,False}}},
			{"Legend",Control@{{leg,1,""},{1->"First","Second"}}},
			{
				PaneSelector[{1 -> Null, 2 -> "Check Size (pix)",3 -> "Overlay Opacity", 4 -> "Difference plot range"},Dynamic[overlay]],
 				PaneSelector[{
 					1 -> Null,
 					2 -> Control@{{checksize, Ceiling[0.1*mpdim], ""}, 1, Ceiling[.5*mpdim], 1},
 					3 -> Control@{{opac, 0.4, ""}, 0, 1},
 					4 -> Control@{{diffr, .5*maxabs, ""}, Dynamic[0.00001*maxabs], Dynamic[2*maxabs] /. 0. -> 1., Dynamic[(1.5*maxabs /. 0. -> 1.)/1000]}}
 					,Dynamic[overlay]]
 			}},False]}];
	(*second tab, exporting controls*)
	tab2=Column[{
		ManPannel["Export plot",{
			{"File Type",Control@{{fileType,".jpg",""},files}},
			{"Export Size",Control@{{size,400,""},sizes,ControlType->PopupMenu}},
			{"Export",Button["Save Plot",SaveImage[Dynamic[exp],FileType->fileType,ImageSize -> size],Method->"Queued",ImageSize->150]}
			}]
		,
		{"",
			ManPannel["Export multiple plots as files",{
				{"Start slice",Control@{{start1,1,""},1,Dynamic[end1],1, Appearance -> "Labeled"}},
				{"End slice",Control@{{end1,rangex,""},Dynamic[start1],rangex,1, Appearance -> "Labeled"}},
				{"Export Files",Button["Save Plots",MultiFileSave[Hold[plot[xs,ys,xs]],Hold[plab[xs,ys,True]],{start1,end1},fileType,size],
					Method->"Queued",ImageSize->150]}
				}],
			ManPannel["Export multiple plots as files",{
				{"Start slice 1",Control@{{start1,1,""},1,Dynamic[end1],1, Appearance -> "Labeled"}},
				{"End slice 1",Control@{{end1,rangex,""},Dynamic[start1],rangex,1, Appearance -> "Labeled"}},
				{"Start slice 2",Control@{{start2,1,""},1,Dynamic[end2],1, Appearance -> "Labeled"}},
				{"End slice 2",Control@{{end2,rangey,""},Dynamic[start2],rangey,1, Appearance -> "Labeled"}},
				{"Export Files",Button["Save Plots",MultiFileSave[Hold[plot[xs,ys,xs]],Hold[plab[xs,ys,True]],{start1,end1,start2,end2},fileType,size],
					Method->"Queued",ImageSize->150]}
				}]
			}[[n]],
		{"",
			ManPannel["Export multiple plots as animated gif",{
				{"Display Duration (s)",Control@{{dur,.5,""},0.1,2,0.1, Appearance -> "Labeled"}},
				{"Animation Repetitions",Control@{{loop,Infinity,""},{Infinity,1,2,3,4,5},ControlType->PopupMenu}},
				{"Export Movie",Button["Save Movie",MovieSave[Hold[plot[xs,ys,xs]],dur,loop,size,{start1,end1,start2,end2}[[1;;2(n-1)]]], Method->"Queued",ImageSize->150]}
				}]
			}[[Unitize[n-1]+1]]
		}];
		
	(*Build the control pannel, allows for easy addition of more tabs*)
	control={str,Delimiter,{{pannel,1,""},{1->"Plotting options",2->"Exporting options"}},Delimiter,PaneSelector[{1->tab1,2->tab2},pannel]};

	(*Deploy plot window*)
	pan=Manipulate[
		If[!ListQ[data1]||!ListQ[data2],Return[]];
		
		(*updata slice range for 3D and 4D plots when switching between axial and sagital*)
		If[(Take[dim1,-2] == Take[dim2,-2] && ArrayDepth[data1] >= 3 && ArrayDepth[data2] >= 3),
			rangex={dim1[[1]],Take[dim1,{-2}][[1]],Take[dim1,{-1}][[1]]}[[or]]
		];
		
		(*reverse slices if needed*)
		x=If[NumericQ[x],Clip[x,{1,rangex}],1];
		xp=If[reverse,(-x+rangex)+1,x];
		yp=If[NumericQ[yp],Clip[yp,{1,rangey}],1];
		
		(*determine the aspect ration based on the voxelsize and dimensions*)
		aspect=Reverse[Drop[vox,{or}]];
		
		(*based on the data dimensions or how the data is showed determine how the data selection looks*)
		pdata1={
			data1&,
			{data1[[#1]]&,Reverse[data1[[All,#1]]]&,Reverse[data1[[All,All,#1]]]&}[[or]],
			{data1[[#1,#2]]&,Reverse[data1[[All,#2,#1]]]&,Reverse[data1[[All,#2,All,#1]]]&}[[or]]
			}[[ArrayDepth[data1]-1]];		
		
		pdata2={data2&,
			{data2[[#1]]&,Reverse[data2[[All,#1]]]&,Reverse[data2[[All,All,#1]]]&}[[or]],
			{data2[[#1,#2]]&,Reverse[data2[[All,#2,#1]]]&,Reverse[data2[[All,#2,All,#1]]]&}[[or]]
			}[[ArrayDepth[data2]-1]];

		(*Make plot label*)
		plabs={{},{#1},{#1,#2}}[[#3-1]]&;
		plab=If[adep1 == adep2,
			(*if both are no label set bot to zero*)
			If[label1!=""||label2!="",{label1,label2}={label1,label2} /. ""->" "];
			{
				If[label1==="",None,label1],
				If[label2==="",None,label2],
				If[#3,LabelFunc[label,plabs[#1,#2, adep1]],LabelFunc[label,{}]]
			}
			,
			If[label1!=""||label2!="",{label1,label2}={label1,label2} /. ""->" "];
			{
				If[#3,LabelFunc[label1,plabs[#1,#2, adep1]],LabelFunc[label1,{}]],
				If[#3,LabelFunc[label2,plabs[#1,#2, adep2]],LabelFunc[label2,{}]],
				If[label==="",None,label]
			}
			]&;
		
		ccol={
			Switch[clip1,"Auto",ColorData2[color1]/@{0,1},"Custom",{minclip1,maxclip1},"Transparent",{Transparent,Transparent}],
			Switch[clip2,"Auto",ColorData2[color2]/@{0,1},"Custom",{minclip2,maxclip2},"Transparent",{Transparent,Transparent}]
			};
		
		plot=Plot2i[
			{pdata1[#1,#2],pdata2[#1,#2]},			(*the data*)
			{{min1,max1},{min2,max2}},				(*the plot range*)
			plab[#3,#2,lab],						(*the plot label*)
			ps,										(*the plot size*)
			{{lstyle1,color1},{lstyle2,color2}},	(*style (1-4),colorfunction*)
			{cfs1,cfs2},							(*color function scaling aut*)
			legend,									(*show plot legend*)
			frame,									(*show the frame*)
			{overlay,checksize,flip,opac,diffr},	(*the overlay options*)
			ccol,									(*the plot clip color*)
			aspect,									(*the aspect ratio*)
			leg										(*chose the legend bar*)
			]&;
			
		(* Create and show plot*)
		exp=plot[xp,yp,x]
	
		,##,
		Initialization:>{or=1,reverse=False,legend=False,leftright->1},
		ControlPlacement->Right,
		(*Deployed->True,*) 
		SynchronousInitialization -> False
		]&@@control;
		
		NotebookClose[plotwindow];
		plotwindow=CreateWindow[DialogNotebook[{CancelButton["Close", Clear[data1,data2];DialogReturn[]], pan}, 
			WindowSize -> All, WindowTitle -> "Plot data window"]];
	];


(* ::Subsection::Closed:: *)
(*Plot Data 3D*)


SyntaxInformation[PlotData3D] = {"ArgumentsPattern" -> {_, _.}};

PlotData3D[data_, vox : {_, _, _} : {1, 1, 1}] := Module[{
   mind, maxd, dimd, dat, depth, colf, str, size1b, size1, size2, size3
   (*dim,size1,size1b,size2,size3,scal,ratio,tran,rowp,columnp,setp,
   slicep,dats,pdat,pmin,pmax,
   linax,lincor,linsag,plax,plcor,plsag,imax,imcor,imsag,imall,sel,
   slices3D,plsl3D,plim3D*)
   },
  
  NotebookClose[plotwindow];
  ClearTemporaryVariables[];
  
  If[! ArrayQ[data, _, NumericQ], Return[Message[PlotData3D::data]]];
  
  {mind, maxd} = MinMax[data];
  dat = Reverse@ToByte[data, {mind, maxd}];
  dimd = Dimensions[dat];
  depth = ArrayDepth[dat];
  
  str = "Displaying " <> DataString[dimd];
  
  {size1b, size1, size2, size3} = If[depth != 4,
    Prepend[dimd, 1],
    dimd[[{2, 1, 3, 4}]]
    ];
    
  pan = Manipulate[
    
    (*first part is data management, pdat is the data to be plotted*)
    t1 = (
        (*determine scaling and dimensions*)
        {size1b, size1, size2, size3} = If[depth != 4,
          Prepend[dimd, 1],
          If[trans, dimd[[{1, 2, 3, 4}]], dimd[[{2, 1, 3, 4}]]]
          ];
        dim = {size1, size2, size3};
        ratio = Reverse[vox*dim]/Max[(vox*dim)];
        
        (*correctly clip the slice numbers and mirror slices if needed*)
        If[depth == 4 && trans != tran, {tran, slice, set} = {trans, set, slice}];
        
        set = If[NumericQ[set], Clip[set, {1, size1b}], 1];
        slice = If[NumericQ[slice], Clip[slice, {1, size1}], 1];
        column = If[NumericQ[column], Clip[column, {1, size2}], 1];
        row = If[NumericQ[row], Clip[row, {1, size3}], 1];
        
        {columnp, rowp} = {size2 - column + 1, row};
        {setp, slicep} = If[trans && depth == 4, {size1b - set + 1, slice}, {set, size1 - slice + 1}];
        
        (*determine to draw lines and adjust pot scaling for all pannels*)
        scal = If[show != 4, scale, 0.5 scale];
        
        (*rescale 3D values for 3D image and select correct dataset*)
        dats = If[depth == 4, If[trans, dat[[setp]], dat[[All, setp]]], dat];
        pdat = If[reverse, Reverse[dats], dats];
        ) // AbsoluteTiming // First;
    
    (*Create dynamic color function, with clipping for min and max vals*)
    t2 = (
    	(*Find the find the color scale range*)    
        {pmin, pmax} = If[cfs, ToByte[MinMax[pdat], {0, 1}], ToByte[{min, max}, {mind, maxd}]];
        (*define the color lookup table*)
        colf = LookUpTable2[{lstyle, color}, If[transp, {RGBColor[0, 0, 0, 0], RGBColor[0, 0, 0, 0]}, {minclip, maxclip}], {pmin, pmax}];
        ) // AbsoluteTiming // First;
    
    (*create the lices for the pannel all view*)
    t3 = (
        {linax, lincor, linsag} = If[show == 4 && lines,
           {Graphics[{Thickness[Large], Red, Line[{{row, 0}, {row, size2 + 1}} - 0.5], Green, Line[{{0, column}, {size3 + 1, column}} - 0.5]}],
            Graphics[{Thickness[Large], Red, Line[{{row, 0}, {row, size1 + 1}} - 0.5], Blue,  Line[{{0, slice}, {size3 + 1, slice}} - 0.5]}],
            Graphics[{Thickness[Large], Green, Line[{{column, 0}, {column, size1 + 1}} - 0.5], Blue, Line[{{0, slice}, {size2 + 1, slice}} - 0.5]}]},
           {Graphics[], Graphics[], Graphics[]}
           ];
        ) // AbsoluteTiming // First;
    
    (*create the axial coronal and sagital images*)
    t4 = (
        If[MemberQ[If[planez, {1, 4, 5, 7}, {1, 4}], show],
         	imax = Image[Raster[Reverse@pdat[[slicep]], ColorFunction -> colf, ColorFunctionScaling -> False], ColorSpace -> "RGB"];
         	plax = Show[imax, linax, ImageSize -> scal {ratio[[1]], ratio[[2]]}, AspectRatio -> Full];
         ];
        If[MemberQ[If[planey, {2, 4, 5, 7}, {2, 4}], show],
         	imcor = Image[Raster[Reverse@pdat[[All, columnp]], ColorFunction -> colf, ColorFunctionScaling -> False], ColorSpace -> "RGB"];
         	plcor = Show[imcor, lincor, ImageSize -> scal {ratio[[1]], ratio[[3]]}, AspectRatio -> Full];
         ];
        If[MemberQ[If[planex, {3, 4, 5, 7}, {3, 4}], show], 
        	imsag = Image[Raster[Reverse@pdat[[All, All, rowp]], ColorFunction -> colf, ColorFunctionScaling -> False], ColorSpace -> "RGB"];
         	plsag = Show[imsag, linsag, ImageSize -> scal {ratio[[2]], ratio[[3]]}, AspectRatio -> Full];
         ];
        ) // AbsoluteTiming // First;
    
    (*create the pannel all view with event handles to click and select*)
     t5 = (
        If[show == 4,
          imall = Grid[{
          	{EventHandler[plax, {"MouseDown" :> ({row, column} = Abs[Round[MousePosition["Graphics"]] - {-1, -1}])}]},
          	{EventHandler[plcor, {"MouseDown" :> ({row, slice} = Abs[Round[MousePosition["Graphics"]] - {-1, 1}])}],
             EventHandler[plsag, {"MouseDown" :> ({column, slice} = (Abs[Round[MousePosition["Graphics"]] - {-1, 1}]))}]}}, 
             Background -> White, Spacings -> {0, 0}, Frame -> All, FrameStyle -> Directive[{Thickness[6], White}]]
          ];
        ) // AbsoluteTiming // First;
    
    If[MemberQ[views[[All, 1]], vp], vv = {0, 0, 1}; va = 25. Degree];
    
    (*create the 3d slice view*)
    t6 = (
        If[show == 5 || show == 7,
          sel = DeleteCases[{If[planez, 1], If[planey, 2], If[planex, 3]}, Null];
          slices3D = If[sel == {}, 
          	{}, 
          	{Opacity[{opz, opy, opx}[[#]]],  
               Texture[{imax, imcor, imsag}[[#]]], 
               Polygon[{
               	{{1, 1, slice}, {size3, 1, slice}, {size3, size2, slice}, {1, size2, slice}}, 
               	{{1, column, 1}, {size3, column, 1}, {size3, column, size1}, {1, column, size1}},
                {{row, 1, 1}, {row, size2, 1}, {row, size2, size1}, {row, 1, size1}}}[[#]], 
                VertexTextureCoordinates -> {{0.025, 0.025}, {0.975, 0.025}, {0.975, 0.975}, {0.025, 0.975}}]} & /@ sel
            ];
           
          plsl3D = Show[Graphics3D[{EdgeForm[None], slices3D},
             BoxRatios -> ratio, ImageSize -> scale, RotationAction -> "Clip", SphericalRegion -> True, 
             Background -> back, Lighting -> "Neutral", ViewPoint -> Dynamic[vp], ViewVertical -> Dynamic[vv],  ViewAngle -> Dynamic[va],
             Boxed -> box, Axes -> axes, AxesStyle -> Thread[List[{Red, Green, Blue}, Thick]]
             ], 
            PlotRange -> {{-1, size3 + 1}, {-1, size2 + 1}, {-1, size1 + 1}}, PerformanceGoal -> "Quality"]
          ];
        ) // AbsoluteTiming // First;
    
    (*Create the 3D image using Image3D*)
    t7 = ( 
        If[show == 6 || show == 7, 
          plim3D = Image3D[ToByte[pdat, {pmin, pmax}], ColorFunction -> col3D, Method -> {"SampleLayers" -> 100}, 
          	BoxRatios -> ratio, ImageSize -> scale, SphericalRegion -> True,  ViewPoint -> Dynamic[vp], ViewVertical -> Dynamic[vv],  ViewAngle -> Dynamic[va],
            Background -> back, Boxed -> box, Axes -> axes, AxesStyle -> Thread[List[{Red, Green, Blue}, Thick]]
            ]
        ];
        ) // AbsoluteTiming // First;
    
    (*If the Hybrid 3D slice and image3D veiuw is selected join the two images*)
    If[show == 7,
     merge = Show[Graphics3D[{EdgeForm[None], slices3D}], plim3D,
       BoxRatios -> ratio, ImageSize -> scale, RotationAction -> "Clip", SphericalRegion -> True, 
       Background -> back, Lighting -> "Neutral", ViewPoint -> Dynamic[vp], ViewVertical -> Dynamic[vv], ViewAngle -> Dynamic[va],
       Boxed -> box, Axes -> axes, AxesStyle -> Thread[List[{Red, Green, Blue}, Thick]],
       PlotRange -> {{-1, size3 + 1}, {-1, size2 + 1}, {-1, size1 + 1}}, PerformanceGoal -> "Quality"]
     ];
    
    Column[{Switch[show, 1, plax, 2, plcor, 3, plsag, 4, imall, 5, plsl3D, 6, plim3D, 7, merge]}]
    
    (*start control pannel*)
    ,
    Row[{str}],
    Delimiter,
    (*The menu that selects what to show*)
    {{show, 4, "Plot Mode"}, {1 -> "Axial", 2 -> "Coronal", 3 -> "Sagital", 4 -> "All Planes", 5 -> "Planes 3D", 6 -> "Volume 3D", 7 -> "Planes + 3D"}},
    (*slice selection menu and *)
    Delimiter,
    Column[{
      ManPannel["Slice Selection", {
        {Dynamic["Axial (1-" <> ToString[size1] <> ")"], Control@{{slice, Round[dimd[[1]]/2], ""}, 1, size1, 1}},
        {Dynamic[ "Coronal (1-" <> ToString[size2] <> ")"], Control@{{column, Round[size2/2], ""}, 1, size2, 1}},
        {Dynamic["Sagital (1-" <> ToString[size3] <> ")"], Control@{{row, Round[size3/2], ""}, 1, size3, 1}},
        {"Data order", Row[{ Control@{{trans, False, ""}, {True, False}},"  Transpose 4D   ", Control@{{reverse, False, ""}, {True, False}}, "  Reverse slices"}]},
        {Dynamic["Set (4D)  (1-" <> ToString[size1b] <> ")"], Control@{{set, 1, ""}, 1, Dynamic[size1b], 1}}, 
        {"Clip 3D", Row[{Control@{{clip, False, ""}, {True, False}}, "  Clip   ", CheckboxBar[Dynamic[flip], {1 -> "Flip LR", 2 -> "Flip AP",3 -> "Flip FH"}]}]} 
        }]
      }],
    Delimiter,
    Column[{
      ManPannel["Plot Range", {
        {"Auto Scaling", Control@{{cfs, False, ""}, {True -> "On", False -> "Off"}}},
        {"Min value", Control@{{min, mind, ""}, mind, Dynamic[0.9 max]}},
        {"Max value", Control@{{max, maxd, ""}, Dynamic[1.1 min], maxd}},
        {"Min Clipping", Control@{{minclip, RGBColor[{0, 0, 0}], ""}, ColorSlider[#, ImageSize -> {Automatic, 15}] &}},
        {"Max Clipping", Control@{{maxclip, RGBColor[{255, 255, 255}], "" }, ColorSlider[#, ImageSize -> {Automatic, 15}] &}},
        {"Transparent Clipping", Control@{{transp, False, ""}, {True -> "On", False -> "Off"}}}
        }]
      }],
    Delimiter,
    (*menu for plot style*)
    Column[{
      ManPannel["Plot Style", {
        {"Plot Title", Control@{{label, "", ""}, InputField[#, String] &}},
        {"Plot Size", Control@{{scale, 500, "" }, psizes}},
        {"Color function", Control@{{color, "BlackToWhite", ""}, colors, ControlType -> PopupMenu}},
        {"Color style", Control@{{lstyle, 1, ""}, colfuncs}},
        {"Layout", Row[
          {"  Show box:", Control@{{box, True, ""}, {True, False}},
           "  Show axis:", Control@{{axes, True, ""}, {True, False}},
           "  Show lines:", Control@{{lines, True, ""}, {True, False}}
           }]},
        {"BackGround", Control@{{back, Gray, ""}, ColorSlider[#, ImageSize -> {Automatic, 15}] &}}
        }]
      }],
    (* menu for 3D plot options*)
    Delimiter,
    Column[{
      ManPannel["3D options", {
        { "Colorfunction 3D", Control@{{col3D, Automatic, ""}, colors3D}},
        {"Viewpoint", Control@{{vp, 3.5 {0.384, 0.709, 0.591}, ""}, views, ControlType -> SetterBar}},
        {"Show Planes", Row[{
           "Axial:  ", Control@{{planez, True, ""}, {True, False}},
           "  Coronal:  ", Control@{{planey, True, ""}, {True, False}},
           "  Sagital:  ", Control@{{planex, True, ""}, {True, False}}
           }]},
        {"Opacity Axial", Control@{{opz, 1, ""}, 0, 1, 0.1}},
        {"Opacity Coronal", Control@{{opy, 1, ""}, 0, 1, 0.1}},
        {"Opacity Sagital", Control@{{opx, 1, ""}, 0, 1, 0.1}}
        }, False]
      }],
    
    (*Hidden parameters*)
    (*for controls*)
    {slice, ControlType -> None}, {column, ControlType -> None}, {row, ControlType -> None}, {trans, ControlType -> None},
    {reverse, ControlType -> None}, {clip, ControlType -> None}, {flip, ControlType -> None}, {set, ControlType -> None},
    
    {{cfs, False}, ControlType -> None}, {min, ControlType -> None}, {max, ControlType -> None}, {{minclip, RGBColor[{0, 0, 0, 1}]}, ControlType -> None}, 
    {{maxclip, RGBColor[{255, 255, 255}]}, ControlType -> None}, {{transp, False}, ControlType -> None}, {col3D, ControlType -> None},
    
    {label, ControlType -> None}, {scale, ControlType -> None}, {color, ControlType -> None}, {lstyle, ControlType -> None},
    {{box, True}, ControlType -> None}, {{axes, True}, ControlType -> None}, {{lines, True}, ControlType -> None}, {{back, Gray}, ControlType -> None},
    
    {{planez, True}, ControlType -> None}, {{planey, True}, ControlType -> None}, {{planex, True}, ControlType -> None},
    {{opz, 1}, ControlType -> None}, {{opy, 1}, ControlType -> None}, {{opx, 1}, ControlType -> None},
    
    (*3d volume view*)
    {{vp, 2{0.65, -1.2, 1}, "ViewPoint"}, Dynamic[vp] &, ControlType -> None},
    {{vv, {0, 0, 1}, "ViewVertical"}, Dynamic[vv] &, ControlType -> None},
    {{va, 25. Degree, "ViewAngle"}, Dynamic[va] &, ControlType -> None},
    
    (*for calculations*)
    {dim, ControlType -> None}, {scal, ControlType -> None}, {ratio, ControlType -> None},
    {{tran, False}, ControlType -> None}, {rowp, ControlType -> None}, {columnp, ControlType -> None}, {setp, ControlType -> None}, {slicep, ControlType -> None},
    
    {dats, ControlType -> None}, {pdat, ControlType -> None}, {pmin, ControlType -> None}, {pmax, ControlType -> None},
    {linax, ControlType -> None}, {lincor, ControlType -> None}, {linsag, ControlType -> None},
    {plax, ControlType -> None}, {plcor, ControlType -> None}, {plsag, ControlType -> None},
    {imax, ControlType -> None}, {imcor, ControlType -> None}, {imsag, ControlType -> None}, {imall, ControlType -> None},
    {sel, ControlType -> None}, {slices3D, ControlType -> None}, {plsl3D, ControlType -> None}, {plim3D, ControlType -> None},
    
    ContentSize -> 1.15 {scale, scale},
    Alignment -> {Center, Center},
    ControlPlacement -> Right,
    ContinuousAction -> True,
    AppearanceElements -> None,
    AutorunSequencing -> {1},
    SynchronousInitialization -> False
	];
	
	plotwindow = CreateWindow[DialogNotebook[{CancelButton["Close", Clear[dat]; DialogReturn[]], pan}, WindowSize -> All, WindowTitle -> "Plot data window"]];
   ]

(*
SyntaxInformation[PlotData3D] = {"ArgumentsPattern" -> {_, _.}};

PlotData3D[data_, vox:{_, _, _}:{1, 1, 1}] := Module[{
   tran, depth, mind, maxd, dimd, ratio, dim, setp, slicep, columnp, rowp, line,
  scal, dats, pdat, im3D,colf, linax, lincor, linsag, plax, plcor, plsag, imall, sel, slices3D, plsl3D, plim3D, dat,
  imax, imcor, imsag, size1, size2, size3, size1b, mins,
     maxs
  },
 
 NotebookClose[plotwindow3D];
 ClearTemporaryVariables[];
 
 tran = False;
 depth = ArrayDepth[data];
 mind = Min[data];
 maxd = Max[data];
 dat = If[depth == 4, Reverse@ToByte[data, {mind, maxd}], 
    Reverse@ToByte[data, {mind, maxd}]];
 dimd = Dimensions[dat];
 
   size1b = 1;
   
   pan = Manipulate[
     
     t0 = (
         (*determine scaling and dimensions*)
         dim = {size1, size2, size3} = If[depth == 4, 
            If[trans, 
            	size1b = dimd[[1]]; dimd[[{2, 3, 4}]],
            	size1b = dimd[[2]]; dimd[[{1, 3, 4}]]
            	], 
            dimd];
         ratio = Reverse[vox*dim]/Max[(vox*dim)];
         
         (*correctly clip the slice numbers and mirror slices if needed*)
         If[depth == 4 && trans != tran, {tran, slice, set} = {trans, set, slice}];
         
         set = If[NumericQ[set], Clip[set, {1, size1b}], 1];
         slice = If[NumericQ[slice], Clip[slice, {1, size1}], 1];
         column = If[NumericQ[column], Clip[column, {1, size2}], 1];
         row = If[NumericQ[row], Clip[row, {1, size3}], 1];
         
         {setp, slicep, columnp, rowp} = If[trans && depth == 4, 
         	{size1b - set + 1, slice, column, size3 - row + 1}, 
         	{set, size1 - slice + 1, column, size3 - row + 1}];
         
         (*determine to draw lines and adjust pot scaling for all pannels*)
         {line, scal} = 
          If[show != 4, {False, scale}, {lines, 0.5 scale}];
         ) // AbsoluteTiming // First;
     
     (*create im3D*)
     t1 = (
         (*rescale 3D values for 3D image and select correct dataset*)

         
         dats = 
          If[depth == 4, 
           If[trans, {dat[[setp]]}, {dat[[All, setp]]}], {dat}];
         mins = Min[dats];
         maxs = Max[dats];
         min3D = Clip[min3D, {mins, 1}];
         max3D = Clip[max3D, {0, 2 maxs}];
         
         (*create im3D*)
         pdat = 
          If[show == 6, ToByte[##, {min3D, max3D}], ##] & @@
            dats;
         im3D = 
          Image3D[##, ColorFunction -> col3D] & @@ 
           If[reverse, {Reverse[pdat]}, {pdat}];
         ) // AbsoluteTiming // First;
     
     (*Create dynamic color function, 1000 values, 
     with clipping for min and max vals*)
     t2 = (
         If[show != 6,
         	(*colf = LookUpTable3[cfs, {lstyle, color}, {minclip, maxclip},If[cfs,{mind,maxd,mind,maxd},{mind,maxd,min,max}]]*)
         	colf = LookUpTable[{lstyle, color}, {minclip, maxclip}]         	
         	]
         ) // AbsoluteTiming // First;
     
     (*create the lices for the pannel all view*)
     t3 = (If[show == 4 && lines,
          
          linax = Graphics[{Red, Thickness[.01], 
             Line[{{column, 0}, {column, size2}}], Green, 
             Thickness[.01], Line[{{0, row}, {size3, row}}]}];
          
          lincor = 
           Graphics[{Red, Thickness[.01], 
             Line[{{column, 0}, {column, size3}}], Blue, 
             Thickness[.01], Line[{{0, slice}, {size3, slice}}]}];
          
          linsag = 
           Graphics[{Green, Thickness[.01], 
             Line[{{row, 0}, {row, size3}}], Blue, Thickness[.01], 
             Line[{{0, slice}, {size3, slice}}]}];
          ]
         ) // AbsoluteTiming // First;
     
     (*create the axial coronal and sagital images*)
     t4 = (
         If[MemberQ[If[planez, {1, 4, 5}, {1, 4}], show],
          
          imax = Colorize[Image3DSlices[im3D, {slicep}, 1][[1]], 
            ColorFunction -> colf, ColorFunctionScaling -> cfs];
          
          plax = Show[##, ImageSize -> scal {ratio[[1]], ratio[[2]]}, 
              AspectRatio -> Full] & @@ 
            If[line, {imax, linax}, {imax}];
          ];
         If[MemberQ[If[planey, {2, 4, 5}, {2, 4}], show],
          
          imcor = Colorize[Image3DSlices[im3D, {rowp}, 2][[1]], 
            ColorFunction -> colf, ColorFunctionScaling -> cfs];
          
          plcor = Show[##, ImageSize -> scal {ratio[[1]], ratio[[3]]},
               AspectRatio -> Full] & @@ 
            If[line, {imcor, lincor}, {imcor}];
          ];
         If[MemberQ[If[planex, {3, 4, 5}, {3, 4}], show],
          
          imsag = ImageReflect[
            Colorize[Image3DSlices[im3D, {columnp}, 3][[1]], 
             ColorFunction -> colf, ColorFunctionScaling -> cfs], 
            Left -> Right];
          
          plsag = Show[##, ImageSize -> scal {ratio[[2]], ratio[[3]]},
               AspectRatio -> Full] & @@ 
            If[line, {imsag, linsag}, {imsag}];
          ];
         ) // AbsoluteTiming // First;
     
     (*create the pannel all view with event handles to click and \
select*)
     t5 = (
         If[show == 4,
           imall = Grid[{{
               
               EventHandler[
                plax, {"MouseDown" :> ({column, row} = 
                    Abs[Round[
                    MousePosition["Graphics"]] - {-1, -1}])}]}, {
               
               EventHandler[
                plcor, {"MouseDown" :> ({column, slice} = 
                    Abs[Round[MousePosition["Graphics"]] - {-1, 1}])}],
               
               EventHandler[
                
                plsag, {"MouseDown" :> ({row, 
                    slice} = (Abs[
                    Round[MousePosition["Graphics"]] - {-1, 1}]))}]
               }}, Background -> White, Spacings -> {0, 0}, 
             Frame -> All, 
             FrameStyle -> Directive[{Thickness[6], White}]]];
         ) // AbsoluteTiming // First;
     
     If[MemberQ[views[[All, 1]], vp], vv = {0, 0, 1}];
     
     t6 = (If[show == 5,
           
           sel = DeleteCases[{If[planez, 1], If[planey, 2], 
              If[planex, 3]}, Null];
           
           slices3D = 
            If[sel == {}, {}, {Opacity[{opz, opy, opx}[[#]]], 
                Dynamic[Texture[{imax, imcor, imsag}[[#]]]], Polygon[{
                   {{1, 1, slice}, {size3, 1, slice}, {size3, size2, 
                    slice}, {1, size2, slice}},
                   {{1, row, 1}, {size2, row, 1}, {size2, row, 
                    size1}, {1, row, size1}},
                   {{column, 1, 1}, {column, size3, 1}, {column, 
                    size3, size1}, {column, 1, size1}}
                   }[[#]], 
                 VertexTextureCoordinates -> {{0, 0}, {1, 0}, {1, 
                    1}, {0, 1}}]} & /@ sel
             ];
           plsl3D = Show[Graphics3D[slices3D,
              BoxRatios -> ratio, ImageSize -> scale, 
              SphericalRegion -> True, Background -> back, 
              Lighting -> "Neutral",
              ViewPoint -> Dynamic[vp], ViewVertical -> Dynamic[vv], 
              ViewAngle -> Dynamic[va],
              Boxed -> box, Axes -> axes, 
              AxesStyle -> Thread[List[{Red, Green, Blue}, Thick]]
              ], 
             PlotRange -> {{-1, size3 + 1}, {-1, size2 + 1}, {-1, 
                size1 + 1}}]
           ];
         ) // AbsoluteTiming // First;
     
     If[show == 6, plim3D = Show[
         im3D,
         BoxRatios -> ratio, ImageSize -> scale, 
         SphericalRegion -> True, Background -> back, 
         Lighting -> "Neutral",
         ViewPoint -> Dynamic[vp], ViewVertical -> Dynamic[vv], 
         ViewAngle -> Dynamic[va],
         Boxed -> box, Axes -> axes, 
         AxesStyle -> Thread[List[{Red, Green, Blue}, Thick]],
         PlotRange -> {{-1, size3 + 1}, {-1, size2 + 1}, {-1, 
            size1 + 1}}
         ];
      ];
     
     Switch[show,
      1, plax,
      2, plcor,
      3, plsag,
      4, imall,
      5, plsl3D,
      6, plim3D
      ]
     
     ,
     
     (*show what*)
     {{show, 4, "Plot Mode"}, {1 -> "Axial", 2 -> "Coronal", 
       3 -> "Sagital", 4 -> "All Planes", 5 -> "Planes 3D", 
       6 -> "Volume 3D"}},
     {{scale, 500, "Plot Size"}, psizes},
     {{back, Gray, "BackGround"}, 
      ColorSlider[#, ImageSize -> {Automatic, 15}] &},
     
     (*general 4D*)
     {{set, 1, "Set (4D)"}, 1, Dynamic[size1b], 1},
     (*general 3D 4D*)
     {{trans, False, "Transpose 4D"}, {True, False}},
     {{reverse, False, "Reverse slices"}, {True, False}},
     {{slice, Round[size1/2], "Axial"}, 1, Dynamic[size1], 1},
     {{row, Round[size2/2], "Coronal"}, 1, Dynamic[size2], 1},
     {{column, Round[size3/2], "Sagital"}, 1, Dynamic[size3], 1},
     
     (*all planes 4*)
     {{lines, True, "Show lines"}, {True -> "On", False -> "Off"}},
     
     (*planes color 1-5*)
     {{color, "BlackToWhite", "ColorFunction"}, colors},
     {{lstyle, 1, "lstyle"}, colfuncs},
     {{cfs, False, "Auto Scaling"}, {True -> "On", False -> "Off"}},
     (*on or off by auto scale*)
     {{min, mind, "Min"}, mind, 0.9 max},
     {{minclip, RGBColor[{0, 0, 0}], "MinClip"}, 
      ColorSlider[#, ImageSize -> {Automatic, 15}] &},
     {{max, maxd, "Max"}, 1.1 min, maxd},
     {{maxclip, RGBColor[{255, 255, 255}], "MaxClip"}, 
      ColorSlider[#, ImageSize -> {Automatic, 15}] &},
     
     (*3D general 5-6*)
     {{box, True, "Show box"}, {True, False}},
     {{axes, True, "Show axis"}, {True, False}},
     {{vp, 3.5 {0.384, 0.709, 0.591}, "Viewpoint"}, views, 
      ControlType -> SetterBar},
     
     (*3D planes 5*)
     {{planex, True, "Show plane x"}, {True, False}},
     {{opx, 1, "Opacity plane x"}, 0, 1, 0.1},
     {{planey, True, "Show plane y"}, {True, False}},
     {{opy, 1, "Opacity plane y"}, 0, 1, 0.1},
     {{planez, True, "Show plane z"}, {True, False}},
     {{opz, 1, "Opacity plane z"}, 0, 1, 0.1},
     
     (*3Dvol 6*)
     {{col3D, Automatic, "Colorfunction 3D"}, colors3D},
     {{min3D, mins, "min 3D"}, Dynamic[mins], max3D},
     {{max3D, maxs, "max 3D"}, min3D, Dynamic[2 maxs]},
     
     {{vp, 3.5 {0.384, 0.709, 0.591}, "ViewPoint"}, Dynamic[vp] &, 
      ControlType -> None},
     {{vv, {0, 0, 1}, "ViewVertical"}, Dynamic[vv] &, 
      ControlType -> None},
     {{va, 25 Degree, "ViewAngle"}, Dynamic[va] &, 
      ControlType -> None},
     
     ControlPlacement -> Right,
     SynchronousInitialization -> False
     ];

   plotwindow3D = 
    CreateWindow[
     DialogNotebook[{CancelButton["Close",Clear[data]; DialogReturn[]], pan}, 
      WindowSize -> All, WindowTitle -> "Plot data window"]];
 ]
*)

(*
PointsFunc = 
  Compile[{{qual, _Real, 0}, {dx, _Integer, 0}, {dy, _Integer, 
     0}, {dz, _Integer, 0}, {size, _Integer, 0}, {alpha, _Real, 
     0}, {beta, _Real, 0}, {or, _Real, 1}},
   Block[{pts, pt = {1, 1, 1}, ptls, blank = {{1, 1, 1}}, test = 0, 
     step = Round[size/(qual*size)]},
    pts = Table[
      Round[(({{1, 0, 0}, {0, Cos[alpha], -Sin[alpha]}, {0, 
              Sin[alpha], Cos[alpha]}}.{{Cos[beta], 0, Sin[beta]}, {0,
               1, 0}, {-Sin[beta], 0, Cos[beta]}}).({x, y, or[[3]]} - 
            or)) + or],
      {y, -Round[(size - dy)/2], Round[(size - dy)/2] + dy, step},
      {x, -Round[(size - dx)/2], Round[(size - dx)/2] + dx, step}];
    Do[pts = DeleteCases[(
          ptls = #;
          blank = ConstantArray[0, Dimensions[ptls]];
          
          test = Total[(pt = #; 
               If[1 - step <= pt[[1]] <= dx + step && 
                 1 - step <= pt[[2]] <= dy + step && 
                 1 - step <= pt[[3]] <= dz + step, 1, 0]) & /@ ptls];
          If[test > 0, ptls, blank]
          ) & /@ pts, blank];
     pts = Transpose[DeleteCases[(
           ptls = #;
           blank = ConstantArray[0, Dimensions[ptls]];
           
           test = Total[(pt = #; 
                If[1 - step <= pt[[1]] <= dx + step && 
                  1 - step <= pt[[2]] <= dy + step && 
                  1 - step <= pt[[3]] <= dz + step, 1, 0]) & /@ ptls];
           If[test > 0, ptls, blank]
           ) & /@ Transpose[pts], blank]];
     , {2}];
    pts
    ]];

AngCor = Function[{ang, cor}, 
   If[-45 <= ang <= 45, ang*(cor/45), 
     If[Positive[ang], 
      cor + (ang - 45)*(90 - cor)/45, -cor + (ang + 45)*(90 - cor)/
         45]] Degree];


SyntaxInformation[PlotData3D] = {"ArgumentsPattern" -> {_, _.}};

PlotData3D[data_, vox : {_, _, _} : {1, 1, 1}] := 
 Module[{tab1, tab2, tab3, tab4, control, dim, dz, dx, dy, planes, 
   qual, xx, yy, zz, planex, opx, planey, opy, planez, opz, ratio, or,
    clip, slicex, slicey, slicez, 
   slicea, sliceao, surf, vp, va, vv, plot, exp, diag, dorig, dqual, 
   opd, diagx, diagy, diagz, alpha, beta, box, axes, label, ps, color,
    lstyle, bcol, legend, min, max, minclip, maxclip, 
   pxmin, pxmax, pymin, pymax, pzmin, pzmax, iso, isoval, surfqual, 
   surfop, surfcol, fileType, size, pannel, dimq, pts, pol, gr, vec, 
   a, b, c, ang, angx, angy}, 
  If[(! ArrayQ[data, _, NumericQ]) || (! ArrayDepth[data] == 3), Return[Message[PlotData3D::data]]];
  
  dim = {dz, dy, dx} = Dimensions[data];
  size = Round[Sqrt[Total[#^2 & /@ Drop[Sort[dim], 1]]] // N];
  
  tab1 = Column[{ManPannel[
      "Planes", {
      	{"Show Planes",Control@{{planes, True, ""}, {True, False}}}, 
      	{"Plane Quality (%)", Control@{{qual, .5, ""}, .2, 1, .2}}, 
      	{Style["Plane Navigation", Bold], ""}, 
        {"Corronal Slice (x)",Control@{{xx, Round[dx/2], ""}, 1, dx, 1}}, 
        {"Saggital Slice (y)",Control@{{yy, Round[dy/2], ""}, 1, dy, 1}}, 
        {"Axial Slice (z)",Control@{{zz, Round[dz/2], ""}, 1, dz, 1}}, 
        {Style["Plane Settings", Bold], ""}, 
        {"Show Corronal (x)",Control@{{planex, True, ""}, {True, False}}}, 
        {"Plane Opacity (x)",Control@{{opx, 1, ""}, 0, 1, 0.1}}, 
        {"Show Saggital (y)",Control@{{planey, True, ""}, {True, False}}}, 
        {"Plane Opacity (y)",Control@{{opy, 1, ""}, 0, 1, 0.1}}, 
        {"Show Axial (z)",Control@{{planez, True, ""}, {True, False}}}, 
        {"Plane Opacity (z)",Control@{{opz, 1, ""}, 0, 1, 0.1}}}], 
     ManPannel[
      "Diagonal plane", {
      	{"Show Diagonal",  Control@{{diag, False, ""}, {True,False}}}, 
        {"Show Plane Origin",Control@{{dorig, False, ""}, {True,False}}}, 
        {"Plane Quality (%)", Control@{{dqual, .5, ""},.2,1,.2}}, 
        {"Plane Opacity", Control@{{opd, 1, ""}, 0, 1, 0.1}}, 
        {Style["Position", Bold], ""}, 
        {"Diagonal x Position", Control@{{diagx, Round[dx/2], ""}, 1, dx, 1}}, 
        {"Diagonal y Position", Control@{{diagy, Round[dy/2], ""}, 1, dy,1}}, 
        {"Diagonal z Position",  Control@{{diagz, Round[dz/2], ""}, 1, dz, 1}}, 
        {Style["Rotation", Bold], ""}, 
        {"Rotation x-axis (\[Degree])", Control@{{alpha, 15, ""}, -90, 90,  1}}, 
        {"Rotation y-axis (\[Degree])",  Control@{{beta, 15, ""}, -90, 90, 1}}}, False]}];
  tab2 = Column[{ManPannel[
      "Plot Style", {
      	{"Show Box", Control@{{box, False, ""}, {True, False}}}, 
        {"Show Axes", Control@{{axes, False, ""}, {True, False}}}, 
        {"Plot Title", Control@{{label, "", ""}, InputField[#, String] &}}, 
        {"Plot Size", Control@{{ps, 400, ""}, sizes, ControlType -> PopupMenu}},
        {"Color function", Control@{{color, "GrayTones", ""}, colors, ControlType -> PopupMenu}}, 
        {"Color style", Control@{{lstyle, 1, ""}, colfuncs}}, 
        {"Background Color", Control@{{bcol, Gray, ""}, ColorSlider[#,  ImageSize -> {Automatic, 15}] &}}, 
        {"Legend on/off", Control@{{legend, False, ""}, {True, False}}}}], 
     ManPannel[
      "Plot Range", {
      	{"Min value", Control@{{min, Min[data], ""}, Min[data], max, (max - Min[data])/100}}, 
        {"Max value",  Control@{{max, Max[data], ""}, min, Max[data], (Max[data] - min)/100}}, 
        (*{"Transparent Clipping", Control@{{transclip, False, ""}, {True, False}}},*) 
        {"Min Clipping",  Control@{{minclip, Black, ""},  ColorSlider[#,  ImageSize -> {Automatic, 15}] &}}, 
        {"Max Clipping", Control@{{maxclip, White, ""},   ColorSlider[#, ImageSize -> {Automatic, 15}] &}}}], 
     ManPannel[
      "Slice Range", {
      	{"Minimal x value", Control@{{pxmin, 1, ""}, 1, pxmax, 1}}, 
        {"Maximal x value", Control@{{pxmax, dx, ""}, pxmin + 1, dx,1}}, 
        {"Minimal y value", Control@{{pymin, 1, ""}, 1, pymax, 1}}, 
        {"Maximal y value", Control@{{pymax, dy, ""}, pymin + 1, dy, 1}}, 
        {"Minimal z value", Control@{{pzmin, 1, ""}, 1, pzmax, 1}}, 
        {"Maximal z value", Control@{{pzmax, dz, ""}, pzmin + 1, dz, 1}}}]}];
  tab3 = Column[{ManPannel[
      "Iso Surface", {
      	{"Show IsoSurface", Control@{{iso, False, ""}, {True, False}}}, 
        {"Iso Value",  Control@{{isoval, {Round[Max[data]/2]}, ""}, InputField[#] &}}, 
        {"Surface Quality (%)", Control@{{surfqual, 50, ""}, 20, 125, 1}}, 
        {"Surface Opacity", Control@{{surfop, 1, ""}, 0, 1, 0.1}}, 
        {"Surface Color", Control@{{surfcol, Darker[Red], ""}, ColorSlider[#, ImageSize -> {Automatic, 15}] &}}}]}];
  tab4 = Column[{ManPannel[
      "Export plot", {
      	{"File Type", Control@{{fileType, ".jpg", ""}, files}}, 
        {"Export Size", Control@{{size, 400, ""}, sizes, ControlType -> PopupMenu}}, 
        {"Export", Button["Save Plot", FileSave[exp, fileType, size],  Method -> "Queued", ImageSize -> 150]}}]}
        ];
  control = {{{pannel, 1, ""}, {1 -> "Planes", 
      2 -> "Plotting Options", 3 -> "IsoSurface", 4 -> "Export"}}, 
    Delimiter, 
    PaneSelector[{1 -> tab1, 2 -> tab2, 3 -> tab3, 4 -> tab4}, 
     pannel]};
  
  (*mind=If[Min[data//N]==0.,0.0001 Max[data],0.];*)
  PrintTemporary["Initializing plot window, please wait"];
  
  Manipulate[If[! ListQ[data], Return[]];
    If[! ArrayQ[data], Return[]];
    (*define box ratio*)
    
    ratio = {(pxmax - pxmin), (pymax - pymin), (pzmax - 
         pzmin)} Reverse[vox];
    ang = {angx, angy} = 
      N[{ArcTan[(ratio[[3]]/vox[[1]])/(ratio[[3]]/vox[[2]])], 
         ArcTan[(ratio[[3]]/vox[[1]])/(ratio[[3]]/vox[[3]])]}/Degree];
    
    (*diagonal slice parameters*)
    
    or = {diagx, diagy, diagz};
    vec = {a, b, c} = 
      Normalize[
       Reverse[vox] {Sin[
          AngCor[beta, angy]], -Cos[AngCor[beta, angy]] Sin[
           AngCor[alpha, angx]], 
         Cos[AngCor[alpha, angx]] Cos[AngCor[beta, angy]]}];
    
    clip = {minclip,maxclip};
     (*If[transclip, {Transparent, Transparent}, {minclip, maxclip}];*)
    With[{
      
      (*slice plot function*)
      
      SlicePlot = 
       Function[{n, op}, 
        dimq = Round[qual*dim[[Drop[{1, 2, 3}, {n}]]]];
        {Opacity[op], 
          Texture[Graphics[
            Raster[Clip[
              Rescale[
               RescaleImg[{data[[zz]], data[[All, yy, All]], 
                  data[[All, All, xx]]}[[n]], dimq], {min, max}], {0, 
               1}, {-1, -2}], 
             ColorFunction -> (ColSelC[#, clip, {lstyle, color}] &)], 
            PlotRange -> {{0, dimq[[2]]}, {0, dimq[[1]]}}]], 
          Polygon[{{{1, 1, zz}, {dx, 1, zz}, {dx, dy, zz}, {1, dy, 
               zz}}, {{1, yy, 1}, {dx, yy, 1}, {dx, yy, dz}, {1, yy, 
               dz}}, {{xx, 1, 1}, {xx, dy, 1}, {xx, dy, dz}, {xx, 1, 
               dz}}}[[n]], 
           VertexTextureCoordinates -> {{0, 0}, {1, 0}, {1, 1}, {0, 
              1}}]}]
      
     (*, SlicePlotAng = 
       Function[{col, op}, 
        pts = PointsFunc[dqual, dx, dy, dz, size, AngCor[alpha, angx],
           AngCor[beta, angy], {diagx, diagy, diagz}];
        pol = {First[First[pts]], First[Last[pts]], Last[Last[pts]], 
          Last[First[pts]]};
          
        gr = 
         Graphics[
          Raster[Clip[
            Rescale[
             Map[data[[Clip[#[[3]], {1, dz}], Clip[#[[2]], {1, dy}], 
                Clip[#[[1]], {1, dx}]]] &, pts, {2}], {min, max}], {0,
              1}, {-1, -2}], 
           ColorFunction -> (ColSelC[#, clip, {lstyle, col}] &)], 
          PlotRange -> {{0, Length[pts[[1]]]}, {0, Length[pts]}}];
        {Opacity[op], Texture[gr], 
          Polygon[pol, 
           VertexTextureCoordinates -> {{0, 0}, {0, 1}, {1, 1}, {1, 
              0}}]}]*)},
     
     (*Draw planes*)
     
     slicex = If[#1 && #2, SlicePlot[2, opx], {}] &;
     slicey = If[#1 && #2, SlicePlot[3, opy], {}] &;
     slicez = If[#1 && #2, SlicePlot[1, opz], {}] &;
     slicea = If[#, 
     	pts = PointsFunc[dqual, dx, dy, dz, size, AngCor[alpha, angx],
           AngCor[beta, angy], {diagx, diagy, diagz}];
        pol = {First[First[pts]], First[Last[pts]], Last[Last[pts]], 
          Last[First[pts]]};
        gr = Graphics[Raster[Clip[Rescale[
             Map[data[[Clip[#[[3]], {1, dz}], Clip[#[[2]], {1, dy}], 
                Clip[#[[1]], {1, dx}]]] &, pts, {2}], {min, max}], {0,
              1}, {-1, -2}], 
           ColorFunction -> (ColSelC[#, clip, {lstyle, color}] &)], 
          PlotRange -> {{0, Length[pts[[1]]]}, {0, Length[pts]}}];
        {Opacity[opd], Texture[gr], 
          Polygon[pol, 
           VertexTextureCoordinates -> {{0, 0}, {0, 1}, {1, 1}, {1, 
              0}}]}
  , {}] &;];
    
    (*Draw diagonal slice marker*)
    
    sliceao = 
     If[#, Dynamic[{Red, 
         Scale[Sphere[or, (1/20 Min[dim*vox])], Min[vox]/Reverse[vox],
           or], Green, Thick, Arrowheads[0.05], 
         Scale[Arrow[
           Tube[{or, 
             or + (.5 Min[dim*vox]) (Normalize[vec/Reverse[vox]])}, 
            0.8]], Min[vox]/Reverse[vox], or]}], {}] &;
    
    (*Draw iso surface*)
    
    surf = 
     If[#, Dynamic[
        ListContourPlot3D[data, Contours -> Cases[isoval, _?NumberQ], 
          Mesh -> False, Axes -> False, 
          ContourStyle -> Directive[Opacity[surfop], surfcol], 
          MaxPlotPoints -> Round[0.75 surfqual], 
          BoundaryStyle -> None][[1]]], {}] &;
    
    (*Generate Plot*)
    
    plot = 
     Dynamic[Graphics3D[{sliceao[dorig], surf[iso], slicez[planes, planez], 
       slicey[planes, planey], slicex[planes, planex], slicea[diag]}, 
      Lighting -> "Neutral", BoxRatios -> ratio, 
      ViewPoint -> Dynamic[vp], ViewVertical -> Dynamic[vv], 
      ViewAngle -> Dynamic[va], ImageSize -> ps, Background -> bcol, 
      SphericalRegion -> True, Boxed -> box, Axes -> axes, 
      AxesStyle -> Thread[List[{Red, Green, Blue}, Thick]], 
      BaseStyle -> {FontWeight -> Bold, FontFamily -> "sans-serif", 
        28}, LabelStyle -> 14, AxesLabel -> {"X", "Y", "Z"}, 
      PlotRange -> {{pxmin - 1, pxmax + 1}, {pymin - 1, 
         pymax + 1}, {pzmin - 1, pzmax + 1}}, 
      ContentSelectable -> True, PlotLabel -> label, 
      ImagePadding -> {{5, 5}, {5, 5}}]];
    
    (*Display Plot*)
    
    exp = If[legend, Legendi[plot, {lstyle, color, bcol}, min, max, ps], plot]
    
    (*Insert control pannels*)
    , ## ,
    (*Hidden manipulation parameters*)
    {{vp, {1.3, -2.4, 2}, "ViewPoint"}, Dynamic[vp] &, ControlType -> None}, 
    {{vv, {0, 0, 1}, "ViewVertical"}, Dynamic[vv] &, ControlType -> None}, 
    {{va, 25 Degree, "ViewAngle"}, Dynamic[va] &, ControlType -> None}, 
    Deployed -> False, 
    SynchronousInitialization -> False, 
    SynchronousUpdating -> False, 
    ContinuousAction -> False,
    ControlPlacement -> Right
    ]&@@ control]
*)


(*
PlotData3D[data_, vox:{_,_,_}:{1,1,1}] := 
 Module[{tab1, tab2, tab3, tab4, control, dim, dz, dx, dy,
   planes, qual, xx, yy, zz, planex, opx, planey, opy, planez, opz,
   ratio,or,clip,CR=Clip[Round[#1], {1, #2}]&,
   slicex,slicey,slicez,slicea,sliceao,surf,vp,va,vv,plot,exp,
   diag, dorig, dqual, opd, diagx, diagy, diagz, alpha, beta,
   box, axes, label, ps, color, lstyle, bcol, legend,
   min, max, transclip, minclip, maxclip,
   pxmin, pxmax, pymin, pymax, pzmin, pzmax,
   iso, isoval, surfqual, surfop, surfcol,
   fileType, size, pannel,dimq,
   vec, a, b, c, ang, angx, angy, afunc, arang, asel, v1, v2
   },
  
  If[(! ArrayQ[data, _, NumericQ]) || (! ArrayDepth[data] == 3),Return[Message[PlotData3D::data]]];
  
  dim = {dz, dy, dx} = Dimensions[data];
  
  tab1 = Column[{
     ManPannel["Planes", {
       {"Show Planes", Control@{{planes, True, ""}, {True, False}}},
       {"Plane Quality (%)", Control@{{qual, .5, ""}, .1, 1, .1}},
       {Style["Plane Navigation", Bold], ""},
       {"Corronal Slice (x)", 
        Control@{{xx, Round[dx/2], ""}, 1, dx, 1}},
       {"Saggital Slice (y)", 
        Control@{{yy, Round[dy/2], ""}, 1, dy, 1}},
       {"Axial Slice (z)", Control@{{zz, Round[dz/2], ""}, 1, dz, 1}},
       {Style["Plane Settings", Bold], ""},
       {"Show Corronal (x)", 
        Control@{{planex, True, ""}, {True, False}}},
       {"Plane Opacity (x)", Control@{{opx, 1, ""}, 0, 1, 0.1}},
       {"Show Saggital (y)", 
        Control@{{planey, True, ""}, {True, False}}},
       {"Plane Opacity (y)", Control@{{opy, 1, ""}, 0, 1, 0.1}},
       {"Show Axial (z)", Control@{{planez, True, ""}, {True, False}}},
       {"Plane Opacity (z)", Control@{{opz, 1, ""}, 0, 1, 0.1}}
       }]
     ,
     ManPannel["Diagonal plane", {
       {"Show Diagonal", Control@{{diag, False, ""}, {True, False}}},
       {"Show Plane Origin", 
        Control@{{dorig, False, ""}, {True, False}}},
       {"Plane Quality (%)", Control@{{dqual, .5, ""}, .1, 1, .1}},
       {"Plane Opacity", Control@{{opd, 1, ""}, 0, 1, 0.1}},
       {Style["Position", Bold], ""},
       {"Diagonal x Position", 
        Control@{{diagx, Round[dx/2], ""}, 1, dx, 1}},
       {"Diagonal y Position", 
        Control@{{diagy, Round[dy/2], ""}, 1, dy, 1}},
       {"Diagonal z Position", 
        Control@{{diagz, Round[dz/2], ""}, 1, dz, 1}},
       {Style["Rotation", Bold], ""},
       {"Rotation x-axis (\[Degree])", 
        Control@{{alpha, 15, ""}, -90, 90, 1}},
       {"Rotation y-axis (\[Degree])", 
        Control@{{beta, 15, ""}, -90, 90, 1}}
       }, False]
     }];
  
  tab2 = Column[{
     ManPannel["Plot Style", {
       {"Show Box", Control@{{box, False, ""}, {True, False}}},
       {"Show Axes", Control@{{axes, False, ""}, {True, False}}},
       {"Plot Title", 
        Control@{{label, "", ""}, InputField[#, String] &}},
       {"Plot Size", 
        Control@{{ps, 400, ""}, sizes, ControlType -> PopupMenu}},
       {"Color function", 
        Control@{{color, "GrayTones", ""}, colors, 
          ControlType -> PopupMenu}},
       {"Color style", Control@{{lstyle, 1, ""}, colfuncs}},
       {"Background Color", 
        Control@{{bcol, Gray, ""}, 
          ColorSlider[#, ImageSize -> {Automatic, 15}] &}},
       {"Legend on/off", Control@{{legend, False, ""}, {True, False}}}
       }]
     ,
     ManPannel["Plot Range", {
       {"Min value", 
        Control@{{min, Min[data], ""}, Min[data], 
          max, (max - Min[data])/100}},
       {"Max value", 
        Control@{{max, Max[data], ""}, min, 
          Max[data], (Max[data] - min)/100}},
       {"Transparent Clipping", 
        Control@{{transclip, False, ""}, {True, False}}},
       {"Min Clipping", 
        Control@{{minclip, Black, ""}, 
          ColorSlider[#, ImageSize -> {Automatic, 15}] &}},
       {"Max Clipping", 
        Control@{{maxclip, White, ""}, 
          ColorSlider[#, ImageSize -> {Automatic, 15}] &}}
       }]
     ,
     ManPannel["Slice Range", {
       {"Minimal x value", Control@{{pxmin, 1, ""}, 1, pxmax, 1}},
       {"Maximal x value", 
        Control@{{pxmax, dx, ""}, pxmin + 1, dx, 1}},
       {"Minimal y value", Control@{{pymin, 1, ""}, 1, pymax, 1}},
       {"Maximal y value", 
        Control@{{pymax, dy, ""}, pymin + 1, dy, 1}},
       {"Minimal z value", Control@{{pzmin, 1, ""}, 1, pzmax, 1}},
       {"Maximal z value", Control@{{pzmax, dz, ""}, pzmin + 1, dz, 1}}
       }]
     }];
  
  tab3 = Column[{
     ManPannel["Iso Surface", {
       {"Show IsoSurface", Control@{{iso, False, ""}, {True, False}}},
       {"Iso Value", 
        Control@{{isoval, {Round[Max[data]/2]}, ""}, InputField[#] &}},
       {"Surface Quality (%)", 
        Control@{{surfqual, 50, ""}, 20, 125, 1}},
       {"Surface Opacity", Control@{{surfop, 1, ""}, 0, 1, 0.1}},
       {"Surface Color", 
        Control@{{surfcol, Darker[Red], ""}, 
          ColorSlider[#, ImageSize -> {Automatic, 15}] &}}
       }]
     }];
  
  tab4 = Column[{
     ManPannel["Export plot", {
       {"File Type", Control@{{fileType, ".jpg", ""}, files}},
       {"Export Size", 
        Control@{{size, 400, ""}, sizes, ControlType -> PopupMenu}},
       {"Export", 
        Button["Save Plot", FileSave[exp, fileType, size], 
         Method -> "Queued", ImageSize -> 150]}
       }]
     }];
  
  control = {
    {{pannel, 1, ""}, {1 -> "Planes", 2 -> "Plotting Options", 
      3 -> "IsoSurface", 4 -> "Export"}},
    Delimiter,
    PaneSelector[{1 -> tab1, 2 -> tab2, 3 -> tab3, 4 -> tab4}, pannel]
    };
  
  (*mind = If[Min[data // N] == 0., 0.0001 Max[data], 0.];*)
  
  PrintTemporary["Initializing plot window, please wait"];
  
  Manipulate[
  	
  	If[!ArrayQ[data],Return[]];
     
     (*define box ratio*)
     ratio = {(pymax - pymin), (pxmax - pxmin), (pzmax - pzmin)} Reverse[vox];
     
     (*diagonal slice parameters*)
     or = {diagx, diagy, diagz};
     vec = {a, b, c} = Normalize[Reverse[vox] {Sin[alpha Degree] Cos[beta Degree], Sin[alpha Degree] Sin[beta Degree], Cos[alpha Degree]}];
     If[diag, 
     	ang = {angx, angy} = N[{ArcTan[dz/dx], ArcTan[dx/dy]}/Degree];
      	asel = If[Abs[alpha] > angx && Abs[beta] > angy, 1, If[Abs[alpha] > angx, 2, 3]];
      	afunc = {
      		{v1,(-a (v1 - diagx) - b (-diagy) - c (v2 - diagz))/If[b == 0 || b == 0., 1, b], v2}, 
          	{(-a (-diagx) - b (v1 - diagy) - c (v2 - diagz))/If[a == 0 || a == 0., 1, a], v1, v2}, 
          	{v1, v2, (-a (v1 - diagx) - b (v2 - diagy) - c (-diagz))/If[c == 0 || c == 0., 1, c]}
          	}[[asel]]// N;
      	arang = {{dx, dz}, {dy, dz}, {dx, dy}}[[asel]];
      	;
      ];
     
     clip=If[transclip, {Transparent,Transparent}, {minclip,maxclip}];
     
     With[{
        (*slice plot function*)
        SlicePlot = Function[{vecf, rang, op, qualf},
        	ParametricPlot3D[vecf, {v1, 1, rang[[1]]}, {v2, 1, rang[[2]]},
        		PlotStyle -> Opacity[op], PlotPoints -> Round[qualf rang], Mesh -> False, ColorFunctionScaling -> False,
        		ColorFunction -> (ColSelC[Clip[Rescale[data[[CR[#3,dz],CR[#1,dx],CR[#2,dy]]],{min,max}],{0,1},{-1,2}],clip,{lstyle,color}]&)
        	]]
        ,
    	SlicePlot2 = 
  Function[{n, op}, dimq = Round[qual*dim[[Drop[{1, 2, 3}, {n}]]]];
   Graphics3D[{Opacity[op], 
     Texture[Graphics[
       Raster[Clip[
         Rescale[RescaleImg[{data[[zz]], data[[All, All, yy]], 
             data[[All, xx, All]]}[[n]], dimq], {min, max}], {0, 
          1}, {-1, -2}], 
        ColorFunction -> (ColSelC[#, clip, {lstyle, color}] &)], 
       PlotRange -> {{0, dimq[[2]]}, {0, dimq[[1]]}}, 
       AspectRatio -> (Divide @@ (dimq*Drop[vox, {n}]))]],
     Polygon[{
        {{1, 1, zz}, {dim[[2]], 1, zz}, {dim[[2]], dim[[3]], zz}, {1, 
          dim[[3]], zz}},
        {{1, xx, 1}, {dim[[2]], xx, 1}, {dim[[2]], xx, dim[[1]]}, {1, 
          xx, dim[[1]]}},
        {{yy, 1, 1}, {yy, dim[[3]], 1}, {yy, dim[[3]], dim[[1]]}, {yy,
           1, dim[[1]]}}
        }[[n]], 
      VertexTextureCoordinates -> {{{0, 0}, {0, 1}, {1, 1}, {1, 
           0}}, {{0, 0}, {1, 0}, {1, 1}, {0, 1}}, {{0, 0}, {1, 0}, {1,
            1}, {0, 
           1}}}[[n]]]}]]},
           (*Draw planes*)
		(*slicex=If[#1&&#2,SlicePlot[{v1,xx,v2},{dy,dz},opx,qual],Graphics3D[]]&;
		slicey=If[#1&&#2,SlicePlot[{yy,v1,v2},{dx,dz},opy,qual],Graphics3D[]]&;
		slicez=If[#1&&#2,SlicePlot[{v1,v2,zz},{dx,dy},opz,qual],Graphics3D[]]&;*)
		slicex = If[#1 && #2, SlicePlot2[2, opx], Graphics3D[]] &;
		slicey = If[#1 && #2, SlicePlot2[3, opy], Graphics3D[]] &;
		slicez = If[#1 && #2, SlicePlot2[1, opz], Graphics3D[]] &;
      slicea = If[#, SlicePlot[afunc, arang, opd, dqual], Graphics3D[]]&;
      ];
     
     (*Draw diagonal slice marker*)
     sliceao = If[#, Graphics3D[{Red,Scale[Sphere[or, 3], Min[vox]/Reverse[vox], or], Green, Thick, Arrowheads[0.05], 
         Scale[Arrow[Tube[{or, or + (1/5 Min[dim*vox]) (Normalize[vec/Reverse[vox]])}, 0.8]], Min[vox]/Reverse[vox], or]}],
       Graphics3D[]]&;
     
     (*Draw iso surface*)
     surf = If[#, ListContourPlot3D[Transpose[data, {1, 3, 2}], Contours -> Cases[isoval, _?NumberQ],Mesh -> False, Axes -> False,
        ContourStyle -> Directive[Opacity[surfop], surfcol], MaxPlotPoints -> Round[0.75 surfqual], BoundaryStyle -> None],
       Graphics3D[]]&;
     
     (*Generate Plot*)
     plot = Show[
       sliceao[dorig], surf[iso], slicez[planes,planez], slicey[planes,planey], slicex[planes,planex], slicea[diag],
       Lighting -> "Neutral", BoxRatios -> ratio, 
       ViewPoint -> Dynamic[vp], ViewVertical -> Dynamic[vv], 
       ViewAngle -> Dynamic[va], ImageSize -> ps, Background -> bcol, 
       SphericalRegion -> True, Boxed -> box, Axes -> axes, 
       AxesStyle -> Thread[List[{ Green, Red, Blue}, Thick]], 
       BaseStyle -> {FontWeight -> Bold, FontFamily -> "sans-serif", 
         28}, LabelStyle -> 14, AxesLabel -> { "Y", "X", "Z"}, 
       PlotRange -> {{pymin - 1, pymax + 1}, {pxmin - 1, 
          pxmax + 1}, {pzmin - 1, pzmax + 1}}, 
       ContentSelectable -> True, PlotLabel -> label, 
       ImagePadding -> {{5, 5}, {5, 5}}
       ];
     
     (*Display Plot*)  
     exp=If[legend,Dynamic[Legendi[plot,{lstyle,color,bcol},min,max,ps]],Dynamic[plot]]
       
     (*Insert control pannels*)  
     , ##,
     (*Hidden manipulation parameters*)
     {{vp, {1.3, -2.4, 2}, "ViewPoint"}, Dynamic[vp] &, ControlType -> None},
     {{vv, {0, 0, 1}, "ViewVertical"}, Dynamic[vv] &, ControlType -> None},
     {{va, 25 Degree, "ViewAngle"}, Dynamic[va] &, ControlType -> None},
     
     Deployed->True,
     SynchronousInitialization -> False,
     ControlPlacement -> Right,
     SynchronousUpdating -> False,
     ContinuousAction -> False] & @@ control
  ]
*)

(*CreateWindow[DialogNotebook[
    {CancelButton["Close", DialogReturn[]],*) 



(* ::Subsection::Closed:: *)
(*Plot Deformed Grid*)


PlotDefGrid[dat_?ArrayQ,phase_?ArrayQ,shiftpar_?ListQ]:=
Module[{dim,exp,data,shift,dir,label,settings,z,min,max,ps,color,maxclip,fileType,size,depth,n,str,
	minclip,transclip,gs,gf,ncol,dcol,lcol,acol,def,norm,defl,arr,pl,tab1,tab2,pannel,control,mind,maxd},
	data=N[dat];
	dim=Dimensions[data];
	shift=N[phase]*shiftpar[[1]];
	dir=shiftpar[[2]];
	
	(*Check if data is numeric array, if not exit*)
	data=dat//N;
	If[!ArrayQ[data,_,NumericQ],Return[Message[PlotData::data]]];
	
	(*See what kind of data: 2D,3D or 4D (n=1,2,3). If not one of those exit*)
	depth=ArrayDepth[data];
	If[depth>4, Return[Message[PlotData::set]]];
	n=depth-1;
		
	(*Determine data dimensions en make string displaying data dimensions*)
	dim=Dimensions[data];
	str="Displaying "<>DataString[dim];
	
	(*Initialize slice ranges and data range*)
	rangex = dim[[1]];
	rangey = dim[[2]];

	(*Rescale data between 0 and 1*)
	{mind,maxd}=If[ListQ[OptionValue[PlotRange]] && Length[OptionValue[PlotRange]]==2,OptionValue[PlotRange],{Min[data],Max[data]}];
	If[mind==maxd,maxd=mind+0.01];
	(*data=(##[data,{mind,maxd}])&@@{{ToByte2,ToByte3,ToByte4}[[n]]};*)
	
	tab1=Column[{
		ManPannel["Slice Selection",{
			{"Slice (1-"<>ToString[dim[[1]]]<>")",Control@{{z,Round[dim[[1]]/2],""},1,dim[[1]],1}}
			}]
		,
		ManPannel["Plot Range",{
			{"Show background image",Control@{{pl,True,""},{True,False}}},
			{"Min value",Control@{{min,mind,""},mind,max-0.0001,(max-mind)/100, Appearance -> "Labeled"}},
			{"Max value",Control@{{max,maxd,""},min+0.0001,maxd,(maxd-min)/100, Appearance -> "Labeled"}},
			{"Min Clipping",Control@{{minclip,Black,""},ColorSlider[#,ImageSize->{Automatic,15}]&}},
			{"Max Clipping",Control@{{maxclip,White,""},ColorSlider[#,ImageSize->{Automatic,15}]&}},
			{"Transparent Clipping",Control@{{transclip,False,""},{True,False}}}
			}]
		,
		ManPannel["Plot Options",{
			{"Grid spacing",Control@{{gs,3,""},1,10,1}},
			{"Grid size",Control@{{gf,{0.003,Medium},""},{{0.001,Tiny}->"Thin",{0.003,Medium}->"Normal",{0.005,Large}->"Thick"}}},
			{"Plot Size",Control@{{ps,400,""},psizes,ControlType->PopupMenu}},
			{"Color function",Control@{{color,"BlackToWhite",""},colors,ControlType->PopupMenu}},
			{"Plot Title",Control@{{label,"",""},InputField[#,String]&}}
			}]
		,
		ManPannel["Grid Options",{
			{"Normal grid",Control@{{norm,False,""},{True,False}}},
			{"Normal grid color",Control@{{ncol,Blue,""},ColorSlider[#,ImageSize->{Automatic,15}]&}},
			{"Deformed grid",Control@{{def,False,""},{True,False}}},
			{"Deformed grid color",Control@{{dcol,Red,""},ColorSlider[#,ImageSize->{Automatic,15}]&}},
			{"Deformation gridlines",Control@{{defl,True,""},{True,False}}},
			{"Grid color",Control@{{lcol,Green,""},ColorSlider[#,ImageSize->{Automatic,15}]&}},
			{"Deformation arrows",Control@{{arr,False,""},{True,False}}},
			{"Arrow color",Control@{{acol,Black,""},ColorSlider[#,ImageSize->{Automatic,15}]&}}
			}]
		}];
	
	tab2=Column[{
		ManPannel["Export plot",{
			{"File Type",Control@{{fileType,".jpg",""},files}},
			{"Export Size",Control@{{size,400,""},sizes,ControlType->PopupMenu}},
			{"Export",Button["Save Plot",SaveImage[Dynamic[exp],FileType->fileType,ImageSize -> size],Method->"Queued",ImageSize->150]}
			}]
		}];
	
	control={{{pannel,1,""},{1->"Plotting options",2->"Exporting options"}},Delimiter,PaneSelector[{1->tab1,2->tab2},pannel]};
	
	Manipulate[
		If[!ListQ[data],Return[]];
		
		settings={{dim,dir},{min,max},label,ps,color,{gs,gf,ncol,dcol,lcol,acol},{def,norm,defl,arr,pl}};
		exp=PlotDefi[data[[z]],shift[[z]],{dim,dir},{mind,maxd,min,max},LabelFunc[label,{z}],ps,color,If[transclip,Transparent,{minclip,maxclip}],{gs,gf,ncol,dcol,lcol,acol},{def,norm,defl,arr,pl}]
		,##,
		(*Manipulate function options*)
		ControlPlacement->Right,
		Deployed->True
		]&@@control
	]


(* ::Subsection:: *)
(*MakeSliceImages*)


(* ::Subsubsection::Closed:: *)
(*MakeSliceImages*)


Options[MakeSliceImages]={PlotRange->Automatic, ColorFunction->"GrayTones", ImageLegend->False};

SyntaxInformation[MakeSliceImages]={"ArgumentsPattern"->{_,_.,_.,OptionsPattern[]}};

MakeSliceImages[selData_,opts:OptionsPattern[]]:=MakeSliceImages[selData,{1,1,1},opts]

MakeSliceImages[selData_,{selMask_,vals_?ListQ},opts:OptionsPattern[]]:=MakeSliceImages[selData,{selMask,vals},{1,1,1},opts]

MakeSliceImages[selData_,vox:{_,_,_},opts:OptionsPattern[]]:=MakeSliceImages[selData,{0,{}},vox,opts]

MakeSliceImages[selData_,{selMask_,vals_?ListQ},vox:{_,_,_},OptionsPattern[]]:=Block[{pdat,ran,ratio,datf,size,colF,mdat,rule,bar,pl1,pl2},

rule=Thread[N[vals]->Range[Length[vals]]];
colo=OptionValue[ColorFunction];

colF = If[
	MemberQ[gradsets, colo],ColorData[colo][#]&,
	If[MemberQ[custColors[[All,1]],colo],
		colo/.custColors,colo]
		];

Table[

(*get the data*)
pdat=N@selData[[n]];
mdat=N@If[selMask=!=0,N[selMask[[n]]]/.rule,0 pdat];

(*find the range*)
datf=DeleteCases[Flatten[pdat][[;;;;10]],0.];
ran=If[OptionValue[PlotRange]===Automatic,If[datf==={},{0,1},{0,Quantile[DeleteCases[Flatten[pdat][[;;;;10]],0.],.9]}],OptionValue[PlotRange]];

size=vox[[{{2,3},{1,2},{1,3}}[[n]]]];
bar=BarLegend[{colF/@Range[0,1,.01],ran},LabelStyle->Directive[{Black,Bold,12}]];

(*loop over the slices, 1 axial, 2 cor, 3 sag*)
MapThread[(
ratio=Divide@@(Dimensions[#]size);

pl1=ArrayPlot[#1,AspectRatio->ratio,Frame->False,ImageSize->400,PlotRangePadding->1, PlotRange->ran,ColorFunction->colF,ClippingStyle->(colF/@{0,1})];

pl2=ArrayPlot[#2,ColorFunction->(Directive[{Opacity[0.4],ColorData["Rainbow"][#]}]&),ColorRules->{0.->Transparent}];

If[OptionValue[ImageLegend],Legended[Show[pl1,pl2],bar],Show[pl1,pl2]]

)&,{pdat,mdat}]
,{n,1,3}]
]


(* ::Subsubsection::Closed:: *)
(*GetSliceData*)


SyntaxInformation[GetSliceData]={"ArgumentsPattern"->{_,_,_.}};

GetSliceData[data_,offsets_]:=GetSliceData[data,offsets,{1,1,1}]

GetSliceData[data_,offsets_,vox_]:=Block[{off},
	off=Round[offsets/vox];
	{data[[off[[1]]]],
	Reverse/@Transpose@data[[All,off[[2]]]],
	Reverse/@Transpose[data[[All,All,off[[3]]]],{2,3,1}]
	}
]


(* ::Subsubsection::Closed:: *)
(*GetSlicePosision*)


Options[GetSlicePositions]={ MakeCheckPlot->False, DropSlices->{1,1,1}, PeakNumber->{1,1,2}};

SyntaxInformation[GetSlicePositions]={"ArgumentsPattern"->{_,_.,OptionsPattern[]}};

GetSlicePositions[data_, opts:OptionsPattern[]]:=GetSlicePositions[data, {1,1,1},opts]

GetSlicePositions[data_, vox_, OptionsPattern[]]:=Block[{dat,peaks,len,fil,ran,pers,min,max,minmax,result,num},
	(*get the max intensity slice*)
	pers={{2,3,1},{1,3,1},{1,2,1}};
	result=(
	dat=MeanNoZero@Flatten[data,pers[[#,1;;2]]];
	len=Length[dat];
	fil=Clip[len/30,{2,Infinity}];
	ran=OptionValue[DropSlices][[#]];
	num=OptionValue[PeakNumber][[#]];
	{min,max}=MinMax[dat];
	minmax=(min+0.5(max-min));
	dat[[;;ran]]=min;
	dat[[-ran;;]]=min;
	dat=GaussianFilter[dat,fil];
	peaks=FindPeaks[dat,fil];
	minmax=(Min[dat]+0.5(Max[dat]-Min[dat]));
	peaks=Select[peaks,#[[2]]>minmax&];
	{dat,peaks,peaks[[;;num]],peaks[[;;num,1]]}
	)&/@{1,2,3};
	(*make chekc plot*)
	If[OptionValue[MakeCheckPlot],Print[Row[Show[
	ListLinePlot[#[[1]],PlotStyle->Black],
	ListPlot[#[[2]],PlotStyle->Directive[{PointSize[Large],Red}]],
	ListPlot[#[[3]],PlotStyle->Directive[{PointSize[Large],Green}]]
	,Axes->True,ImageSize->200]&/@result]]
	];
	vox result[[All,-1]]
]


(* ::Subsection:: *)
(*General Plot Functions*)


(* ::Subsubsection::Closed:: *)
(*PlotCorrection*)


SyntaxInformation[PlotCorrection] = {"ArgumentsPattern" -> {_}};

PlotCorrection[w_]:=Module[{sel},
	Switch[
		Dimensions[w][[2]],
		6,
		GraphicsGrid[Partition[MapThread[
		ListPlot[#1,PlotRange->Full,Joined->True,PlotLabel->Style[#2,Bold],AspectRatio->.5,PlotStyle->Thick]&,
		{
			(({1,1,1,1,1,1}*Transpose[w])+{0,0,0,0,0,0})[[#]]&/@{1,2;;3,4;;5,6},
			{"Rotation [Degree]","Translation [mm]","Scale","Scew "},
			{{-3,3},{-4,4},{.95,1.05},{-.05,.05}}
			}],2],ImageSize->600]
		,
		12,
		sel=If[Mean[w][[7;;12]]==={1.,1.,1.,0.,0.,0.},2,4];
		
		Grid[Partition[
			MapThread[
				ListLinePlot[#1, PlotLabel -> Style[#2, Bold], PlotLegends -> #3,
					PlotRange -> {{1,Length[#1[[1]]]},Full},AxesOrigin->{1,Mean[#4]}, AspectRatio -> .5, PlotStyle -> (Directive[{Thick,#}]&/@{Red,Green,Blue}),
					AxesStyle->Directive[{Thick,Black}],LabelStyle->Directive[{Bold,Black,FontFamily->"Helvetica"}],
					ImageSize -> 400, AxesOrigin -> #5
					] &, {
						({1, 1, 1, 1}*Partition[Transpose[w], 3]) + {0, 0, 0, 0},
						{"Rotation [Degree]", "Translation [mm]", "Scale", "Scew "},
						{{"Coronal axis (roll)", "Sagital axis (pitch)","Axial axis (yaw)"},
						{"Coronal direction", "Sagital direction", "Axial direction"},
						{"Coronal direction", "Sagital direction", "Axial direction"},
						{"Coronal direction", "Sagital direction", "Axial direction"}},
						{{-3, 3}, {-4, 4}, {.95, 1.05}, {-.05, .05}},
						{{0, 0}, {0, 0}, {0, 1}, {0, 0}}
					}[[All,;;sel]]], 2]]
		]
]


(* ::Subsubsection::Closed:: *)
(*PlotContour*)


Options[PlotContour] = {ContourStyle -> {Gray, 0.25}};

SyntaxInformation[PlotContour] = {"ArgumentsPattern" -> {_, _, _., _., OptionsPattern[]}}; 

PlotContour[data_, voxi_, opts:OptionsPattern[]] := PlotContour[data, voxi, {0}, 0, opts]

PlotContour[data_, voxi_, scaleI_?ArrayQ, opts:OptionsPattern[]] := PlotContour[data, voxi, scaleI, {0}, opts]

PlotContour[data_, voxi_, scaleI_?ArrayQ, range_, OptionsPattern[]] :=  Block[{
	vox, pdata, dim, color, opac, style, scale, mean, func},
  
  (*prepare data*)
  vox = Reverse[voxi];
  pdata = ArrayPad[data, 1];
  dim = Reverse@Dimensions[pdata];
  
  color = OptionValue[ContourStyle];
  {color, opac} = If[ColorQ[color], {color, 0.25}, color];
  
  (*create a plot scale if needed*)
  style = If[scaleI === {0},
    Directive[{Opacity[opac], color, Specularity[Lighter@color, 5]}],
    GrayLevel[1]
    ];
  
  (*create a colorfunction if needed*)
  func = If[scaleI =!= {0},
    (*get the scaling*)
    scale = ArrayPad[scaleI, 1];
    mean = If[range === 0,
      Quantile[DeleteCases[N@Flatten[data scaleI], 0.], .95]
      ,
      range
      ];
    scale = scale/(mean);
    Function[{x, y, z}, ColorData["SunsetColors"][scale[[Ceiling[z], Ceiling[y], Ceiling[x]]]]]
    ,
    Automatic
    ];
  
  Quiet@ListContourPlot3D[pdata,
   Contours -> 1, BoxRatios -> dim vox, PlotRange -> Thread[{{0, 0, 0} - 5, dim + 2 + 5}], ContourStyle -> style, ColorFunction -> func, Mesh -> False, 
   Lighting -> "Neutral", MaxPlotPoints -> Round[Max[dim]/3], ColorFunctionScaling -> False, SphericalRegion -> True, ImageSize -> 300, PerformanceGoal -> "Speed", Axes -> False
   ]
  ]


(* ::Subsubsection::Closed:: *)
(*ListSpherePlot*)


Options[ListSpherePlot] = {SphereSize->2, SphereColor->Automatic}

SyntaxInformation[ListSpherePlot] = {"ArgumentsPattern" -> {_, OptionsPattern[]}};  

ListSpherePlot[ptsi_, OptionsPattern[]] := Module[{cols, graphics, pt, pc, ran, len,coli,size},
 	coli = OptionValue[SphereColor];
 	size = OptionValue[SphereSize];
 	
  len = Length[ptsi];
  ran = RandomSampleFix[len];
  cols = If[coli === Automatic,
    (ColorData[1] /@ N[Range[1, len]])[[ran]],
    ConstantArray[coli, len]
    ];
  cols = cols;
  graphics = MapThread[(pt = #1; pc = #2;
      If[ArrayDepth[pt] == 1,
       {pc, Sphere[pt, size]},
       {pc, Sphere[#, size]} & /@ pt
       ]) &, {ptsi, cols}];
  Graphics3D[Flatten[graphics], Lighting -> "Neutral"]
  ]

RandomSampleFix[len_] := RandomSampleFix[len] = RandomSample[Range[len]];


(* ::Subsubsection::Closed:: *)
(*PlotDuty*)


SyntaxInformation[PlotDuty] = {"ArgumentsPattern" -> {{_,_,_},_.}};

PlotDuty[{grad_, bval_, ord_}, mode_:True] := 
 Module[{grads, order, testgr, mn, ran},
  grads = Abs[grad*Sqrt[bval]];
  grads = If[NumberQ[bval], grads, Flatten[grads, 1]];
  grads = (grads - Min[grads])/(Max[grads] - Min[grads]);
  ran = MinMax[grads];
  order = If[! mode, Range[Length[grads]], ord];
  testgr = Mean[Transpose[Partition[#, 10, 1]]] & /@ Transpose[grads[[order]]];
  mn = Max /@ Transpose@testgr;
  Show[
   ListLinePlot[testgr, PlotLabel -> "Average Gradient Load", 
    AxesStyle -> Directive[{Thick, Black}],
    LabelStyle -> 
     Directive[{Black, Bold, 12, FontFamily -> "Helvetica"}],
    Ticks -> {Automatic, {{0.1, "Min G"}, {.55, "Avrg. G"}, {1, 
        "Max G"}}}, PlotRange -> {0, 1},
    GridLines -> {None, {00.1, 0.55, 
       1, {Max@mn, Directive[Red, Thick]}}}
    ],
   ListLinePlot[mn, PlotStyle -> Directive[Black, Dashed, Thick]]
   ]
  ]
  



(* ::Subsubsection::Closed:: *)
(*GradientPlot*)


Options[GradientPlot] = {PlotSpace -> "bspace", PlotColor -> "Auto", SphereSize -> 0.05 , PositiveZ -> False};

SyntaxInformation[GradientPlot] = {"ArgumentsPattern" -> {_, _., OptionsPattern[]}};

(*GradientPlot[bmat_,opts:OptionsPattern[]]:=Block[{vec,val},
	{val,vec}=BmatrixInv[bmat];
	GradientPlot[vec,val,opts]]*)

GradientPlot[veci_, val_, OptionsPattern[]] := 
 Block[{pts, range, norm, mnorm, cnorm, col, pcol, vec}, 
 	
  vec = If[OptionValue[PositiveZ],
  	Sign2[#[[3]]]#&/@veci,
  	veci
  ];
  
  pts = Switch[OptionValue[PlotSpace], 
  	"bspace", vec val, 
  	"qspace", vec Sqrt[val]
  	];
  norm = Norm /@ pts;
  mnorm = Max[Abs[pts]];
  cnorm = norm/(1.25 Max[norm]);
  
  range = ConstantArray[{-1.1, 1.1} mnorm, 3];
  col = OptionValue[PlotColor];
  
  pcol = If[MemberQ[ColorData["Gradients"], col],
    ColorData[col],
    If[ColorQ[col],
     col &,
     ColorData["SunsetColors"]
     ]
    ];
  
  Graphics3D[MapThread[
    {pcol[#2], Sphere[#1, OptionValue[SphereSize] mnorm]} &,
    {pts, cnorm}], ImageSize -> 400, BoxStyle -> Thick, 
   SphericalRegion -> True, Lighting -> "Neutral", BoxRatios -> 1, 
   PlotRange -> range]]
  
  Sign2[dat_]:=Sign[Sign[dat] + 0.0001];


(* ::Subsubsection::Closed:: *)
(*PlotMoments*)


SyntaxInformation[PlotMoments] = {"ArgumentsPattern" -> {_, _, _}};

PlotMoments[fmom_, te_, t_] := Module[{
   plab, rlab, cols, alabs, grnr, fun, max, len, sc, lens
   },
  
  plab = {"Gx", "Gy", "Gz"};
  rlab = {"Gradients", "Zeroth order moment", "First order moment", "Second order moment", "Third order moment"};
  cols = {Black, Red, Purple, Blue, Green};
  alabs = {
    "mT \!\(\*SuperscriptBox[\(m\), \(-1\)]\)",
    "mT \!\(\*SuperscriptBox[\(m\), \(-1\)]\) \!\(\*SuperscriptBox[\(ms\), \(-1\)]\)",
    "mT \!\(\*SuperscriptBox[\(m\), \(-1\)]\) \!\(\*SuperscriptBox[\(ms\), \(-2\)]\)",
    "mT \!\(\*SuperscriptBox[\(m\), \(-1\)]\) \!\(\*SuperscriptBox[\(ms\), \(-3\)]\)",
    "mT \!\(\*SuperscriptBox[\(m\), \(-1\)]\) \!\(\*SuperscriptBox[\(ms\), \(-4\)]\)"
    };
  
  plots = MapIndexed[(
     grnr = #2[[1]];
     Column[
      Prepend[MapIndexed[(
          fun = #1;
          max = Max[Abs[Table[fun, {t, 0, te, .25}]]];
          len = IntegerLength[Round[max]] - 1;
          
          If[len <= 1,
           sc = 1;
           lens = "";
           ,
           sc = 10^len;
           lens = ToString[Superscript[10, len], StandardForm];
           ];
          
          Plot[fun/sc, {t, -.1 te, 1.5 te}, 
           PlotRange -> {{0, te}, 1.1 {-max, max}/sc}, 
           Exclusions -> None,
           AspectRatio -> .15, ImageSize -> 800, 
           PlotStyle -> Directive[{cols[[grnr]], Thick}],
           AxesLabel -> {"ms", lens <> " " <> alabs[[grnr]]}, 
           PlotLabel -> plab[[#2[[1]]]], 
           LabelStyle -> Directive[Black, Bold, FontFamily -> "Arial"]]
          ) &, #1],
       Style[rlab[[grnr]], Directive[Black, Bold, FontFamily -> "Arial"]]],
      Alignment -> Center]
     ) &, fmom];
     
     Manipulate[
     	pl=plots[[(n+1)]],
     	
     	 {{n,0,"Moment"}, 0, Length[plots]-1, 1},
     	 Button["Save Image",SaveImage[pl], Method -> "Queued"]
     	 ]
  ]


(* ::Subsubsection::Closed:: *)
(*PlotIVIM*)


Options[PlotIVIM] = {Method -> "", PlotColor -> {Red, Green, Blue, Black}, NormalizeIVIM->"Fit",PlotRange->"Auto",ImageSize->400}

SyntaxInformation[PlotIVIM] = {"ArgumentsPattern" -> {_, _, _, OptionsPattern[]}};

PlotIVIM[val_, data_, bvals_, OptionsPattern[]] := 
 Module[{pdat, pdatL, rule, stdash, stsol, lstyle, pl, vals = val, 
   func, cols, S0, f1, dc, pdc1, f2,f3, pdc2, bm,plr},
  DynamicModule[{plot},
   cols = OptionValue[PlotColor];
   cols = If[Length[cols] != 4, {Red,Darker@ Green, Blue, Black}, cols];
   
   If[OptionValue[NormalizeIVIM]==="Fit",
   pdatL = {bvals, Log[data/vals[[1]]]} // Transpose;
   pdat = {bvals, data/vals[[1]]} // Transpose;
   vals[[1]] = 1;
   ,
   pdatL = {bvals, Log[data/data[[1]]]} // Transpose;
   pdat = {bvals, data/data[[1]]} // Transpose;
   vals[[1]] = vals[[1]]/data[[1]];
   ];
   
   stdash = Directive[{Thick, #, Dashed}] &;
   stsol = Directive[{Thick, #}] &;
   lstyle = Directive[Black, Bold, If[OptionValue[ImageSize]<=200,Small,Medium], FontFamily -> "Helvetica"];
   
   Switch[Length[vals],
   	2,
    func = S0(f3*Exp[-bm*dc]);
 	rule = Flatten@Append[Thread[{S0, dc} -> vals], {f2 -> 0,f1->0}];,
    4,
    func = S0(f3*Exp[-bm*dc] + f1*Exp[-bm*pdc1]);
 	rule = Append[Thread[{S0, f1, dc, pdc1} -> vals], f2 -> 0];,
    6,
    func = S0(f3*Exp[-bm*dc] + f1*Exp[-bm*pdc1] + f2*Exp[-bm*pdc2]);
    rule = Thread[{S0, f1, f2, dc, pdc1, pdc2} -> vals];,
    _,
    Return[Message[PlotIVIM::vals]]];
   
   plr=If[OptionValue[PlotRange]==="Auto",{1.2 Min[pdatL[[All,2]]], 0.1},OptionValue[PlotRange]];
   
   pl = Plot[#6 /. {f1 -> #1, f2 -> #2, f3->#3} /. rule, {bm, -0.1, #5}, 
      PlotStyle -> ({stdash[#4[[1]]], stsol[#4[[1]]]}[[#4[[2]]]]), 
      PlotRange -> ({{0, 1.1}, plr }[[#7]]), 
      LabelStyle -> lstyle, Frame -> {{True, False}, {True, False}}, 
      FrameStyle -> Thick, ImageSize -> OptionValue[ImageSize], 
      FrameLabel -> {"b-value [\!\(\*SuperscriptBox[\(mm\), \(2\)]\)/s]", {"Signal", "Log[Signal]"}[[#7]]}] &;
      
   plot = GraphicsRow[{
       Show[
        pl[f1, f2, 1-f1-f2, {cols[[4]], 2}, #, func, 1],
        pl[1-f2, 0, 0, {cols[[1]], 1}, #, func, 1],
        pl[0, 1, 0, {cols[[2]], 1}, #, func, 1],
        pl[0, 0,  1-f1-f2, {cols[[3]], 1}, #, func, 1],
        ListPlot[pdat, PlotStyle -> {cols[[4]], PointSize[0.02]}]
       ],
       Show[
        pl[f1, f2, 1-f1-f2, {cols[[4]], 2}, #, Log[func], 2],
        pl[1-f2, 0, 0, {cols[[1]], 1}, #, Log[func], 2],
        pl[0, 1, 0, {cols[[2]], 1}, #, Log[func], 2],
        pl[0, 0, 1-f1-f2, {cols[[3]], 1}, #, Log[func], 2],
        ListPlot[pdatL, PlotStyle -> {cols[[4]], PointSize[0.02]}]
        ]
       }] &;
   
   If[OptionValue[Method] === "Dynamic",
    Manipulate[plot[bran],{{bran, 1.1 Max[bvals], "Plot Range"}, 10, 1.5 Max[bvals], 10},SaveDefinitions -> True],
    plot[Max[bvals]]
    ]
   ]
  ]


(* ::Subsubsection::Closed:: *)
(*PlotSequence*)


SyntaxInformation[PlotSequence] = {"ArgumentsPattern" -> {_, _}};

PlotSequence[(*{seq_,hw_,te_}*)inp_, t_] := DynamicModule[{
	hw1, Gx, Gy, Gz, seq2, len, pdat, seq, te, start, stop, x, clip, plots
	},
  
  {len, pdat} = If[Dimensions[inp] === {3}, {1, {inp}}, {Length[inp], inp}];
  te = Last@First@pdat;
  hw1 = Piecewise[{{1, t <= te}, {0, t > te}}];
  seq = {PiecewiseExpand[#[[1]]], PiecewiseExpand[hw1 #[[1]]]} & /@ pdat;
  
  plots = Map[(
      seq2 = #;
      Plot[seq2[[#]],
         {t, -0.5 te, 1.5 te}, PlotRange -> {-100, 100}, 
         PlotStyle -> {Thick, Black}, Exclusions -> None,
         AspectRatio -> .15, ImageSize -> 1000, 
         PlotPoints -> Round[te/.25],
         Axes -> False, Frame -> True, 
         FrameTicks -> {{None, None}, {Range[0, 150, 10], None}},
         PlotLabel -> {"Gx", "Gy", "Gz"}[[#]], 
         LabelStyle -> {FontFamily -> "Helvetica", Bold},
         GridLines -> {{{0, Directive[Red, Thick]}, {te/2, 
             Directive[Red, Thick]}, {te, 
             Directive[Red, Thick]}}, {0}}] & /@ Range[3]
      ) &, seq, {2}];
  
  Manipulate[
   
   Column[(Show[plots[[x, clip, #]], PlotRange -> ({{start, stop}, {{-Gx, Gx}, {-Gy, Gy}, {-Gz, Gz}}[[#]]})]) & /@ Range[3]],
   
   {{x, 1, "Sequence"}, 1, len, 1, Appearance -> "Labeled"},
   {{clip, 1, "Clip the te"}, {1 -> "False", 2 -> "True"}},
   
   {{Gx, 90, "Gx"}, 5, 100, 10, Appearance -> "Labeled"},
   {{Gy, 90, "Gy"}, 5, 100, 10, Appearance -> "Labeled"},
   {{Gz, 90, "Gz"}, 5, 100, 10, Appearance -> "Labeled"},
   
   {{start, Round[-0.07 te], "Time start"}, Round[-0.07 te], Round[.5 te], Appearance -> "Labeled"},
   {{stop, Round[1.15 te], "Time end"}, Round[0.5 te], Round[1.20 te], Appearance -> "Labeled"}
   ]
]


(* ::Section:: *)
(*End Package*)


End[]

EndPackage[]
