(* ::Package:: *)

(* ::Title:: *)
(*QMRITools ElastixTools*)


(* ::Subtitle:: *)
(*Written by: Martijn Froeling, PhD*)
(*m.froeling@gmail.com*)


(* ::Section:: *)
(*Begin Package*)


BeginPackage["QMRITools`ElastixTools`", Join[{"Developer`"}, Complement[QMRITools`$Contexts, {"QMRITools`ElastixTools`"}]]];


(* ::Section:: *)
(*Usage Notes*)


(* ::Subsection::Closed:: *)
(*Functions*)


RegisterData::usage =
"RegisterData[data] registers the data series. If data is 3D it performs multiple 2D registration, if data is 4D it performs multipe 3D registration. The target is the first image orvolume in the series.
RegisterData[{data, vox}] registers the data series using the given voxel size.
RegisterData[{data, mask}] registers the data series only using data whithin the mask.
RegisterData[{data, mask, vox}] registers the data series using the given voxel size only using data within the mask.

RegisterData[target, moving] registers the moving data to the target data. target can be 2D or 3D. moving can be the same of one dimension higher than the target.
RegisterData[{target, mask, vox},{moving, mask, vox}] registers the data using the given voxel size only using data within the mask.
RegisterData[{target, vox}, moving] registers the data using the given voxel size.
RegisterData[target, {moving, vox}] registers the data using the given voxel size.
RegisterData[{target, vox}, {moving, vox}] registers the data using the given voxel size.

RegisterData[{target, mask}, moving] registers the data series only using data whithin the mask.
RegisterData[target, {moving, mask}] registers the data series only using data whithin the mask.
RegisterData[{target, mask}, moving] registers the data series only using data whithin the mask.
RegisterData[{target, mask}, {moving, mask}] registers the data series only using data whithin the mask.

RegisterData[target, {moving, mask, vox}] registers the data series using the given voxel size only using data within the mask.
RegisterData[{target, mask}, {moving, mask, vox}] registers the data series using the given voxel size only using data within the mask.
RegisterData[{target, vox}, {moving, mask, vox}] registers the data series using the given voxel size only using data within the mask.
RegisterData[{target, mask, vox}, moving] registers the data series using the given voxel size only using data within the mask.
RegisterData[{target, mask, vox}, {moving, mask}] registers the data series using the given voxel size only using data within the mask.
RegisterData[{target, mask, vox}, {moving, vox}] registers the data series using the given voxel size only using data within the mask.
RegisterData[{target, mask}, {moving, vox}] registers the data series using the given voxel size only using data within the mask.
RegisterData[{target, vox}, {moving, mask}] registers the data series using the given voxel size only using data within the mask.

Output is the registered data with the dimensions of the moving data. 
If OutputTransformation is True it also outputs the translation, rotation scale and skew of all images or volumes.

RegisterData[] is based on DOI: 10.1109/TMI.2009.2035616 and 10.3389/fninf.2013.00050."

RegisterDataSplit::usage = 
"RegisterDataSplit[target, moving] is identical to RegisterData data however left and right side of the data are registered seperately.

Splitting the data is done using the function CutData and merged wit Stich data.
Output is the registered data."


TransformData::usage = 
"TransformData[{data,vox}] deforms the data according to the last output of register data.
The directory should be the TempDirectory were the registration is stored. DeleteTempDirectory should be False."

ReadTransformParameters::usage = 
"ReadTransformParameters[directory] reads the tranfomation parameters generated by RegisterData. The directory should be the TempDirectory were the registration is stored. DeleteTempDirectory should be False.

Output is the affine transformation vector per volume."


RegisterDataTransform::usage = 
"RegisterDataTransform[target, moving, {moving2nd, vox}] performs the registration exactly as RegisterData. target and moving are the inputs for Registerdata, which can be {data,mask,vox}.
After the registeration is done the moving2nd data is deformed acording to the output of the registrtion of moving.

moving2nd can have the same dimensions of moving or one dimension higher (e.g. 3D and 3D or 3D and 4D). 

Output is {registered moving, deformed moving2nd}."

RegisterDataTransformSplit::usage = 
"RegisterDataTransformSplit[target, moving, {moving2nd, vox}] is idenditcal to RegisterDataTransform with the same functionality as RegisterDataSplit.
This means the data is split in two using the function CutData and merged wit Stich data.

Output is {registered moving, deformed moving2nd}."


RegisterDiffusionData::usage =
"RegisterDiffusionData[{dtidata, vox}] registers a diffusion dataset. dtidata should be 4D {slice, diff, x, y}. vox is the voxelsize of the data.
RegisterDiffusionData[{dtidata, dtimask, vox}] registers the data series using the given voxel size only using data within the mask.
RegisterDiffusionData[{dtidata ,vox}, {anatdata, voxa}] registers a diffusion dataset. The diffusion data is also registered to the anatdata.
RegisterDiffusionData[{dtidata, dtimask, vox}, {anatdata, voxa}] registers the data series using the given voxel size only using data within the mask.
RegisterDiffusionData[{dtidata,vox}, {anatdata, anatmask, voxa}] registers the data series using the given voxel size only using data within the mask.
RegisterDiffusionData[{dtidata, dtimask, vox}, {anatdata, anatmask, voxa}] registers the data series using the given voxel size only using data within the mask.

Output is the registered dtidata and, if anatdata is given, the registered dtidata in anatomical space. If OutputTransformation is True it also outputs the translation, rotation scale and skew of all images or volumes."

RegisterDiffusionDataSplit::usage = 
"RegisterDiffusionDataSplit[dtidata, vox] is identical to Register diffusion data however left and right side of the data are registered seperately.
RegisterDiffusionDataSplit[{dtidata, vox}, {anatdata, voxa}] is identical to Register diffusion data however left and right side of the data are registered seperately.
RegisterDiffusionDataSplit[{dtidata, dtimask, vox}, {anatdata, anatmask, voxa}] is identical to Register diffusion data however left and right side of the data are registered seperately.

Splitting the data is done using the function CutData and merged wit Stich data.
Output is the registered data."


RegisterCardiacData::usage =
"RegisterCardiacData[data] registers the data using a 2D algorithm. data can be 3D or 4D.  
RegisterCardiacData[{data,vox}] registers the data series using the given voxel size.
RegisterCardiacData[{data,mask}] registers the data series only using data whithin the mask.
RegisterCardiacData[{data,mask,vox}] registers the data series using the given voxel size only using data within the mask.

Output is the registered data."


(* ::Subsection::Closed:: *)
(*Options*)


Iterations::usage =
"Iterations is an options for RegisterData, RegisterDiffusionData, and RegisterDataTransform. 
It specifies the number of iterations used by the registration functions."

Resolutions::usage =
"Resolutions is an options for RegisterData, RegisterDiffusionData, and RegisterDataTransform. 
It specifies the number of scale space resolutions used by the registration functions."

HistogramBins::usage =
"HistogramBins is an options for RegisterData, RegisterDiffusionData, and RegisterDataTransform. 
It specifies the number of bins of the joined histogram used by the registration functions."

NumberSamples::usage =
"NumberSamples is an options for RegisterData, RegisterDiffusionData, and RegisterDataTransform. 
It specifies the number of random samples that are taken each iteration used by the registration functions."

OutputImage::usage =
"OutputImage is an options for RegisterData, RegisterDiffusionData, and RegisterDataTransform. 
It specifies if the result image should be writen in the TempDirectory as nii file."

InterpolationOrderReg::usage =
"InterpolationOrderReg is an options for RegisterData, RegisterDiffusionData, and RegisterDataTransform. 
It specifies the interpolation order used in the registration functions."

MethodReg::usage = 
"MethodReg is an options for RegisterData, RegisterDiffusionData, RegisterCardiacData and RegisterDataTransform. 
It spefifies which registration method to use. 
Mehtods can be be \"translation\", \"rigid\", \"affine\", \"bspline\", \"rigidDTI\", \"affineDTI\", \"PCAtranslation\", \"PCArigid\", \"PCAaffine\", or \"PCAbspline\"."

BsplineSpacing::usage =
"BsplineSpacing is an options for RegisterData, RegisterDiffusionData, RegisterCardiacData and RegisterDataTransform. 
It specifies the spacing of the bsplines if the method is \"bspline\"."

TempDirectory::usage = 
"TempDirectory is an options for RegisterData, RegisterDiffusionData, RegisterCardiacData and RegisterDataTransform. 
It specifies the temprary directory used to perform and output the registration."

DeleteTempDirectory::usage =
"DeleteTempDirectory an options for RegisterData, RegisterDiffusionData, RegisterCardiacData and RegisterDataTransform. 
It specifies if the temp directory should be deleted after the registration is finisched."

PrintTempDirectory::usage = 
"PrintTempDirectory is an options for RegisterData, RegisterDiffusionData, RegisterCardiacData and RegisterDataTransform. 
It spefifies if the location of the temp directory should be deplayed."

RegistrationTarget::usage = 
"RegistrationTarget is an option for RegisterDiffusionData and RegisterCardiacData. Specifies which target to uses for registration if using \"rigid\", \"affine\" or \"bspline\" as MethodReg.
If the MethodReg is \"PCA\" based it does not need a target and this options does nothing. 
Values can be \"First\", \"Mean\" or \"Median\"."

BsplineDirections::usage = 
"BsplineDirections is an option for RegisterData ad RegisterDiffusionData. 
It gives the direction in which the bsplines are allowed to move when registering diffusion data to anatomical space."

AffineDirections::usage = 
"AffineDirections is an option for RegisterData ad RegisterDiffusionData. 
It gives the directions in which data can be moved when registering diffusion data to anatomical space."

OutputTransformation::usage =
"OutputTransformation is an option for RegisterData ad RegisterDiffusionData.
It specifies if the tranformation paramters (translation, rotation, scale and skew) should be given as output in the registration functions."

IterationsA::usage = 
"IterationsA is an option for RegisterDiffusionData. 
It specifies the number of iterations used when registering diffusion data to anatomical space."

ResolutionsA::usage =
"ResolutionsA is an option for RegisterDiffusionData.
It specifies the number of scale space resolutions used when registering diffusion data to anatomical space."

HistogramBinsA::usage =
"HistogramBinsA is an option for RegisterDiffusionData.
It specifies the number of bins of the joined histogram used when registering diffusion data to anatomical space."

NumberSamplesA::usage =
"NumberSamplesA is an option for RegisterDiffusionData.
It specifies the number of random samples that are taken each iteration when registering diffusion data to anatomical space."

InterpolationOrderRegA::usage =
"InterpolationOrderRegA is an option for RegisterDiffusionData.
It specifies the interpolation order used in the registration functions when registering diffusion data to anatomical space."
 
MethodRegA::usage =
"MethodRegA is an option for RegisterDiffusionData.
It spefifies which registration method to use when registering diffusion data to anatomical space. Mehtods can be be \"rigid\",\"affine\" or \"bspline\"."

UseGPU::usage = 
"UseGPU is an option for RegisterData. The value is {bool, gpu} where bool is True or False, and gpu is the gpu ID which is an integer or Automatic."

PCAComponents::usage = 
"PCAComponents is an option for RegisterData. It speciefies how many PCA components are used if method is set to \"PCA\""

FindTransform::usage = 
"FindTransform is an option for TransformData and RegisterTransformData. It specifies where to find the transformfile."

SplitMethod::usage = 
"SplitMethod is an option for RegisterDataSplit and RegisterDataTransformSplit. values can be \"mean\", \"moving\", \"target\""


(* ::Subsection::Closed:: *)
(*Error Messages*)


RegisterData::vol="The `1`D datasets should have 2 or more volumes, it has `2` volumes."

RegisterData::dim="Datasets should both be 2D or 3D, or 2D and 3D, or 3D and 4D, current datasets are `1`D and `2`D."

RegisterData::dims="Dataset should be 3D or 4D, current dataset is `1`D."

RegisterData::vox="voxel size should be {z,x,y} and numeric, current sizes are `1` and `2`."

RegisterData::voxs="voxel size should be {z,x,y} and numeric, current size is `1`."

RegisterData::met="MethodReg should be \"translation\", \"rigid\", \"affine\", \"bspline\", \"rigidDTI\", \"affineDTI\", \"PCAtranslation\", \"PCArigid\", \"PCAaffine\", or \"PCAbspline\", current method is `1`."

RegisterData::metc="If the MethodReg is \"cyclyc\" no target can be given."

RegisterData::mask="The mask dimensions `1` should be equal to the data dimensions `2`."

RegisterData::dir="Temporary directory not created."

RegisterData::elastix="Elastix not found, check if QMRITools is installed in the $BaseDirectory or $UserBaseDirectory."

RegisterData::par="`1` should be a number or a list of numbers with length `2`."

RegisterData::fatal="Fatal error encountered."


(* ::Section:: *)
(*Functions*)


Begin["`Private`"]


(* ::Subsection::Closed:: *)
(*Support Functions*)


operatingSystem = $OperatingSystem;

QMRITools`ElastixTools`$debugElastix = If[QMRITools`ElastixTools`$debugElastix===True, True, False];


(* ::Subsubsection::Closed:: *)
(*ParString*)


ListToString[list_, add_: ""] := StringTrim[StringJoin[Riffle[ToString /@ list, " "]] <> " " <> add]

SchedulePar[res_, dtar_] := ListToString[ListToString[2.^ConstantArray[#, dtar - 1], "0.0"] & /@ Reverse[Range[res] - 1]]

DerivativePar[par_, dtar_, add_: ""] := ListToString[Reverse[par[[-dtar ;;]]], add]

ParString[{itterations_, resolutions_, bins_, samples_, intOrder_}, {type_, output_}, {dtar_, grid_, derscB_, derscA_, pca_}, {openCL_, gpu_}]:=(
"// ***************************************************************
// ** "<>type<>" **


// ** fixed general settings **
// ***************************************************************
(FixedInternalImagePixelType \"float\")
(MovingInternalImagePixelType \"float\")
(UseDirectionCosines \"true\")

(DefaultPixelValue 0)
(WriteTransformParametersEachIteration \"false\")
(ResultImageFormat \"nii.gz\")
(ResultImagePixelType \"float\")

(ErodeMask \"false\")
(ErodeFixedMask \"false\")

(Registration \"MultiResolutionRegistration\")

(ImageSampler \"RandomCoordinate\")
(CheckNumberOfSamples \"false\")
(NewSamplesEveryIteration \"true\")
(MaximumNumberOfSamplingAttempts 5)

(HowToCombineTransforms \"Compose\")

(Optimizer \"AdaptiveStochasticGradientDescent\")
(ASGDParameterEstimationMethod \"Original\")
(AutomaticParameterEstimation \"true\")
(AutomaticTransformInitialization \"true\")

"<>If[openCL,
(*check to uses openCL needs custom compile of elastix*)
"(OpenCLDeviceID \""<>ToString[gpu]<>"\")
(Resampler \"OpenCLResampler\")
(OpenCLResamplerUseOpenCL \"true\")
(FixedImagePyramid \"OpenCLFixedGenericImagePyramid\")
(OpenCLFixedGenericImagePyramidUseOpenCL \"true\")
(MovingImagePyramid \"OpenCLMovingGenericImagePyramid\")
(OpenCLMovingGenericImagePyramidUseOpenCL \"true\")"
,
"(Resampler \"DefaultResampler\")
(FixedImagePyramid \"FixedGenericImagePyramid\")
(MovingImagePyramid \"MovingGenericImagePyramid\")"
]<>"
// ***************************************************************


// ** setting specific for PCA or non PCA methods **
// ***************************************************************
"<>Which[(*if PCA uses stack transform*)
	(*PCA based methods*)
	type==="PCAtranslation"||type==="PCArigid"||type==="PCAaffine"||type==="PCAbspline",
"(Metric \"PCAMetric2\")
(NumEigenValues "<>ToString[pca]<>")
(SubtractMean \"true\")

(AutomaticScalesEstimationStackTransform \"true\")

(Interpolator \"ReducedDimensionBSplineInterpolator\")
(ResampleInterpolator \"FinalReducedDimensionBSplineInterpolator\")",
	True,
	(*Non PCA based methods*)
"(Metric \"AdvancedMattesMutualInformation\")

(AutomaticScalesEstimation \"true\")

(Interpolator \"BSplineInterpolator\")
(ResampleInterpolator \"FinalBSplineInterpolator\")"
]<>"
// ***************************************************************


// ** setting allowed by QMRITools **
// ***************************************************************
(WriteResultImage  \""<>output<>"\")

(NumberOfResolutions "<>ToString[resolutions]<>")
"<>Which[(*if multi resolution PCA imagePyramidSchedule has to be defined*)
	type==="PCAtranslation"||type==="PCArigid"||type==="PCAaffine"||type==="PCAbspline",
	"(ImagePyramidSchedule "<>SchedulePar[resolutions, dtar]<>")",
	True,""
]<>"
(BSplineInterpolationOrder "<>ToString[intOrder]<>")
(FinalBSplineInterpolationOrder "<>ToString[intOrder]<>")

(NumberOfHistogramBins "<>ToString[bins]<>")
(MaximumNumberOfIterations "<>ToString[itterations]<>")

(NumberOfSpatialSamples "<>ToString[samples]<>")
// ***************************************************************


// ** Transform type specific settings **
// ***************************************************************
"<>Switch[type, (*switch beteen registration types*)
(*normal methods*)	
"translation",
"(Transform \"TranslationTransform\")",
"rigid",
"(Transform \"EulerTransform\")",
"affine",
"(Transform \"AffineTransform\")
(MovingImageDerivativeScales "<>DerivativePar[N@Clip[derscA], dtar]<>")",
"bspline",
"(Transform \"RecursiveBSplineTransform\")
(FinalGridSpacingInPhysicalUnits "<>DerivativePar[N@Round[grid], dtar]<>")
(MovingImageDerivativeScales "<>DerivativePar[N@Clip[derscB], dtar]<>")",

(*DTI methods*)
"rigidDTI",
"(Transform \"AffineDTITransform\")
(Scales -1.0 -1.0 -1.0  3.0e+38  3.0e+38  3.0e+38  3.0e+38  3.0e+38  3.0e+38 -1.0 -1.0 -1.0)",
"affineDTI",
"(Transform \"AffineDTITransform\")
(Scales -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1)
(MovingImageDerivativeScales "<>DerivativePar[N@Clip[derscA], dtar]<>")",

(*PCA methods*)
"PCAtranslation",
"(Transform \"TranslationStackTransform\")
(MovingImageDerivativeScales "<>DerivativePar[{1.,1.,1.}, dtar-1, "0.0"]<>")",
"PCArigid",
"(Transform \"EulerStackTransform\")
(MovingImageDerivativeScales "<>DerivativePar[{1.,1.,1.}, dtar-1, "0.0"]<>")",
"PCAaffine",
"(Transform \"AffineLogStackTransform\")
(MovingImageDerivativeScales "<>DerivativePar[{1.,1.,1.}, dtar-1, "0.0"]<>")",
"PCAbspline",
"(Transform \"BSplineStackTransform\")
(FinalGridSpacingInPhysicalUnits "<>DerivativePar[Round[grid], dtar]<>")
(MovingImageDerivativeScales "<>DerivativePar[N@Clip[derscB], dtar-1, "0.0"]<>")"
]<>"
// ***************************************************************

//****************** end of file ***************
")


(* ::Subsubsection::Closed:: *)
(*FindElastix*)


FindElastix[]:=Module[{fil1,fil2},
	Switch[operatingSystem,
		"Windows",
		fil1=$UserBaseDirectory<>"\\Applications\\QMRITools\\Applications\\Windows-x86-64\\elastix.exe";
		fil2=$BaseDirectory<>"\\Applications\\QMRITools\\Applications\\Windows-x86-64\\elastix.exe";
		,
		"MacOSX",
		fil1=$UserBaseDirectory<>"/Applications/QMRITools/Applications/MacOSX-x86-64/bin/elastix";
		fil2=$BaseDirectory<>"/Applications/QMRITools/Applications/MacOSX-x86-64/bin/elastix";
		,
		"Unix",
		fil1=$UserBaseDirectory<>"/Applications/QMRITools/Applications/Linux-x86-64/bin/elastix";
		fil2=$BaseDirectory<>"/Applications/QMRITools/Applications/Linux-x86-64/bin/elastix";
		];
	If[FileExistsQ[fil1],fil1,If[FileExistsQ[fil2],fil2,"error: elastix not found"]]
]


(* ::Subsubsection::Closed:: *)
(*FindTransformix*)


FindTransformix[]:=Module[{fil1,fil2},
	Switch[operatingSystem,
		"Windows",
		fil1=$UserBaseDirectory<>"\\Applications\\QMRITools\\Applications\\Windows-x86-64\\transformix.exe";
		fil2=$BaseDirectory<>"\\Applications\\QMRITools\\Applications\\Windows-x86-64\\transformix.exe";
		,
		"MacOSX",
		fil1=$UserBaseDirectory<>"/Applications/QMRITools/Applications/MacOSX-x86-64/bin/transformix";
		fil2=$BaseDirectory<>"/Applications/QMRITools/Applications/MacOSX-x86-64/bin/transformix";
		,
		"Unix",
		fil1=$UserBaseDirectory<>"/Applications/QMRITools/Applications/Linux-x86-64/bin/transformix";
		fil2=$BaseDirectory<>"/Applications/QMRITools/Applications/Linux-x86-64/bin/transformix";
	];
	If[FileExistsQ[fil1],fil1,If[FileExistsQ[fil2],fil2,"error: transformix not found"]]
]


(* ::Subsubsection::Closed:: *)
(*ElastixCommand*)


ElastixCommand[elastix_,tempdir_,parfile_,{inpfol_,movfol_,outfol_},{fixedi_,movingi_,out_},{maskfi_,maskmi_}]:=Module[{
	quote, cp, num, fixed, moving, maskf, maskm, command, resout, finout, output, elas, outfile,
	inpfold, outfold, movfold, parfiles, copy, maskfFile, maskmFile, elastixFol
	},
	
	(*operating specific settings *)
	quote = Switch[operatingSystem,"Windows","\"",_,"'"];
	cp = Switch[operatingSystem,"Windows","@ copy ",_,"cp "];
	elas = Switch[operatingSystem, 
		"Windows", 
		"@ "<>quote<>elastix<>quote,
		"MacOSX", 
		elastixFol = DirectoryName[elastix, 2];
		"export PATH="<>elastixFol<>"bin:$PATH\nexport DYLD_LIBRARY_PATH="<>elastixFol<>"lib:$DYLD_LIBRARY_PATH\n"<>elastix
		,
		"Unix",
		elastixFol=DirectoryName[elastix, 2];
		"export PATH="<>elastixFol<>"bin:$PATH\nexport LD_LIBRARY_PATH="<>elastixFol<>"lib:$LD_LIBRARY_PATH\n"<>elastix
	];
	
	(*make files into gz where needed*)
	fixed = If[FileExtension[fixedi] == "nii", fixedi<>".gz", fixedi];
	moving = If[FileExtension[movingi] == "nii", movingi<>".gz", fixedi];
	maskf = If[FileExtension[maskfi] == "nii", maskfi<>".gz", maskfi];
	maskm = If[FileExtension[maskmi] == "nii", maskmi<>".gz", maskmi];
	
	(*in and output folders*)
	inpfold=If[inpfol=="",tempdir,FileNameJoin[{tempdir,inpfol}]];
	movfold=If[movfol=="",tempdir,FileNameJoin[{tempdir,movfol}]];
	outfold=If[outfol=="",StringDrop[tempdir,-1], FileNameJoin[{tempdir,outfol}]];
	outfile = FileNameJoin[{outfold,out}];
	(*maskfiles*)	
	maskfFile=If[maskf==="",""," -fMask "<>quote<>FileNameJoin[{tempdir,maskf}]<>quote];
	maskmFile=If[maskm==="",""," -mMask "<>quote<>FileNameJoin[{tempdir,maskm}]<>quote];
	
	(*par file string*)
	parfiles = StringJoin[" -p "<>quote<>FileNameJoin[{tempdir,#}]<>quote &/@parfile];
	(*copy string*)
	copy = If[out=="", 
		"", 
		(*how many par files*)
		num=ToString[Length[parfile]-1];
		resout = quote<>FileNameJoin[{tempdir,outfol,"result."<>num<>".nii.gz"}]<>quote;
		finout = quote<>FileNameJoin[{tempdir,outfol,out}]<>quote;
		cp<>resout<>" "<>finout
	];
	output = quote<>FileNameJoin[{movfold,"output.txt"}]<>quote;

	command = elas<>" -f "<>quote<>FileNameJoin[{inpfold,fixed}]<>quote<>" -m "<>quote<>FileNameJoin[{movfold,moving}]<>quote<>" -out "<>quote<>outfold<>quote<>
		maskfFile<>maskmFile<>parfiles<>" > "<>output<>" \n"<>copy<>" \n"<>"exit \n";

	{command,outfile}	
]


(* ::Subsubsection::Closed:: *)
(*RunBatfile*)


RunBatfile[tempdir_,command_]:=Block[{file,batfile,com},
	(*make elastix sh/bat based on operating system*)
	file = "elastix-batch."<>Switch[operatingSystem,"Windows","bat",_,"sh"];
	
	batfile = FileNameJoin[{tempdir,file}];
	Export[batfile,StringJoin[StringReplace[command,"exit \n"->""]],"TEXT"];
	
	com = Switch[operatingSystem,
		"Windows","\"" <> batfile <> "\"\n exit \n",
		_,"chmod 700 "<>batfile<>"\n"<>batfile<> "\n exit \n"];
	
	(*perform sh/bat on system shell*)
	If[$debugElastix, Print[com]];	
	RunProcess[$SystemShell, "StandardOutput", com];
]


(* ::Subsubsection::Closed:: *)
(*StringPad*)


StringPad[x_] := 
 StringJoin[
  PadLeft[{ToString[x]}, 5 - StringLength[ToString[x]], "0"]
]


(* ::Subsubsection::Closed:: *)
(*ConcatenateTransformFiles*)


ConcatenateTransformFiles[files_, outDir_] := Block[{len, filesi, tfile},
  (*import the transform files*)
  len = Range[Length[files]];
  filesi = Import[#, "Lines"] & /@ files;
  
  (*concatenate the transform files*)
  (
  	tfile = If[# == 1, "NoInitialTransform", outDir <> $PathnameSeparator <> "FinalTransform." <> ToString[# - 2] <> ".txt"];
  	filesi[[#, 4]] = "(InitialTransformParametersFileName \"" <> tfile <> "\")";
  	Export[outDir <> $PathnameSeparator <> "FinalTransform." <> ToString[# - 1] <> ".txt", filesi[[#]]];
  ) & /@ len;
  ]


(* ::Subsubsection::Closed:: *)
(*RunBatfileT*)


RunBatfileT[tempdir_, command_] := Block[{batfile, com},
	Switch[operatingSystem,
		"Windows",
		batfile = tempdir <> "\\transformix-batch.bat";
		Export[batfile, StringJoin[command], "TEXT"];
		com = batfile <> "\n exit \n";
		,
		"MacOSX",
		batfile = tempdir <> "/transformix-bash.sh";
		Export[batfile, StringJoin[command], "TEXT"];
		com = "chmod 700 "<>batfile<>"\n"<>batfile<> "\n exit \n";
		,
		"Unix",
		batfile = tempdir <> "/transformix-bash.sh";
		Export[batfile, StringJoin[command], "TEXT"];
		com = "chmod 700 "<>batfile<>"\n"<>batfile<> "\n exit \n";
	];
	
	If[$debugElastix, Print[com]];
	RunProcess[$SystemShell, "StandardOutput", com];
]


(* ::Subsubsection::Closed:: *)
(*TransformixCommand*)


TransformixCommand[tempDir_] := Block[{volDirs, transformix, transFol,command},
  transformix = FindTransformix[];
  transFol = StringDrop[DirectoryName[transformix, 2], -1];
    
  volDirs = FileNames["vol*", tempDir, 1];
  
  Movfile[fol_] := First[FileNames["moving*", fol]];
  
  Transfile[fol_] := Last[SortBy[FileNames["FinalTransform*", fol],FileDate[#, "Modification"] &]];
  
  command=Switch[operatingSystem,
  	"Windows",
  	(
  		"@ \"" <> transformix <>
  		"\" -in \"" <> Movfile[#] <>
  		"\" -out \"" <> # <>
  		"\" -tp \"" <> Transfile[#] <>
  		"\" > \"" <> # <> "\\outputa.txt\" \n" <>
  		"@ rename \"" <> # <> "\\result.nii.gz\" resultA-3D.nii.gz \n"
  	) & /@ volDirs
  	,
  	"MacOSX",
  	(
  		"export PATH="<>transFol<>"/bin:$PATH \n"<>
  		"export DYLD_LIBRARY_PATH="<>transFol<>"/lib:$DYLD_LIBRARY_PATH \n"<>
  		transformix <>
		" -in '" <> Movfile[#] <>
		"' -out '" <> # <>
		"' -tp '" <> Transfile[#] <>
		"' > '" <> # <> "/outputa.txt' \n" <>
		" mv '" <> # <> "/result.nii.gz' '"<> # <> "/resultA-3D.nii.gz' \n"
	) & /@ volDirs
	,
	"Unix",
	(
		"export PATH="<>transFol<>"/bin:$PATH \n"<>
		"export LD_LIBRARY_PATH="<>transFol<>"/lib:$LD_LIBRARY_PATH \n"<>
		transformix <>
		" -in '" <> Movfile[#] <>
		"' -out '" <> # <>
		"' -tp '" <> Transfile[#] <>
		"' > '" <> # <> "/outputa.txt' \n" <>
		" mv '" <> # <> "/result.nii.gz' '"<> # <> "/resultA-3D.nii.gz' \n"
	) & /@ volDirs
  ];
  
  If[$debugElastix, Print[command]];
  
  command
]


(* ::Subsection:: *)
(*RegisterData/Split*)


(* ::Subsubsection::Closed:: *)
(*RegisterData*)


Options[RegisterData]={
Iterations->250,
Resolutions->1,
HistogramBins->64,
NumberSamples->4000,
InterpolationOrderReg->3,
BsplineSpacing->30,
BsplineDirections->{1,1,1},
AffineDirections->{1,1,1},
MethodReg->"affine",
OutputImage->True,
TempDirectory->"Default",
DeleteTempDirectory->True,
PrintTempDirectory->True,
OutputTransformation->False,
UseGPU->{False,Automatic},
PCAComponents->3
};

SyntaxInformation[RegisterData]={"ArgumentsPattern"->{_,_.,OptionsPattern[]}};


(* ::Subsubsection::Closed:: *)
(*RegisterData Series*)


(*series have no target defninition*)
(*register series of data sets, no vox definition, no mask definition*)
RegisterData[series_?ArrayQ,opts:OptionsPattern[]]:=RegisterData[{series,{1,1,1}},opts]
(*register series of data sets, vox definition, no mask definition*)
RegisterData[{series_?ArrayQ,vox:{_?NumberQ,_?NumberQ,_?NumberQ}},opts:OptionsPattern[]]:=RegisterData[{series,{1},vox},opts]
(*register series of data sets, no vox definition, mask definition*)
RegisterData[{series_?ArrayQ,mask_?ArrayQ},opts:OptionsPattern[]]:=RegisterData[{series,mask,{1,1,1}},opts]

(*register series of data sets, vox definition, mask definition, no target definition*)
RegisterData[{series_?ArrayQ,mask_?ArrayQ,vox:{_?NumberQ,_?NumberQ,_?NumberQ}},opts:OptionsPattern[]]:=Module[
{depthS,error,dim,dimm,dimL,target,moving,dataout,
voxL,output,cyclyc,maskf,maskm},

(*set error*)
error=False;

(*get data properties*)
depthS=ArrayDepth[series];
dim=Dimensions[series];
dimL=If[depthS==3,dim[[1]],dim[[2]]];
dimm=Dimensions[mask];
voxL=Length[vox];

cyclyc = OptionValue[MethodReg]==="PCAtranslation"||OptionValue[MethodReg]==="PCArigid"||OptionValue[MethodReg]==="PCAaffine"||OptionValue[MethodReg]==="PCAbspline";

(*check dimensions*)
(*series must be 3 of 4D*)
If[!(depthS==3||depthS==4),Message[RegisterData::dims,depthS];Return[Message[RegisterData::fatal]]];
(*sereis must have 2 or more volumes*)
If[!dimL>=2,Message[RegisterData::vol,depthS,dim[[1]]];Return[Message[RegisterData::fatal]]];

(*check voxel sizes*)
If[voxL!=3||!(NumberQ@Total@vox),Message[RegisterData::voxs,vox];Return[Message[RegisterData::fatal]]];

(*check mask*)
If[mask!={1},
	If[cyclyc,
		(*cyclyc mask needs to be same dimensions as moving data*)
		If[dim!=dimm,Message[RegisterData::mask,dimm,dim];Return[Message[RegisterData::fatal]]],
		If[depthS==3,
			(*normal mask, one mask for all or one mask per volume*)
			If[!(dim[[2;;3]]==dimm||dim==dimm),Message[RegisterData::mask,dimm,dim];Return[Message[RegisterData::fatal]]],
			If[!(dim[[{1,3,4}]]==dimm||dim==dimm),Message[RegisterData::mask,dimm,dim];Return[Message[RegisterData::fatal]]]
		]
	]
];

(*check if method is cyclyc*)
If[cyclyc,
	(*cyclyc series define moving and target voluems*)
	target=moving=series;
	(*go to registration function*)
	RegisterDatai[{target,mask,vox},{moving,mask,vox},OptionValue[MethodReg],opts]
	,
	(*normal series define moving and target voluems*)
	{target,moving}=If[depthS==3,{series[[1]],series[[2;;]]},{series[[All,1]],Transpose@series[[All,2;;]]}];
	{maskf,maskm}=If[dimm==dim,If[depthS==3,{mask[[1]],mask[[2;;]]},{mask[[All,1]],Transpose@mask[[All,2;;]]}],{mask,mask}];
	(*go to registration function*)
	output = RegisterDatai[{target,maskf,vox},{moving,maskm,vox},"series",opts];
	(*prepare output*)
	If[OptionValue[OutputTransformation],
		(*output data with tranformation parameters*)
		dataout=Prepend[output[[1]],target];
		{If[depthS==4,Transpose@dataout,dataout],Prepend[output[[2]],{0,0,0,0,0,0,1,1,1,0,0,0}]}
		,
		(*output dat without transformation parameters*)
		dataout=Prepend[output,target];
		If[depthS==4,Transpose@dataout,dataout]
	]
]
]


(* ::Subsubsection::Closed:: *)
(*RegisterData Volumes*)


(*Volumes do have target defninition*)

(*register two data sets, vox definition and mask definition*)
RegisterData[
{target_?ArrayQ,maskt:{_?ListQ..},voxt:{_?NumberQ,_?NumberQ,_?NumberQ}},
{moving_?ArrayQ,maskm:{_?ListQ..}}
,opts:OptionsPattern[]]:=RegisterData[{target,maskt,voxt},{moving,maskm,{1,1,1}},opts];
RegisterData[
{target_?ArrayQ,maskt:{_?ListQ..}},
{moving_?ArrayQ,maskm:{_?ListQ..},voxm:{_?NumberQ,_?NumberQ,_?NumberQ}}
,opts:OptionsPattern[]]:=RegisterData[{target,maskt,{1,1,1}},{moving,maskm,voxm},opts];

(*register two data sets, vox definition and maskt definition*)
RegisterData[
{target_?ArrayQ,maskt:{_?ListQ..},voxt:{_?NumberQ,_?NumberQ,_?NumberQ}},
moving_?ArrayQ
,opts:OptionsPattern[]]:=RegisterData[{target,maskt,voxt},{moving,{1},{1,1,1}},opts];
RegisterData[
{target_?ArrayQ,maskt:{_?ListQ..}},
{moving_?ArrayQ,voxm:{_?NumberQ,_?NumberQ,_?NumberQ}}
,opts:OptionsPattern[]]:=RegisterData[{target,maskt,{1,1,1}},{moving,{1},voxm},opts];
RegisterData[
{target_?ArrayQ,maskt:{_?ListQ..},voxt:{_?NumberQ,_?NumberQ,_?NumberQ}},
{moving_?ArrayQ,voxm:{_?NumberQ,_?NumberQ,_?NumberQ}}
,opts:OptionsPattern[]]:=RegisterData[{target,maskt,voxt},{moving,{1},voxm},opts];

(*register two data sets, vox definition and maskm definition*)
RegisterData[
{target_?ArrayQ,voxt:{_?NumberQ,_?NumberQ,_?NumberQ}},
{moving_?ArrayQ,maskm:{_?ListQ..}}
,opts:OptionsPattern[]]:=RegisterData[{target,{1},voxt},{moving,maskm,{1,1,1}},opts];
RegisterData[
target_?ArrayQ,
{moving_?ArrayQ,maskm:{_?ListQ..},voxm:{_?NumberQ,_?NumberQ,_?NumberQ}}
,opts:OptionsPattern[]]:=RegisterData[{target,{1},{1,1,1}},{moving,maskm,voxm},opts];
RegisterData[
{target_?ArrayQ,voxt:{_?NumberQ,_?NumberQ,_?NumberQ}},
{moving_?ArrayQ,maskm:{_?ListQ..},voxm:{_?NumberQ,_?NumberQ,_?NumberQ}}
,opts:OptionsPattern[]]:=RegisterData[{target,{1},voxt},{moving,maskm,voxm},opts];

(*register two data sets, no vox definition and mask definition*)
RegisterData[
{target_?ArrayQ,maskt_:{_?ListQ..}},
moving_?ArrayQ
,opts:OptionsPattern[]]:=RegisterData[{target,maskt,{1,1,1}},{moving,{1},{1,1,1}},opts];
RegisterData[
target_?ArrayQ,
{moving_?ArrayQ,maskm:{_?ListQ..}}
,opts:OptionsPattern[]]:=RegisterData[{target,{1},{1,1,1}},{moving,maskm,{1,1,1}},opts];
RegisterData[
{target_?ArrayQ,maskt:{_?ListQ..}},
{moving_?ArrayQ,maskm:{_?ListQ..}}
,opts:OptionsPattern[]]:=RegisterData[{target,maskt,{1,1,1}},{moving,maskm,{1,1,1}},opts];

(*register two data sets, vox definition and no mask definition*)
RegisterData[
{target_?ArrayQ,voxt:{_?NumberQ,_?NumberQ,_?NumberQ}},
moving_?ArrayQ
,opts:OptionsPattern[]]:=RegisterData[{target,{1},voxt},{moving,{1},{1,1,1}},opts]
RegisterData[
target_?ArrayQ,
{moving_?ArrayQ,voxm:{_?NumberQ,_?NumberQ,_?NumberQ}}
,opts:OptionsPattern[]]:=RegisterData[{target,{1},{1,1,1}},{moving,{1},voxm},opts]
RegisterData[
{target_?ArrayQ,voxt:{_?NumberQ,_?NumberQ,_?NumberQ}},
{moving_?ArrayQ,voxm:{_?NumberQ,_?NumberQ,_?NumberQ}}
,opts:OptionsPattern[]]:=RegisterData[{target,{1},voxt},{moving,{1},voxm},opts]

(*register two data sets, no vox definition and no mask definition*)
RegisterData[
target_?ArrayQ,
moving_?ArrayQ
,opts:OptionsPattern[]]:=RegisterData[{target,{1},{1,1,1}},{moving,{1},{1,1,1}},opts]

(*register two data sets, mask and vox definition*)
RegisterData[
{target_?ArrayQ,maskt_?ArrayQ,voxt:{_?NumberQ,_?NumberQ,_?NumberQ}},
{moving_?ArrayQ,maskm_?ArrayQ,voxm:{_?NumberQ,_?NumberQ,_?NumberQ}},opts:OptionsPattern[]]:=Module[
{depthT,depthM,voxtL,voxmL,error,dim,type,mov,output},

(*set error*)
error=False;

(*Check Method, PCA only possible for series*)
If[OptionValue[MethodReg]==="PCAtranslation"||OptionValue[MethodReg]==="PCArigid"||OptionValue[MethodReg]==="PCAaffine"||OptionValue[MethodReg]==="PCAbspline",
	error=True;Message[RegisterData::metc]];

(*get data properties*)
depthT=ArrayDepth[target];
depthM=ArrayDepth[moving];
dim=Dimensions[moving];
voxtL=Length[voxt];
voxmL=Length[voxm];

(*check dimensions and determine type*)
type=Which[
	depthT == depthM, "vol", (*2D-2D, 3D-3D*)
	(depthT == 2 || depthT == 3) && depthM == depthT + 1, "series", (*2D-3D, 3D-4D*)
	True, error=True;Message[RegisterData::dim,depthT,depthM]; (*error*)];

(*check voxel sies*)
If[voxtL!=3||voxmL!=3||!(NumberQ@Total@voxt)||!(NumberQ@Total@voxm),Message[RegisterData::vox,voxt,voxm];Return[Message[RegisterData::fatal]]];

(*if error found quit*)
If[error,Return[Message[RegisterData::fatal]]];

(*define moving voluems*)
mov=If[depthM==4,Transpose@moving,moving];

(*No errors, go to registration function only "vol" or "series"*)
output=RegisterDatai[{target,maskt,voxt},{mov,maskm,voxm},type,opts];

If[OptionValue[OutputTransformation],
		{If[depthM==4,Transpose@output[[1]],output[[1]]],Prepend[output[[2]],{0,0,0,0,0,0,1,1,1,0,0,0}]},
		If[depthM==4,Transpose@output,output]
]
]


(* ::Subsubsection::Closed:: *)
(*RegisterDatai*)


Options[RegisterDatai]=Options[RegisterData];

RegisterDatai[{target_?ArrayQ,voxt:{_?NumberQ,_?NumberQ,_?NumberQ}},{moving_?ArrayQ,voxm:{_?NumberQ,_?NumberQ,_?NumberQ}},type_,opts:OptionsPattern[]]:=
RegisterDatai[{target,{1},voxt},{moving,{1},voxm},type,opts]

RegisterDatai[{target_?ArrayQ,maskt_,voxt:{_?NumberQ,_?NumberQ,_?NumberQ}},{moving_?ArrayQ,voxm:{_?NumberQ,_?NumberQ,_?NumberQ}},type_,opts:OptionsPattern[]]:=
RegisterDatai[{target,maskt,voxt},{moving,{1},voxm},type,opts]

RegisterDatai[{target_?ArrayQ,voxt:{_?NumberQ,_?NumberQ,_?NumberQ}},{moving_?ArrayQ,maskm_,voxm:{_?NumberQ,_?NumberQ,_?NumberQ}},type_,opts:OptionsPattern[]]:=
RegisterDatai[{target,{1},voxt},{moving,maskm,voxm},type,opts]

RegisterDatai[
{target_?ArrayQ,maskt_?ArrayQ,voxt:{_?NumberQ,_?NumberQ,_?NumberQ}},{moving_?ArrayQ,maskm_?ArrayQ,voxm:{_?NumberQ,_?NumberQ,_?NumberQ}},
type_,OptionsPattern[]]:=Module[{
	tdir, tempdir, elastix, targetFile, parstring, outputImg, iterations, resolutions,
	histogramBins, numberSamples, derivativeScaleA, derivativeScaleB, interpolationOrder,
	method, bsplineSpacing, data, vox, dimmov, dimtar, dimmovm, dimtarm, inpfol, movfol, outfol, 
	fixedF, movingF, outF, parF, depth, index, error, regpars, lenMeth, command, outfile, 
	fmaskF, mmaskF, maske, maske2, w, openCL, gpu, pca, dtar},
	
	w={{0,0,0,0,0,0,1,1,1,0,0,0}};
	
	(*set error*)
	error=False;
	maske=False;
	
	(*get option values*)
	tdir=OptionValue[TempDirectory];
	outputImg=ToLowerCase[ToString[OptionValue[OutputImage]]];
	
	method=OptionValue[MethodReg];
	If[$debugElastix,Print[method]];
	
	bsplineSpacing=OptionValue[BsplineSpacing];
	bsplineSpacing=If[!ListQ[bsplineSpacing],ConstantArray[bsplineSpacing,3],bsplineSpacing];
	derivativeScaleB=OptionValue[BsplineDirections];
	derivativeScaleA=OptionValue[AffineDirections];
	
	{openCL,gpu}=OptionValue[UseGPU];
	gpu=If[gpu===Automatic,0,gpu];
	pca=OptionValue[PCAComponents];
	
	(*Print[{derivativeScaleA,derivativeScaleB}];*)
	
	iterations=OptionValue[Iterations];
	resolutions=OptionValue[Resolutions];
	histogramBins=OptionValue[HistogramBins];
	numberSamples=OptionValue[NumberSamples];
	interpolationOrder=OptionValue[InterpolationOrderReg];
	regpars={iterations,resolutions,histogramBins,numberSamples,interpolationOrder};
	
	dimmov=Dimensions[moving];
	dimtar=Dimensions[target];
	dtar=ArrayDepth[target];
	dimmovm=Dimensions[maskm];
	dimtarm=Dimensions[maskt];
	
	(*find the elastix program*)
	elastix=FindElastix[];
	If[elastix=="error",error=True;Message[RegisterData::elastix];];
	
	(*create temp directory*)
	tdir=(If[StringQ[tdir],tdir,"Default"]/. {"Default"->$TemporaryDirectory});
	
	tdir=If[Last[FileNameSplit[tdir]] === "QMRIToolsReg" || Last[FileNameSplit[tdir]] === "anat",
		tdir,
		tdir<>$PathnameSeparator<>"QMRIToolsReg"
	];
	
	If[DirectoryQ[tdir],DeleteDirectory[tdir,DeleteContents->True]];
	tempdir=CreateDirectory[tdir]<>$PathnameSeparator;
	If[!DirectoryQ[tempdir],Message[RegisterData::dir];Return[Message[RegisterData::fatal]]];
	
	(*check registration method*)
	method=If[StringQ[method],{method},method];
	If[!MemberQ[{"translation", "rigid", "affine", "bspline", "rigidDTI", "affineDTI", "PCAtranslation", "PCArigid", "PCAaffine", "PCAbspline"},#],
		Message[RegisterData::met,#];
		Return[Message[RegisterData::fatal],Module]
		]&/@method; 
	lenMeth=Length[method];
	
	(*only cyclyc is possible*)
	If[(MemberQ[method,"PCAtranslation"]||MemberQ[method,"PCArigid"]||MemberQ[method,"PCAaffine"]||MemberQ[method,"PCAbspline"] )&&lenMeth>1,error=True];
	
	(*create parameter list*)
	regpars=If[NumberQ[#],ConstantArray[#,lenMeth],
	If[Length[#]==lenMeth,#,Message[RegisterData::par,#,lenMeth];Return[Message[RegisterData::fatal]];
	]]&/@regpars;
	
	(*check mask dimensions*)
	
	(*if error quit*)
	If[error,Return[Message[RegisterData::fatal]]];
	If[OptionValue[PrintTempDirectory],PrintTemporary["using as temp directory: "<>tdir]];

	(*create target file*)
	depth=If[type==="PCAtranslation"||type==="PCArigid"||type==="PCAaffine"||type==="PCAbspline",
		ToString[dtar-1]<>"D-t",
		ToString[dtar]<>"D"];
	fixedF="target-"<>depth<>".nii";
	targetFile=tempdir<>fixedF;
	(*export the target*)
	ExportNii[target,voxt,targetFile];
	
	(*create parameter files*)
	
	parF = MapThread[(
		parstring=ParString[#2, {#1,outputImg}, {dtar, bsplineSpacing, derivativeScaleB, derivativeScaleA, pca},{openCL, gpu}];
		parF="parameters-"<>#1<>".txt";
		Export[tempdir<>parF,parstring];
		parF
	)&, {method, Transpose[regpars]}];
	

	
	(*perform registration which is either "series", "vol" or PCA based method*)
	Which[
		type==="vol",(*volume to volume registration (2D-2D, 3D-3D)*)
		
		{inpfol,movfol,outfol}={"","",""};
		{movingF,outF}={"moving-"<>depth<>".nii","result-"<>depth<>".nii.gz"};
		ExportNii[moving,voxm,tempdir<>movingF];
		{fmaskF,mmaskF}={"",""};
		(*check if target mask is needed*)
		If[dimtarm == dimtar && maskt!={1},fmaskF="targetMask.nii";ExportNii[maskt,voxm,tempdir<>fmaskF]];
		(*check if moving mask is needed*)
		If[(dimmovm == dimmov && maskm!={1}),mmaskF="moveMask.nii";ExportNii[maskm,voxm,tempdir<>mmaskF]];
		command = ElastixCommand[elastix,tempdir,parF,{inpfol,movfol,outfol},{fixedF,movingF,outF},{fmaskF,mmaskF}][[1]];
		If[$debugElastix, Print[command]];
		RunProcess[$SystemShell,"StandardOutput",command];
		(*RunElastix[elastix,tempdir,parF,{inpfol,movfol,outfol},{fixedF,movingF,outF},{fmaskF,mmaskF}];*)
		{data,vox}=ImportNii[tempdir<>outfol<>outF];
			
		,
		type==="series", (*series to volume registration (2D-3D, 3D-4D)*)
		
		inpfol="";
		{fmaskF,mmaskF}={"",""};
		{movingF,outF}={"moving-"<>depth<>".nii","result-"<>depth<>".nii.gz"};
		(*export one mask for every volume in the series*)
		If[dimtarm == dimtar && maskt!={1},
		fmaskF="targetMask.nii";
		ExportNii[maskt,voxm,tempdir<>fmaskF]];
		(*check if mask needs to be exported for each volume*)
		maske=(dimmovm == dimmov && maskm!={1});
		(*check if same mask for all volumes*)
		maske2=(dimmovm == Drop[dimmov,1] && maskm!={1});
		(*export data*)
		{command,outfile}=Transpose@(
		(
			index=StringPad[#];
			movfol=outfol="vol"<>index;
			CreateDirectory[tempdir<>outfol];
			ExportNii[moving[[#]],voxm,tempdir<>movfol<>$PathnameSeparator<>movingF];
			(*export mask*)
			If[maske,mmaskF=movfol<>$PathnameSeparator<>"moveMask.nii";ExportNii[maskm[[#]],voxm,tempdir<>mmaskF]];
			If[maske2,mmaskF=movfol<>$PathnameSeparator<>"moveMask.nii";ExportNii[maskm,voxm,tempdir<>mmaskF]];
			
			ElastixCommand[elastix,tempdir,parF,{inpfol,movfol,outfol},{fixedF,movingF,outF},{fmaskF,mmaskF}]
		)&/@Range[Length[moving]]);
		(*create and run batch*)
		RunBatfile[tempdir,command];
		(*Import data*)
		data=(First@ImportNii[#])&/@outfile;
		
		If[OptionValue[OutputTransformation], w = ReadTransformParameters[tempdir]];
		
		,
		True, (*if not series or vol then PCA based method*)
		
		{inpfol,movfol,outfol}={"","",""};
		{fmaskF,mmaskF}={"",""};
		{movingF,outF}={"moving-"<>depth<>".nii","result-"<>depth<>".nii.gz"};
		ExportNii[moving,voxm,tempdir<>movingF];
		If[maskm!={1},mmaskF="moveMask.nii";ExportNii[maskm,voxm,tempdir<>mmaskF]];
		If[maskt!={1},fmaskF="targetMask.nii";ExportNii[maskt,voxm,tempdir<>fmaskF]];
		command = ElastixCommand[elastix,tempdir,parF,{inpfol,movfol,outfol},{fixedF,movingF,outF},{fmaskF,mmaskF}][[1]];
		If[$debugElastix, Print[command]];
		RunProcess[$SystemShell,"StandardOutput",command];
		(*RunElastix[elastix,tempdir,parF,{inpfol,movfol,outfol},{fixedF,movingF,outF},{fmaskF,mmaskF}];*)
		{data,vox}=ImportNii[tempdir<>outfol<>outF];
	];
	
	data=ToPackedArray[N@Chop[Clip[data,MinMax[moving]]]];
	
	If[OptionValue[DeleteTempDirectory],DeleteDirectory[tempdir,DeleteContents->True]];
	If[OptionValue[OutputTransformation], {data,w},	data]
	
]


(* ::Subsubsection::Closed:: *)
(*RegisterDataSplit*)


Options[RegisterDataSplit] = Join[Options[RegisterData],{SplitMethod->"Mean"}];

SyntaxInformation[RegisterDataSplit] = {"ArgumentsPattern" -> {_, _., OptionsPattern[]}};

RegisterDataSplit[targeti_, movingi_, opts : OptionsPattern[]] := Block[{
	reg, mov,
	target ,maskT, voxT,
	moving, maskM, voxM,
	targetl, targetr, maskTl, maskTr, cut1,
	movingl, movingr, maskMl, maskMr, cut2,
	regl, regr, movl, movr
	},
	
	(*prepare the input*)
	{target ,maskT, voxT}=SplitInput[targeti];
	{moving, maskM, voxM}=SplitInput[movingi];
	
	(*find the common split*)	
	{targetl, targetr, cut1}=CutData[target];
	{movingl, movingr, cut2}=CutData[moving];
	
	{cut1, cut2} = Switch[OptionValue[SplitMethod],
		"target", Round[{cut1, (cut1 voxT[[2]])/voxM[[2]]}],
		"moving", Round[{(cut2 voxM[[2]])/voxT[[2]], cut2}],
		"nearest", Round[First@Nearest[{cut1 Last@voxT, cut2 Last@voxM}, (Last@Dimensions[target]/2) Last[voxT]]/{Last@voxT, Last@voxM}],
		"own", Round[{cut1, cut2}],
		_, Round[Mean[{cut1 voxT[[2]], cut2 voxM[[2]]}]/{voxT[[2]], voxM[[2]]}]
		];
	
	(*cut data*)
	{targetl, targetr, cut1}=CutData[target,cut1];
	{movingl, movingr, cut2}=CutData[moving,cut2];
	(*cut masks*)
	{maskTl, maskTr}=If[maskT==={1},{{1},{1}},CutData[maskT,cut1][[;;-2]]];
	{maskMl, maskMr}=If[maskM==={1},{{1},{1}},CutData[maskM,cut2][[;;-2]]];
	
	(*register left part*)
	regl = RegisterData[{targetl, maskTl, voxT}, {movingl, maskMl, voxM},  Sequence@@FilterRules[{opts}, Options[RegisterData]]];
	(*register right part*)
	regr = RegisterData[{targetr, maskTr, voxT}, {movingr, maskMr, voxM},  Sequence@@FilterRules[{opts}, Options[RegisterData]]];
	
	StichData[regl,regr]
	
  ]


(* ::Subsubsection::Closed:: *)
(*SplitInput*)


SplitInput[input_]:=Module[{data,mask,vox},
	(*split the target data*)
	If[ArrayQ[input],
		(*data*)
		data=input;mask={1};vox={1,1,1};
		,
		If[Length[input]==2 && ArrayQ[input[[1]]] && Length[input[[2]]]==3,
			(*data and vox*)
			data=input[[1]];mask={1};vox=input[[2]];
			,
			(*data, mask and vox*)
			data=input[[1]];mask=input[[2]];vox=input[[3]];
		]
	];
	{data,mask,vox}
]


(* ::Subsection:: *)
(*TransformData*)


(* ::Subsubsection::Closed:: *)
(*TransformData*)


Options[TransformData] = {TempDirectory -> "Default", FindTransform -> "Auto", DeleteTempDirectory -> "All",PrintTempDirectory->True}

SyntaxInformation[TransformData] = {"ArgumentsPattern" -> {_, OptionsPattern[]}};

TransformData[{data_, vox_}, OptionsPattern[]] := Module[{tdir, command, output},
	
	(*define the directory*)
	tdir = OptionValue[TempDirectory];
	tdir = (If[StringQ[tdir], tdir, "Default"] /. {"Default" -> $TemporaryDirectory}) <>$PathnameSeparator<>"QMRIToolsReg"<>$PathnameSeparator<>"transform";
	
	(*create and print the directory*)
	If[OptionValue[PrintTempDirectory],PrintTemporary[tdir]];
	If[DirectoryQ[tdir],DeleteDirectory[tdir,DeleteContents->True]];
	CreateDirectory[tdir];
	
	(*Export and transform*)
	ExportNii[data, vox, tdir <> $PathnameSeparator <> "trans.nii"];
	command = TransformixCommandInd[tdir];

	If[$debugElastix, Print[command]];
	RunProcess[$SystemShell, "StandardOutput", command];
	
	output = ToPackedArray[ImportNii[tdir <> $PathnameSeparator <> "result.nii"][[1]]];
	
	(*Delete temp directory*)
	Switch[OptionValue[DeleteTempDirectory],
		"All", DeleteDirectory[FileNameTake[tdir, {1, -2}],  DeleteContents -> True],
		"Trans", DeleteDirectory[tdir, DeleteContents -> True],
		_, Null];
		
	(*give the output*)
	ToPackedArray@N@Chop[Clip[output,MinMax[data]],10^-6]
]


(* ::Subsubsection::Closed:: *)
(*TransformixCommandInd*)


TransformixCommandInd[tempDir_] := Block[{transformix, transfile,transFol},
	transformix = FindTransformix[];
	transFol = StringDrop[DirectoryName[transformix, 2], -1];
	
	transfile = Last[SortBy[
		FileNames["TransformParameters*", FileNameTake[tempDir, {1, -2}]],
		FileDate[#, "Modification"] &]];
	
	Switch[$OperatingSystem,
		"Windows",
		"@ \"" <> transformix <>
		"\" -in \"" <> First[FileNames["trans*", tempDir]] <>
		"\" -out \"" <> tempDir <>
		"\" -tp \"" <> transfile <>
		(*"\" -def all" <>*)
		"\"" <>
		" > \"" <> tempDir <> "\\outputT.txt\" \n exit \n"
		,
		"MacOSX",
		"export PATH="<>transFol<>"/bin:$PATH\nexport DYLD_LIBRARY_PATH="<>transFol<>"/lib:$DYLD_LIBRARY_PATH\n"<>
		transformix <>
		" -in '" <> First[FileNames["trans*", tempDir]] <>
		"' -out '" <> tempDir <>
		"' -tp '" <> transfile <>
		"' > '" <> tempDir <> "/outputT.txt' \n exit \n"
		,
		"Unix",
		"export PATH="<>transFol<>"/bin:$PATH\nexport LD_LIBRARY_PATH="<>transFol<>"/lib:$LD_LIBRARY_PATH\n"<>
		transformix <>
		" -in '" <> First[FileNames["trans*", tempDir]] <>
		"' -out '" <> tempDir <>
		"' -tp '" <> transfile <>
		"' > '" <> tempDir <> "/outputT.txt' \n exit \n"
	]
  ]


(* ::Subsubsection::Closed:: *)
(*ReadTransformParameters*)


SyntaxInformation[ReadTransformParameters]={"ArgumentsPattern"->{_}};

ReadTransformParameters[dir_] := Block[{files,filenum,cor},
  files = FileNames["TransformParameters*", dir, 3];
  filenum = If[Length[files] == 1,
  	{1},
  	ToExpression[First[StringCases[FileNameSplit[#][[-2]],DigitCharacter ..]]] & /@ files
  	];
  files = files[[Ordering[filenum]]];
  cor =  
    Partition[
        ToExpression[
         StringSplit[StringTake[Import[#, "Lines"][[3]], {2, -2}]][[
          2 ;;]]], 3][[{1, 4, 3, 2}, {3,2,1}]] & /@ files;
  cor[[All, 1]] = cor[[All, 1]]/Degree;

  Flatten /@ cor
  ]


(* ::Subsection:: *)
(*RegisterDataTransform/Split*)


(* ::Subsubsection::Closed:: *)
(*RegisterDataTransform*)


Options[RegisterDataTransform] = Options[RegisterData];

SyntaxInformation[RegisterDataTransform] = {"ArgumentsPattern" -> {_, _, _, OptionsPattern[]}};

RegisterDataTransform[target_, moving_, {moving2_, vox_}, opts : OptionsPattern[]] := Block[{reg, mov,tdir},
	reg = RegisterData[target, moving, DeleteTempDirectory -> False, opts];
	
	mov = If[
		ArrayDepth[moving2]==4 && ArrayDepth[reg]==3 ,
		Transpose[TransformData[{#, vox}, DeleteTempDirectory -> False, PrintTempDirectory -> False] & /@ Transpose[moving2]] ,
		If[ArrayDepth[moving2]==3 && ArrayDepth[reg]==2 ,
			TransformData[{#, vox}, DeleteTempDirectory -> False, PrintTempDirectory -> False] & /@ moving2,
			TransformData[{moving2, vox}, DeleteTempDirectory -> False, PrintTempDirectory -> False]
			]
		];
	
	tdir=OptionValue[TempDirectory];
	tdir=(If[StringQ[tdir],tdir,"Default"]/. {"Default"->$TemporaryDirectory})<>$PathnameSeparator<>"QMRIToolsReg";
	
	If[OptionValue[DeleteTempDirectory],DeleteDirectory[tdir,DeleteContents->True]];		
		
	{reg, mov}
  ]


(* ::Subsubsection::Closed:: *)
(*RegisterDataTransformSplit*)


Options[RegisterDataTransformSplit] = Join[Options[RegisterData],{SplitMethod->"Mean"}];

SyntaxInformation[RegisterDataTransformSplit] = {"ArgumentsPattern" -> {_, _, _, OptionsPattern[]}};

RegisterDataTransformSplit[targeti_, movingi_, {moving2_, vox_}, opts : OptionsPattern[]] := Block[{reg, mov,
	target ,maskT, voxT,
	moving, maskM, voxM,
	targetl, targetr, maskTl, maskTr, cut1,
	movingl, movingr, maskMl, maskMr, cut2,
	moving2l, moving2r, tdir,
	regl, regr, movl, movr
	},
	
	(*prepare the input*)
	{target ,maskT, voxT}=SplitInput[targeti];
	{moving, maskM, voxM}=SplitInput[movingi];
	
	(*find the common split*)	
	{targetl, targetr, cut1}=CutData[target];
	{movingl, movingr, cut2}=CutData[moving];
	
	{cut1, cut2} = Switch[OptionValue[SplitMethod],
		"Target", Round[{cut1, (cut1 voxT[[2]])/voxM[[2]]}],
		"Moving", Round[{(cut2 voxM[[2]])/voxT[[2]], cut2}],
		"Nearest", Round[First@Nearest[{cut1 Last@voxT, cut2 Last@voxM}, (Last@Dimensions[target]/2) Last[voxT]]/{Last@voxT, Last@voxM}],
		"own", Round[{cut1, cut2}],
		_, Round[Mean[{cut1 voxT[[2]], cut2 voxM[[2]]}]/{voxT[[2]], voxM[[2]]}]
		];
	
	(*cut data*)
	{targetl, targetr, cut1}=CutData[target,cut1];
	{movingl, movingr, cut2}=CutData[moving,cut2];
	(*cut masks*)
	{maskTl, maskTr}=If[maskT==={1},{{1},{1}},CutData[maskT,cut1][[;;-2]]];
	{maskMl, maskMr}=If[maskM==={1},{{1},{1}},CutData[maskM,cut2][[;;-2]]];
	
	(*split the moving2 data*)
	{moving2l, moving2r, cut2} = CutData[moving2, cut2];
	
	(*register left part*)
	regl = RegisterData[{targetl, maskTl, voxT}, {movingl, maskMl, voxM}, DeleteTempDirectory -> False, Sequence@@FilterRules[{opts}, Options[RegisterData]]];
	(*transform the left part*)
	movl = If[ArrayDepth[moving2l] == 4,
		Transpose[TransformData[{#, vox}, DeleteTempDirectory -> False, PrintTempDirectory -> False] & /@ Transpose[moving2l]],
		TransformData[{moving2l, vox}, DeleteTempDirectory -> False, PrintTempDirectory -> False]
		];
		
	(*register right part*)
	regr = RegisterData[{targetr, maskTr, voxT}, {movingr, maskMr, voxM}, DeleteTempDirectory -> False, Sequence@@FilterRules[{opts}, Options[RegisterData]]];
	(*transform the right part*)
	movr = If[ArrayDepth[moving2r] == 4,
		Transpose[TransformData[{#, vox}, DeleteTempDirectory -> False, PrintTempDirectory -> False] & /@ Transpose[moving2r]],
		TransformData[{moving2r, vox}, DeleteTempDirectory -> False, PrintTempDirectory -> False]
		];
	
	tdir=OptionValue[TempDirectory];
	tdir=(If[StringQ[tdir],tdir,"Default"]/. {"Default"->$TemporaryDirectory})<>$PathnameSeparator<>"QMRIToolsReg";
	
	If[OptionValue[DeleteTempDirectory],DeleteDirectory[tdir,DeleteContents->True]];	
	
	{StichData[regl,regr],StichData[movl,movr]}
	
  ]



(* ::Subsection:: *)
(*RegisterDiffusionData/Split*)


(* ::Subsubsection::Closed:: *)
(*RegisterDiffusionData*)


Options[RegisterDiffusionData] = 
  Join[Options[RegisterData] /. {{1, 1, 1} -> {0, 1, 1}, "affine" -> "affineDTI", "rigid" -> "rigidDTI"},
   {IterationsA -> 1000, 
   	ResolutionsA -> 1, 
   	HistogramBinsA -> 64, 
    NumberSamplesA -> 20000, 
    InterpolationOrderRegA -> 1, 
    MethodRegA -> {"rigid", "bspline"},
    RegistrationTarget->"Fist"
    }];

SyntaxInformation[RegisterDiffusionData] = {"ArgumentsPattern" -> {_, _., OptionsPattern[]}};

(*No anatomical data, goto Registerdata*)
RegisterDiffusionData[
	{dtidata_?ArrayQ, vox : {_?NumberQ, _?NumberQ, _?NumberQ}},
	opts : OptionsPattern[]
	] := RegisterDiffusionData[{dtidata, {1}, vox}, opts]

RegisterDiffusionData[
	{dtidata_?ArrayQ, dtimask_?ArrayQ, vox : {_?NumberQ, _?NumberQ, _?NumberQ}},
	opts:OptionsPattern[]
	] := (RegisterData[{dtidata, dtimask, vox},(*OutputTransformation->True,*) 
		MethodReg-> (OptionValue[MethodReg] /. {"affine" -> "affineDTI", "rigid" -> "rigidDTI"}),
		AffineDirections -> {1, 1, 1},
		FilterRules[{opts}, Options[RegisterData]]]
		)

(**)
RegisterDiffusionData[
	{dtidata_?ArrayQ, vox : {_?NumberQ, _?NumberQ, _?NumberQ}},
	{anatdata_?ArrayQ, voxa : {_?NumberQ, _?NumberQ, _?NumberQ}},
	opts : OptionsPattern[]
	] := RegisterDiffusionData[{dtidata, {1}, vox}, {anatdata, {1},voxa}, opts]

RegisterDiffusionData[
	{dtidata_?ArrayQ, dtimask_?ArrayQ, vox : {_?NumberQ, _?NumberQ, _?NumberQ}},
	{anatdata_?ArrayQ, voxa : {_?NumberQ, _?NumberQ, _?NumberQ}}, 
	opts : OptionsPattern[]
	] := RegisterDiffusionData[{dtidata, dtimask, vox}, {anatdata, {1}, voxa}, opts]

RegisterDiffusionData[
	{dtidata_?ArrayQ, vox : {_?NumberQ, _?NumberQ, _?NumberQ}},
	{anatdata_?ArrayQ, anatmask_?ArrayQ, voxa : {_?NumberQ, _?NumberQ, _?NumberQ}},
	opts : OptionsPattern[]
	] := RegisterDiffusionData[{dtidata, {1}, vox}, {anatdata, anatmask, voxa}, opts]

RegisterDiffusionData[
	{dtidata_?ArrayQ, dtimask_?ArrayQ, vox : {_?NumberQ, _?NumberQ, _?NumberQ}},
	{anatdata_?ArrayQ, anatmask_?ArrayQ, voxa : {_?NumberQ, _?NumberQ, _?NumberQ}},
	opts : OptionsPattern[]
	] := Module[{dtidatar, tempDir, tempDira, volDirs, w,tFilesA, tFilesD, dtidatarA, cmd, target, movingdata},
  
  (*Print["RegisterDiffusionData"];*)
 
  (*get the current temp dir and define the anat tempdir*)
  tempDir = OptionValue[TempDirectory];
  tempDir = (If[StringQ[tempDir], tempDir, "Default"]/. {"Default"->$TemporaryDirectory})<>$PathnameSeparator<>"QMRIToolsReg";
  tempDira = tempDir <> $PathnameSeparator <> "anat";

  (*perform DTI registration*)
  dtidatar = RegisterData[{dtidata, dtimask, vox},
    TempDirectory -> tempDir, 
    DeleteTempDirectory -> False, 
    OutputTransformation->OptionValue[OutputTransformation], 
    MethodReg-> (OptionValue[MethodReg] /. {"affine" -> "affineDTI", "rigid" -> "rigidDTI"}),
    (*AffineDirections -> {1, 1, 1},*)
    FilterRules[{opts} , Options[RegisterData]]];

  If[OptionValue[OutputTransformation],{dtidatar,w}=dtidatar];
    
  target = OptionValue[RegistrationTarget];
  movingdata=If[ListQ[target] && AllTrue[target, IntegerQ] && Min[target] > 0 && Max[target] <= Length[dtidatar[[1]]],
  	Median /@ dtidatar[[All, DeleteDuplicates[target]]],
  	Switch[target,
  		"Median", Median /@ dtidatar,
  		"First", dtidatar[[All, 1]],
  		_, Mean /@ dtidatar
  		]];
  
  (*perform anat registration*)
  RegisterData[{anatdata, anatmask, voxa}, {movingdata, dtimask, vox},
   TempDirectory -> tempDira, 
   DeleteTempDirectory -> False,
   Iterations -> OptionValue[IterationsA], 
   Resolutions -> OptionValue[ResolutionsA],
   HistogramBins -> OptionValue[HistogramBinsA], 
   NumberSamples -> OptionValue[NumberSamplesA],
   InterpolationOrderReg -> OptionValue[InterpolationOrderRegA],
   BsplineSpacing -> OptionValue[BsplineSpacing], 
   BsplineDirections -> OptionValue[BsplineDirections],
   AffineDirections -> OptionValue[AffineDirections],
   MethodReg -> OptionValue[MethodRegA], 
   FilterRules[{opts}, Options[RegisterData]]
   ];
  
  (*transform all diffusion files to anatomy*)
  
  (*export diffusion reg target*)
  CreateDirectory[tempDir<>$PathnameSeparator<>"vol0000"];
  ExportNii[dtidatar[[All,1]],vox,tempDir<>$PathnameSeparator<>"vol0000"<>$PathnameSeparator<>"moving-3D.nii"];
  
  (*get vol folders and anat transform files*)
  volDirs = FileNames["vol*", tempDir, 1];
  tFilesA = FileNames["TransformParameters*", tempDira];
  
  (*create Final Transform files*)
  (
     tFilesD = FileNames["TransformParameters*", #];
     ConcatenateTransformFiles[Join[tFilesD, tFilesA], #]
     ) & /@ volDirs;
  
  (*call transformix*)
  cmd = TransformixCommand[tempDir];
  PrintTemporary["Combining transformations"];
  RunBatfileT[tempDir, cmd];
  
  (*import dti data in anat space*)
  dtidatarA = Transpose[ImportNii[#][[1]] & /@ FileNames["resultA*", tempDir, 2]];
  
  (*finalize by deleting temp director*)
  If[OptionValue[DeleteTempDirectory],DeleteDirectory[tempDir,DeleteContents->True]];
  
  (*output data*)
  If[OptionValue[OutputTransformation],
  	{dtidatar, dtidatarA, w},
  	{dtidatar, dtidatarA}
  ]
]


(* ::Subsubsection::Closed:: *)
(*RegisterDiffusionDataSplit*)


Options[RegisterDiffusionDataSplit] := Options[RegisterDiffusionData];

SyntaxInformation[RegisterDiffusionDataSplit] = {"ArgumentsPattern" -> {_, _., OptionsPattern[]}};

RegisterDiffusionDataSplit[
	{data_, vox: {_?NumberQ, _?NumberQ, _?NumberQ}}, 
	opts : OptionsPattern[]
	] := Block[{datal, datar, cut},
   {datal, datar, cut} = CutData[data];
   datal = RegisterDiffusionData[{datal, vox}, opts];
   datar = RegisterDiffusionData[{datar, vox}, opts];
   StichData[datal, datar]
   ];

RegisterDiffusionDataSplit[
	{data_, mask_, vox: {_?NumberQ, _?NumberQ, _?NumberQ}}, 
	opts : OptionsPattern[]
	] := Block[{datal, datar, cut,maskr,maskl},
	
	{datal, datar, cut} = CutData[data];
	{maskl, maskr, cut} = CutData[mask,cut];
	datal = RegisterDiffusionData[{datal, maskl, vox}, opts];
	datar = RegisterDiffusionData[{datar, maskr, vox}, opts];
	StichData[datal, datar]
   ];

RegisterDiffusionDataSplit[
	{data_, vox: {_?NumberQ, _?NumberQ, _?NumberQ}}, 
	{dataa_, voxa: {_?NumberQ, _?NumberQ, _?NumberQ}}, 
	opts : OptionsPattern[]
	] := Block[{datal, datar, dataal, dataar, cut1, cut2},
   	
   (*find cuts*)
   {datal, datar, cut1} = CutData[data];
   {dataal, dataar, cut2} = CutData[dataa];
   (*align cuts*)
   {cut1,cut2}=Round[First@Nearest[{cut1 Last@vox, cut2 Last@voxa}, Round[Last@Dimensions[data]/2] Last@vox] / {Last@vox, Last@voxa}];
   (*{cut1,cut2}=Round[Mean[{cut1 vox[[2]], cut2 voxa[[2]]}]/{vox[[2]],voxa[[2]]}];*)
   
   (*cut with the aligned cuts*)
   {datal, datar, cut1} = CutData[data, cut1];
   {dataal, dataar, cut2} = CutData[dataa, cut2];
   
   datal = RegisterDiffusionData[{datal, vox}, {dataal, voxa}, opts][[2]];
   datar = RegisterDiffusionData[{datar, vox}, {dataar, voxa}, opts][[2]];
   StichData[datal, datar]
   ];

RegisterDiffusionDataSplit[
	{data_, mask_, vox: {_?NumberQ, _?NumberQ, _?NumberQ}}, 
	{dataa_, maska_, voxa: {_?NumberQ, _?NumberQ, _?NumberQ}}, 
	opts : OptionsPattern[]
	] := Block[{datal, datar, dataal, dataar, maskl, maskr, maskal, maskar,cut1,cut2},
	
	(*find cuts*)
   {datal, datar, cut1} = CutData[data];
   {dataal, dataar, cut2} = CutData[dataa];
   
   (*align cuts*)
   {cut1,cut2}=Round[First@Nearest[{cut1 Last@vox, cut2 Last@voxa}, Round[Last@Dimensions[data]/2] Last@vox] / {Last@vox, Last@voxa}];
   (*{cut1,cut2}=Round[Mean[{cut1 vox[[2]], cut2 voxa[[2]]}]/{vox[[2]],voxa[[2]]}];*)
   
   (*cut with the aligned cuts*)   
   {datal, datar, cut1} = CutData[data,cut1];
   {maskl, maskr, cut1} = CutData[mask,cut1];
   {dataal, dataar, cut2} = CutData[dataa,cut2];
   {maskal, maskar, cut2} = CutData[maska,cut2];
  
   
   datal = RegisterDiffusionData[{datal, maskl, vox}, {dataal, maskal, voxa}, opts][[2]];
   datar = RegisterDiffusionData[{datar, maskr, vox}, {dataar, maskar, voxa}, opts][[2]];
   
   StichData[datal, datar]
   ];


(* ::Subsection::Closed:: *)
(*RegisterCardiacData*)


Options[RegisterCardiacData]=Join[{RegistrationTarget->"Mean"},Options[RegisterData]];

SyntaxInformation[RegisterCardiacData]={"ArgumentsPattern"->{_,OptionsPattern[]}};

(*data only*)
RegisterCardiacData[data_?ArrayQ, opts:OptionsPattern[]]:=RegisterCardiacData[{data,{1},{1,1,1}},opts]
(*data with voxel*)
RegisterCardiacData[{data_?ArrayQ, vox:{_?NumberQ,_?NumberQ,_?NumberQ}}, opts:OptionsPattern[]]:=RegisterCardiacData[{data,{1},vox},opts]
(*data with mask*)
RegisterCardiacData[{data_?ArrayQ ,mask_?ArrayQ}, opts:OptionsPattern[]]:=RegisterCardiacData[{data,mask,{1,1,1}},opts]
(*data with mask and voxel*)
RegisterCardiacData[{data_?ArrayQ, mask_?ArrayQ, vox:{_?NumberQ,_?NumberQ,_?NumberQ}}, opts:OptionsPattern[]]:=Block[
{tdir, datar, slices, maskr, i, size, target},

tdir=OptionValue[TempDirectory];
tdir=(If[StringQ[tdir],tdir,"Default"]/. {"Default"->$TemporaryDirectory})<>$PathnameSeparator<>"QMRIToolsReg";

If[OptionValue[PrintTempDirectory],PrintTemporary["using as temp directory: "<>tdir]];

slices=Range[Length[data]];
size=Length[data[[1]]];
maskr=If[mask=={1},ConstantArray[1,Dimensions[data[[All,1]]]],mask];

target=If[OptionValue[MethodReg]==="PCAtranslation"||OptionValue[MethodReg]==="PCArigid"||OptionValue[MethodReg]==="PCAaffine"||OptionValue[MethodReg]==="PCAbspline",
	"stack",
	OptionValue[RegistrationTarget]];

(*monitro over slices*)
Monitor[
	i=0;
	datar=Switch[
	target,
	"Mean",
	(i++;RegisterData[{N[Mean@data[[#]]],maskr[[#]],vox},{data[[#]],maskr[[#]],vox},
		OutputTransformation->False, PrintTempDirectory->False,FilterRules[{opts},Options[RegisterData]]])&/@slices,
	"Median",
	(i++;RegisterData[{N[Median@data[[#]]],maskr[[#]],vox},{data[[#]],maskr[[#]],vox},
		OutputTransformation->False, PrintTempDirectory->False,FilterRules[{opts},Options[RegisterData]]])&/@slices,
	"First",
	(i++;RegisterData[{data[[#,1]],maskr[[#]],vox},{data[[#]],maskr[[#]],vox},
		OutputTransformation->False, PrintTempDirectory->False,FilterRules[{opts},Options[RegisterData]]])&/@slices,
	"stack",
	(i++;RegisterData[{data[[#]],ConstantArray[maskr[[#]],size],vox},
		OutputTransformation->False, PrintTempDirectory->False,FilterRules[{opts},Options[RegisterData]]])&/@slices
	]
	,ProgressIndicator[i,{0,Length[data]}]
];
datar
]


(* ::Section:: *)
(*End Package*)


End[]

EndPackage[]
